/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_empty(soap, "tt:InterfaceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Addresses)
	{	int i;
		for (i = 0; i < (int)a->__sizeAddresses; i++)
			if (soap_out_string(soap, "tt:Addresses", -1, (char*const*)(a->Addresses + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Addresses = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Addresses", 1, NULL))
			{	if (a->Addresses == NULL)
				{	if (soap_blist_Addresses == NULL)
						soap_blist_Addresses = soap_alloc_block(soap);
					a->Addresses = (char **)soap_push_block_max(soap, soap_blist_Addresses, sizeof(char *));
					if (a->Addresses == NULL)
						return NULL;
					*a->Addresses = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:Addresses", (char**)a->Addresses, "tt:IPv4Address"))
				{	a->__sizeAddresses++;
					a->Addresses = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Addresses)
			soap_pop_block(soap, soap_blist_Addresses);
		if (a->__sizeAddresses)
		{	a->Addresses = (char **)soap_save_block(soap, soap_blist_Addresses, NULL, 1);
		}
		else
		{	a->Addresses = NULL;
			if (soap_blist_Addresses)
				soap_end_block(soap, soap_blist_Addresses);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_new_tt__NetworkZeroConfiguration(struct soap *soap, int n)
{
	struct tt__NetworkZeroConfiguration *p;
	struct tt__NetworkZeroConfiguration *a = (struct tt__NetworkZeroConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkZeroConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkZeroConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetZeroConfigurationResponse(struct soap *soap, const struct _tds__GetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &a->ZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (!a->ZeroConfiguration)
	{	if (soap_element_empty(soap, "tds:ZeroConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetZeroConfigurationResponse *a, const char *type)
{
	size_t soap_flag_ZeroConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetZeroConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &a->ZeroConfiguration, "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ZeroConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_new__tds__GetZeroConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__GetZeroConfigurationResponse *p;
	struct _tds__GetZeroConfigurationResponse *a = (struct _tds__GetZeroConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetZeroConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetZeroConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetZeroConfigurationResponse(struct soap *soap, const struct _tds__GetZeroConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetZeroConfigurationResponse(soap, tag ? tag : "tds:GetZeroConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetZeroConfiguration(struct soap *soap, const struct _tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__GetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetZeroConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration * SOAP_FMAC4 soap_new__tds__GetZeroConfiguration(struct soap *soap, int n)
{
	struct _tds__GetZeroConfiguration *p;
	struct _tds__GetZeroConfiguration *a = (struct _tds__GetZeroConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetZeroConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__GetZeroConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetZeroConfiguration(struct soap *soap, const struct _tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_new__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkDefaultGatewayResponse *p;
	struct _tds__SetNetworkDefaultGatewayResponse *a = (struct _tds__SetNetworkDefaultGatewayResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkDefaultGatewayResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkDefaultGatewayResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:SetNetworkDefaultGatewayResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->IPv4Address + i));
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, (char*const*)(a->IPv6Address + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			if (soap_out_string(soap, "tds:IPv4Address", -1, (char*const*)(a->IPv4Address + i), ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			if (soap_out_string(soap, "tds:IPv6Address", -1, (char*const*)(a->IPv6Address + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGateway(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (char **)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tds:IPv4Address", (char**)a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (char **)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tds:IPv6Address", (char**)a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_new__tds__SetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct _tds__SetNetworkDefaultGateway *p;
	struct _tds__SetNetworkDefaultGateway *a = (struct _tds__SetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->IPv4Address + i));
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, (char*const*)(a->IPv6Address + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const struct tt__NetworkGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			if (soap_out_string(soap, "tt:IPv4Address", -1, (char*const*)(a->IPv4Address + i), ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			if (soap_out_string(soap, "tt:IPv6Address", -1, (char*const*)(a->IPv6Address + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkGateway(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (char **)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (char **)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_new_tt__NetworkGateway(struct soap *soap, int n)
{
	struct tt__NetworkGateway *p;
	struct tt__NetworkGateway *a = (struct tt__NetworkGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkGateway));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NetworkGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkGateway(soap, &a->NetworkGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (!a->NetworkGateway)
	{	if (soap_element_empty(soap, "tds:NetworkGateway", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->NetworkGateway, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	size_t soap_flag_NetworkGateway = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->NetworkGateway))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_new__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkDefaultGatewayResponse *p;
	struct _tds__GetNetworkDefaultGatewayResponse *a = (struct _tds__GetNetworkDefaultGatewayResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkDefaultGatewayResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkDefaultGatewayResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:GetNetworkDefaultGatewayResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGateway(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_new__tds__GetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct _tds__GetNetworkDefaultGateway *p;
	struct _tds__GetNetworkDefaultGateway *a = (struct _tds__GetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocolsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_new__tds__SetNetworkProtocolsResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkProtocolsResponse *p;
	struct _tds__SetNetworkProtocolsResponse *a = (struct _tds__SetNetworkProtocolsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkProtocolsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkProtocolsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag ? tag : "tds:SetNetworkProtocolsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocols(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_alloc_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block_max(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
		{	a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		}
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkProtocols < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_new__tds__SetNetworkProtocols(struct soap *soap, int n)
{
	struct _tds__SetNetworkProtocols *p;
	struct _tds__SetNetworkProtocols *a = (struct _tds__SetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizePort = 0;
	a->Port = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Port)
	{	int i;
		for (i = 0; i < (int)a->__sizePort; i++)
		{
			soap_embedded(soap, a->Port + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Port)
	{	int i;
		for (i = 0; i < (int)a->__sizePort; i++)
			if (soap_out_int(soap, "tt:Port", -1, a->Port + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Port = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkProtocol(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Port", 1, NULL))
			{	if (a->Port == NULL)
				{	if (soap_blist_Port == NULL)
						soap_blist_Port = soap_alloc_block(soap);
					a->Port = (int *)soap_push_block_max(soap, soap_blist_Port, sizeof(int));
					if (a->Port == NULL)
						return NULL;
					soap_default_int(soap, a->Port);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Port", a->Port, "xsd:int"))
				{	a->__sizePort++;
					a->Port = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Port)
			soap_pop_block(soap, soap_blist_Port);
		if (a->__sizePort)
		{	a->Port = (int *)soap_save_block(soap, soap_blist_Port, NULL, 1);
		}
		else
		{	a->Port = NULL;
			if (soap_blist_Port)
				soap_end_block(soap, soap_blist_Port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_new_tt__NetworkProtocol(struct soap *soap, int n)
{
	struct tt__NetworkProtocol *p;
	struct tt__NetworkProtocol *a = (struct tt__NetworkProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkProtocol));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkProtocols");
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocolsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_alloc_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block_max(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
		{	a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		}
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_new__tds__GetNetworkProtocolsResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkProtocolsResponse *p;
	struct _tds__GetNetworkProtocolsResponse *a = (struct _tds__GetNetworkProtocolsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkProtocolsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkProtocolsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag ? tag : "tds:GetNetworkProtocolsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocols(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_new__tds__GetNetworkProtocols(struct soap *soap, int n)
{
	struct _tds__GetNetworkProtocols *p;
	struct _tds__GetNetworkProtocols *a = (struct _tds__GetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfacesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_new__tds__SetNetworkInterfacesResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkInterfacesResponse *p;
	struct _tds__SetNetworkInterfacesResponse *a = (struct _tds__SetNetworkInterfacesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkInterfacesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkInterfacesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag ? tag : "tds:SetNetworkInterfacesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->Link = NULL;
	a->MTU = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->Link);
	soap_serialize_PointerToint(soap, &a->MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_MTU = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link--;
					continue;
				}
			}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv4--;
					continue;
				}
			}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv6--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_new_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceSetConfiguration *p;
	struct tt__NetworkInterfaceSetConfiguration *a = (struct tt__NetworkInterfaceSetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceSetConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceSetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	a->NetworkInterface = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &a->NetworkInterface);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_empty(soap, "tds:InterfaceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	if (!a->NetworkInterface)
	{	if (soap_element_empty(soap, "tds:NetworkInterface", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->NetworkInterface, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_NetworkInterface = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfaces(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			}
			if (soap_flag_NetworkInterface && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || !a->NetworkInterface))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_new__tds__SetNetworkInterfaces(struct soap *soap, int n)
{
	struct _tds__SetNetworkInterfaces *p;
	struct _tds__SetNetworkInterfaces *a = (struct _tds__SetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Info = NULL;
	a->Link = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &a->Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &a->Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterface *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Info = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterface(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info--;
					continue;
				}
			}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link--;
					continue;
				}
			}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv4--;
					continue;
				}
			}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv6--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_new_tt__NetworkInterface(struct soap *soap, int n)
{
	struct tt__NetworkInterface *p;
	struct tt__NetworkInterface *a = (struct tt__NetworkInterface*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterface));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterface(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkInterfaces = 0;
	a->NetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkInterfaces; i++)
		{
			soap_embedded(soap, a->NetworkInterfaces + i, SOAP_TYPE_tt__NetworkInterface);
			soap_serialize_tt__NetworkInterface(soap, a->NetworkInterfaces + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkInterfaces");
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkInterfaces; i++)
			if (soap_out_tt__NetworkInterface(soap, "tds:NetworkInterfaces", -1, a->NetworkInterfaces + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkInterfaces = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfacesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
			{	if (a->NetworkInterfaces == NULL)
				{	if (soap_blist_NetworkInterfaces == NULL)
						soap_blist_NetworkInterfaces = soap_alloc_block(soap);
					a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_push_block_max(soap, soap_blist_NetworkInterfaces, sizeof(struct tt__NetworkInterface));
					if (a->NetworkInterfaces == NULL)
						return NULL;
					soap_default_tt__NetworkInterface(soap, a->NetworkInterfaces);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkInterface(soap, "tds:NetworkInterfaces", a->NetworkInterfaces, "tt:NetworkInterface"))
				{	a->__sizeNetworkInterfaces++;
					a->NetworkInterfaces = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkInterfaces)
			soap_pop_block(soap, soap_blist_NetworkInterfaces);
		if (a->__sizeNetworkInterfaces)
		{	a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_save_block(soap, soap_blist_NetworkInterfaces, NULL, 1);
		}
		else
		{	a->NetworkInterfaces = NULL;
			if (soap_blist_NetworkInterfaces)
				soap_end_block(soap, soap_blist_NetworkInterfaces);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkInterfaces < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_new__tds__GetNetworkInterfacesResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkInterfacesResponse *p;
	struct _tds__GetNetworkInterfacesResponse *a = (struct _tds__GetNetworkInterfacesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkInterfacesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkInterfacesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag ? tag : "tds:GetNetworkInterfacesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfaces(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_new__tds__GetNetworkInterfaces(struct soap *soap, int n)
{
	struct _tds__GetNetworkInterfaces *p;
	struct _tds__GetNetworkInterfaces *a = (struct _tds__GetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNSResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_new__tds__SetDynamicDNSResponse(struct soap *soap, int n)
{
	struct _tds__SetDynamicDNSResponse *p;
	struct _tds__SetDynamicDNSResponse *a = (struct _tds__SetDynamicDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDynamicDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDynamicDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag ? tag : "tds:SetDynamicDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	soap_default_tt__DNSName(soap, &a->Name);
	soap_default_xsd__duration(soap, &a->TTL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__DNSName(soap, (char*const*)&a->Name);
	soap_serialize_xsd__duration(soap, (char*const*)&a->TTL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tds:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:TTL", -1, (char*const*)&a->TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__DNSName(soap, "tds:Name", (char**)&a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:TTL", (char**)&a->TTL, "xsd:duration"))
				{	soap_flag_TTL--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_new__tds__SetDynamicDNS(struct soap *soap, int n)
{
	struct _tds__SetDynamicDNS *p;
	struct _tds__SetDynamicDNS *a = (struct _tds__SetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	soap_default_tt__DNSName(soap, &a->Name);
	soap_default_xsd__duration(soap, &a->TTL);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__DNSName(soap, (char*const*)&a->Name);
	soap_serialize_xsd__duration(soap, (char*const*)&a->TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:TTL", -1, (char*const*)&a->TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DynamicDNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DynamicDNSInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__DNSName(soap, "tt:Name", (char**)&a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:TTL", (char**)&a->TTL, "xsd:duration"))
				{	soap_flag_TTL--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_new_tt__DynamicDNSInformation(struct soap *soap, int n)
{
	struct tt__DynamicDNSInformation *p;
	struct tt__DynamicDNSInformation *a = (struct tt__DynamicDNSInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DynamicDNSInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__DynamicDNSInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DynamicDNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &a->DynamicDNSInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (!a->DynamicDNSInformation)
	{	if (soap_element_empty(soap, "tds:DynamicDNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->DynamicDNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	size_t soap_flag_DynamicDNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNSResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DynamicDNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_new__tds__GetDynamicDNSResponse(struct soap *soap, int n)
{
	struct _tds__GetDynamicDNSResponse *p;
	struct _tds__GetDynamicDNSResponse *a = (struct _tds__GetDynamicDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDynamicDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDynamicDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag ? tag : "tds:GetDynamicDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_new__tds__GetDynamicDNS(struct soap *soap, int n)
{
	struct _tds__GetDynamicDNS *p;
	struct _tds__GetDynamicDNS *a = (struct _tds__GetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTPResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_new__tds__SetNTPResponse(struct soap *soap, int n)
{
	struct _tds__SetNTPResponse *p;
	struct _tds__SetNTPResponse *a = (struct _tds__SetNTPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNTPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNTPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNTPResponse(soap, tag ? tag : "tds:SetNTPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const struct _tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_alloc_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
		{	a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		}
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_new__tds__SetNTP(struct soap *soap, int n)
{
	struct _tds__SetNTP *p;
	struct _tds__SetNTP *a = (struct _tds__SetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNTP));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeNTPFromDHCP = 0;
	a->NTPFromDHCP = NULL;
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPFromDHCP; i++)
		{
			soap_embedded(soap, a->NTPFromDHCP + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPFromDHCP + i);
		}
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
	soap_serialize_PointerTott__NTPInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const struct tt__NTPInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPFromDHCP; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPFromDHCP", -1, a->NTPFromDHCP + i, ""))
				return soap->error;
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPFromDHCP = NULL;
	struct soap_blist *soap_blist_NTPManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NTPInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NTPInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPFromDHCP", 1, NULL))
			{	if (a->NTPFromDHCP == NULL)
				{	if (soap_blist_NTPFromDHCP == NULL)
						soap_blist_NTPFromDHCP = soap_alloc_block(soap);
					a->NTPFromDHCP = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPFromDHCP, sizeof(struct tt__NetworkHost));
					if (a->NTPFromDHCP == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPFromDHCP", a->NTPFromDHCP, "tt:NetworkHost"))
				{	a->__sizeNTPFromDHCP++;
					a->NTPFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_alloc_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPFromDHCP)
			soap_pop_block(soap, soap_blist_NTPFromDHCP);
		if (a->__sizeNTPFromDHCP)
		{	a->NTPFromDHCP = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPFromDHCP, NULL, 1);
		}
		else
		{	a->NTPFromDHCP = NULL;
			if (soap_blist_NTPFromDHCP)
				soap_end_block(soap, soap_blist_NTPFromDHCP);
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
		{	a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		}
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_new_tt__NTPInformation(struct soap *soap, int n)
{
	struct tt__NTPInformation *p;
	struct tt__NTPInformation *a = (struct tt__NTPInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NTPInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__NTPInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NTPInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NTPInformation(soap, &a->NTPInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (!a->NTPInformation)
	{	if (soap_element_empty(soap, "tds:NTPInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->NTPInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse *a, const char *type)
{
	size_t soap_flag_NTPInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTPResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->NTPInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_new__tds__GetNTPResponse(struct soap *soap, int n)
{
	struct _tds__GetNTPResponse *p;
	struct _tds__GetNTPResponse *a = (struct _tds__GetNTPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNTPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNTPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNTPResponse(soap, tag ? tag : "tds:GetNTPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const struct _tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_new__tds__GetNTP(struct soap *soap, int n)
{
	struct _tds__GetNTP *p;
	struct _tds__GetNTP *a = (struct _tds__GetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNTP));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNSResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_new__tds__SetDNSResponse(struct soap *soap, int n)
{
	struct _tds__SetDNSResponse *p;
	struct _tds__SetDNSResponse *a = (struct _tds__SetDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDNSResponse(soap, tag ? tag : "tds:SetDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddress(struct soap *soap, struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const struct tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddress(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->Type, "tt:IPType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_new_tt__IPAddress(struct soap *soap, int n)
{
	struct tt__IPAddress *p;
	struct tt__IPAddress *a = (struct tt__IPAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddress));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, struct tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->SearchDomain + i));
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
			if (soap_out_string(soap, "tds:SearchDomain", -1, (char*const*)(a->SearchDomain + i), ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tds:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_alloc_block(soap);
					a->SearchDomain = (char **)soap_push_block_max(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:SearchDomain", (char**)a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_alloc_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tds:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
		{	a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		}
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
		{	a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		}
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_new__tds__SetDNS(struct soap *soap, int n)
{
	struct _tds__SetDNS *p;
	struct _tds__SetDNS *a = (struct _tds__SetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSFromDHCP = 0;
	a->DNSFromDHCP = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->SearchDomain + i));
		}
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSFromDHCP; i++)
		{
			soap_embedded(soap, a->DNSFromDHCP + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSFromDHCP + i);
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
	soap_serialize_PointerTott__DNSInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
			if (soap_out_string(soap, "tt:SearchDomain", -1, (char*const*)(a->SearchDomain + i), ""))
				return soap->error;
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSFromDHCP; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSFromDHCP", -1, a->DNSFromDHCP + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSFromDHCP = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DNSInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_alloc_block(soap);
					a->SearchDomain = (char **)soap_push_block_max(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:SearchDomain", (char**)a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSFromDHCP", 1, NULL))
			{	if (a->DNSFromDHCP == NULL)
				{	if (soap_blist_DNSFromDHCP == NULL)
						soap_blist_DNSFromDHCP = soap_alloc_block(soap);
					a->DNSFromDHCP = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSFromDHCP, sizeof(struct tt__IPAddress));
					if (a->DNSFromDHCP == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSFromDHCP", a->DNSFromDHCP, "tt:IPAddress"))
				{	a->__sizeDNSFromDHCP++;
					a->DNSFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_alloc_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
		{	a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		}
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSFromDHCP)
			soap_pop_block(soap, soap_blist_DNSFromDHCP);
		if (a->__sizeDNSFromDHCP)
		{	a->DNSFromDHCP = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSFromDHCP, NULL, 1);
		}
		else
		{	a->DNSFromDHCP = NULL;
			if (soap_blist_DNSFromDHCP)
				soap_end_block(soap, soap_blist_DNSFromDHCP);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
		{	a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		}
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_new_tt__DNSInformation(struct soap *soap, int n)
{
	struct tt__DNSInformation *p;
	struct tt__DNSInformation *a = (struct tt__DNSInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DNSInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__DNSInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSInformation(soap, &a->DNSInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (!a->DNSInformation)
	{	if (soap_element_empty(soap, "tds:DNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->DNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse *a, const char *type)
{
	size_t soap_flag_DNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNSResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_new__tds__GetDNSResponse(struct soap *soap, int n)
{
	struct _tds__GetDNSResponse *p;
	struct _tds__GetDNSResponse *a = (struct _tds__GetDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDNSResponse(soap, tag ? tag : "tds:GetDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_new__tds__GetDNS(struct soap *soap, int n)
{
	struct _tds__GetDNS *p;
	struct _tds__GetDNS *a = (struct _tds__GetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetHostnameFromDHCPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCPResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_new__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n)
{
	struct _tds__SetHostnameFromDHCPResponse *p;
	struct _tds__SetHostnameFromDHCPResponse *a = (struct _tds__SetHostnameFromDHCPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameFromDHCPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameFromDHCPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag ? tag : "tds:SetHostnameFromDHCPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetHostnameFromDHCP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_new__tds__SetHostnameFromDHCP(struct soap *soap, int n)
{
	struct _tds__SetHostnameFromDHCP *p;
	struct _tds__SetHostnameFromDHCP *a = (struct _tds__SetHostnameFromDHCP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameFromDHCP));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameFromDHCP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_new__tds__SetHostnameResponse(struct soap *soap, int n)
{
	struct _tds__SetHostnameResponse *p;
	struct _tds__SetHostnameResponse *a = (struct _tds__SetHostnameResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameResponse(soap, tag ? tag : "tds:SetHostnameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const struct _tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tds:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tds:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostname(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:Name", (char**)&a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_new__tds__SetHostname(struct soap *soap, int n)
{
	struct _tds__SetHostname *p;
	struct _tds__SetHostname *a = (struct _tds__SetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostname));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	soap_default_xsd__token(soap, &a->Name);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	soap_serialize_xsd__token(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__HostnameInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__HostnameInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:Name", (char**)&a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_new_tt__HostnameInformation(struct soap *soap, int n)
{
	struct tt__HostnameInformation *p;
	struct tt__HostnameInformation *a = (struct tt__HostnameInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__HostnameInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__HostnameInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostnameInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__HostnameInformation(soap, &a->HostnameInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (!a->HostnameInformation)
	{	if (soap_element_empty(soap, "tds:HostnameInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->HostnameInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse *a, const char *type)
{
	size_t soap_flag_HostnameInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostnameResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->HostnameInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_new__tds__GetHostnameResponse(struct soap *soap, int n)
{
	struct _tds__GetHostnameResponse *p;
	struct _tds__GetHostnameResponse *a = (struct _tds__GetHostnameResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetHostnameResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetHostnameResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetHostnameResponse(soap, tag ? tag : "tds:GetHostnameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const struct _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostname(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_new__tds__GetHostname(struct soap *soap, int n)
{
	struct _tds__GetHostname *p;
	struct _tds__GetHostname *a = (struct _tds__GetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetHostname));
	for (p = a; p && n--; p++)
		soap_default__tds__GetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics--;
					continue;
				}
			}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging--;
					continue;
				}
			}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_new_tt__Capabilities(struct soap *soap, int n)
{
	struct tt__Capabilities *p;
	struct tt__Capabilities *a = (struct tt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetCapabilitiesResponse *p;
	struct _tds__GetCapabilitiesResponse *a = (struct _tds__GetCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->Category == NULL)
				{	if (soap_blist_Category == NULL)
						soap_blist_Category = soap_alloc_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block_max(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
		{	a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		}
		else
		{	a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_new__tds__GetCapabilities(struct soap *soap, int n)
{
	struct _tds__GetCapabilities *p;
	struct _tds__GetCapabilities *a = (struct _tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->WsdlUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->WsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	if (a->WsdlUrl)
		soap_element_result(soap, "tds:WsdlUrl");
	if (!a->WsdlUrl)
	{	if (soap_element_empty(soap, "tds:WsdlUrl", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, (char*const*)&a->WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	size_t soap_flag_WsdlUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetWsdlUrlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", (char**)&a->WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl--;
					continue;
				}
			}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->WsdlUrl))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_new__tds__GetWsdlUrlResponse(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrlResponse *p;
	struct _tds__GetWsdlUrlResponse *a = (struct _tds__GetWsdlUrlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrlResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetWsdlUrl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_new__tds__GetWsdlUrl(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrl *p;
	struct _tds__GetWsdlUrl *a = (struct _tds__GetWsdlUrl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrl));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_new__tds__SetUserResponse(struct soap *soap, int n)
{
	struct _tds__SetUserResponse *p;
	struct _tds__SetUserResponse *a = (struct _tds__SetUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUserResponse(soap, tag ? tag : "tds:SetUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUser(struct soap *soap, struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const struct _tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_new__tds__SetUser(struct soap *soap, int n)
{
	struct _tds__SetUser *p;
	struct _tds__SetUser *a = (struct _tds__SetUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, struct _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_new__tds__DeleteUsersResponse(struct soap *soap, int n)
{
	struct _tds__DeleteUsersResponse *p;
	struct _tds__DeleteUsersResponse *a = (struct _tds__DeleteUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsersResponse(soap, tag ? tag : "tds:DeleteUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUsername = 0;
	a->Username = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Username + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
			if (soap_out_string(soap, "tds:Username", -1, (char*const*)(a->Username + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers *a, const char *type)
{
	struct soap_blist *soap_blist_Username = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	if (a->Username == NULL)
				{	if (soap_blist_Username == NULL)
						soap_blist_Username = soap_alloc_block(soap);
					a->Username = (char **)soap_push_block_max(soap, soap_blist_Username, sizeof(char *));
					if (a->Username == NULL)
						return NULL;
					*a->Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", (char**)a->Username, "xsd:string"))
				{	a->__sizeUsername++;
					a->Username = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Username)
			soap_pop_block(soap, soap_blist_Username);
		if (a->__sizeUsername)
		{	a->Username = (char **)soap_save_block(soap, soap_blist_Username, NULL, 1);
		}
		else
		{	a->Username = NULL;
			if (soap_blist_Username)
				soap_end_block(soap, soap_blist_Username);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_new__tds__DeleteUsers(struct soap *soap, int n)
{
	struct _tds__DeleteUsers *p;
	struct _tds__DeleteUsers *a = (struct _tds__DeleteUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_new__tds__CreateUsersResponse(struct soap *soap, int n)
{
	struct _tds__CreateUsersResponse *p;
	struct _tds__CreateUsersResponse *a = (struct _tds__CreateUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsersResponse(soap, tag ? tag : "tds:CreateUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_new__tds__CreateUsers(struct soap *soap, int n)
{
	struct _tds__CreateUsers *p;
	struct _tds__CreateUsers *a = (struct _tds__CreateUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__User(struct soap *soap, struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_tt__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__User(struct soap *soap, const struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTott__UserExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const struct tt__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "tt:Username", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, struct tt__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__User*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__User(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->Extension, "tt:UserExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UserLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_new_tt__User(struct soap *soap, int n)
{
	struct tt__User *p;
	struct tt__User *a = (struct tt__User*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__User));
	for (p = a; p && n--; p++)
		soap_default_tt__User(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__User(struct soap *soap, const struct tt__User *a, const char *tag, const char *type)
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, struct tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_new__tds__GetUsersResponse(struct soap *soap, int n)
{
	struct _tds__GetUsersResponse *p;
	struct _tds__GetUsersResponse *a = (struct _tds__GetUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsersResponse(soap, tag ? tag : "tds:GetUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const struct _tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_new__tds__GetUsers(struct soap *soap, int n)
{
	struct _tds__GetUsers *p;
	struct _tds__GetUsers *a = (struct _tds__GetUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__SetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteUserResponse *p;
	struct _tds__SetRemoteUserResponse *a = (struct _tds__SetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUserResponse(soap, tag ? tag : "tds:SetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_new__tds__SetRemoteUser(struct soap *soap, int n)
{
	struct _tds__SetRemoteUser *p;
	struct _tds__SetRemoteUser *a = (struct _tds__SetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__boolean(soap, &a->UseDerivedPassword);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_embedded(soap, &a->UseDerivedPassword, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const struct tt__RemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "tt:Username", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:UseDerivedPassword", -1, &a->UseDerivedPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UseDerivedPassword = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RemoteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_UseDerivedPassword && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:UseDerivedPassword", &a->UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UseDerivedPassword > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_new_tt__RemoteUser(struct soap *soap, int n)
{
	struct tt__RemoteUser *p;
	struct tt__RemoteUser *a = (struct tt__RemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RemoteUser));
	for (p = a; p && n--; p++)
		soap_default_tt__RemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a, const char *tag, const char *type)
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__GetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteUserResponse *p;
	struct _tds__GetRemoteUserResponse *a = (struct _tds__GetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUserResponse(soap, tag ? tag : "tds:GetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_new__tds__GetRemoteUser(struct soap *soap, int n)
{
	struct _tds__GetRemoteUser *p;
	struct _tds__GetRemoteUser *a = (struct _tds__GetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GUID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->GUID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	if (a->GUID)
		soap_element_result(soap, "tds:GUID");
	if (!a->GUID)
	{	if (soap_element_empty(soap, "tds:GUID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:GUID", -1, (char*const*)&a->GUID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	size_t soap_flag_GUID = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetEndpointReferenceResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReferenceResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:GUID", (char**)&a->GUID, "xsd:string"))
				{	soap_flag_GUID--;
					continue;
				}
			}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->GUID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_new__tds__GetEndpointReferenceResponse(struct soap *soap, int n)
{
	struct _tds__GetEndpointReferenceResponse *p;
	struct _tds__GetEndpointReferenceResponse *a = (struct _tds__GetEndpointReferenceResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReferenceResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReferenceResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag ? tag : "tds:GetEndpointReferenceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetEndpointReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReference(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_new__tds__GetEndpointReference(struct soap *soap, int n)
{
	struct _tds__GetEndpointReference *p;
	struct _tds__GetEndpointReference *a = (struct _tds__GetEndpointReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReference));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddressesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__SetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__SetDPAddressesResponse *p;
	struct _tds__SetDPAddressesResponse *a = (struct _tds__SetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddressesResponse(soap, tag ? tag : "tds:SetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddresses(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_new__tds__SetDPAddresses(struct soap *soap, int n)
{
	struct _tds__SetDPAddresses *p;
	struct _tds__SetDPAddresses *a = (struct _tds__SetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
	soap_default_tt__DNSName(soap, &a->DNSname);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
	soap_serialize_tt__DNSName(soap, (char*const*)&a->DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const struct tt__NetworkHost *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tt:DNSname", -1, (char*const*)&a->DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkHost*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHost(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->Type, "tt:NetworkHostType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			}
			if (soap_flag_DNSname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__DNSName(soap, "tt:DNSname", (char**)&a->DNSname, "tt:DNSName"))
				{	soap_flag_DNSname--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_new_tt__NetworkHost(struct soap *soap, int n)
{
	struct tt__NetworkHost *p;
	struct tt__NetworkHost *a = (struct tt__NetworkHost*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkHost));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHost(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDPAddress");
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddressesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__GetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__GetDPAddressesResponse *p;
	struct _tds__GetDPAddressesResponse *a = (struct _tds__GetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddressesResponse(soap, tag ? tag : "tds:GetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddresses(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_new__tds__GetDPAddresses(struct soap *soap, int n)
{
	struct _tds__GetDPAddresses *p;
	struct _tds__GetDPAddresses *a = (struct _tds__GetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryModeResponse *p;
	struct _tds__SetRemoteDiscoveryModeResponse *a = (struct _tds__SetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:SetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryMode *p;
	struct _tds__SetRemoteDiscoveryMode *a = (struct _tds__SetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryModeResponse *p;
	struct _tds__GetRemoteDiscoveryModeResponse *a = (struct _tds__GetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:GetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryMode *p;
	struct _tds__GetRemoteDiscoveryMode *a = (struct _tds__GetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryModeResponse *p;
	struct _tds__SetDiscoveryModeResponse *a = (struct _tds__SetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag ? tag : "tds:SetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryMode *p;
	struct _tds__SetDiscoveryMode *a = (struct _tds__SetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryModeResponse *p;
	struct _tds__GetDiscoveryModeResponse *a = (struct _tds__GetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag ? tag : "tds:GetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryMode *p;
	struct _tds__GetDiscoveryMode *a = (struct _tds__GetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopeItem");
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_new__tds__RemoveScopesResponse(struct soap *soap, int n)
{
	struct _tds__RemoveScopesResponse *p;
	struct _tds__RemoveScopesResponse *a = (struct _tds__RemoveScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopesResponse(soap, tag ? tag : "tds:RemoveScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_new__tds__RemoveScopes(struct soap *soap, int n)
{
	struct _tds__RemoveScopes *p;
	struct _tds__RemoveScopes *a = (struct _tds__RemoveScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_new__tds__AddScopesResponse(struct soap *soap, int n)
{
	struct _tds__AddScopesResponse *p;
	struct _tds__AddScopesResponse *a = (struct _tds__AddScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopesResponse(soap, tag ? tag : "tds:AddScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const struct _tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_new__tds__AddScopes(struct soap *soap, int n)
{
	struct _tds__AddScopes *p;
	struct _tds__AddScopes *a = (struct _tds__AddScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_new__tds__SetScopesResponse(struct soap *soap, int n)
{
	struct _tds__SetScopesResponse *p;
	struct _tds__SetScopesResponse *a = (struct _tds__SetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopesResponse(soap, tag ? tag : "tds:SetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->Scopes + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const struct _tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			if (soap_out_string(soap, "tds:Scopes", -1, (char*const*)(a->Scopes + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (char **)soap_push_block_max(soap, soap_blist_Scopes, sizeof(char *));
					if (a->Scopes == NULL)
						return NULL;
					*a->Scopes = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:Scopes", (char**)a->Scopes, "xsd:anyURI"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (char **)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_new__tds__SetScopes(struct soap *soap, int n)
{
	struct _tds__SetScopes *p;
	struct _tds__SetScopes *a = (struct _tds__SetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Scope(struct soap *soap, struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &a->ScopeDef);
	soap_default_xsd__anyURI(soap, &a->ScopeItem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Scope(struct soap *soap, const struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ScopeItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const struct tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->ScopeDef, ""))
		return soap->error;
	if (!a->ScopeItem)
	{	if (soap_element_empty(soap, "tt:ScopeItem", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, (char*const*)&a->ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, struct tt__Scope *a, const char *type)
{
	size_t soap_flag_ScopeDef = 1;
	size_t soap_flag_ScopeItem = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Scope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef--;
					continue;
				}
			}
			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", (char**)&a->ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || !a->ScopeItem))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_new_tt__Scope(struct soap *soap, int n)
{
	struct tt__Scope *p;
	struct tt__Scope *a = (struct tt__Scope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Scope));
	for (p = a; p && n--; p++)
		soap_default_tt__Scope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Scope(struct soap *soap, const struct tt__Scope *a, const char *tag, const char *type)
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, struct tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_embedded(soap, a->Scopes + i, SOAP_TYPE_tt__Scope);
			soap_serialize_tt__Scope(soap, a->Scopes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopes");
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			if (soap_out_tt__Scope(soap, "tds:Scopes", -1, a->Scopes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (struct tt__Scope *)soap_push_block_max(soap, soap_blist_Scopes, sizeof(struct tt__Scope));
					if (a->Scopes == NULL)
						return NULL;
					soap_default_tt__Scope(soap, a->Scopes);
				}
				soap_revert(soap);
				if (soap_in_tt__Scope(soap, "tds:Scopes", a->Scopes, "tt:Scope"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (struct tt__Scope *)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_new__tds__GetScopesResponse(struct soap *soap, int n)
{
	struct _tds__GetScopesResponse *p;
	struct _tds__GetScopesResponse *a = (struct _tds__GetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopesResponse(soap, tag ? tag : "tds:GetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const struct _tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_new__tds__GetScopes(struct soap *soap, int n)
{
	struct _tds__GetScopes *p;
	struct _tds__GetScopes *a = (struct _tds__GetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLog(struct soap *soap, struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const struct tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_new_tt__SystemLog(struct soap *soap, int n)
{
	struct tt__SystemLog *p;
	struct tt__SystemLog *a = (struct tt__SystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLog));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, struct tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLog(soap, &a->SystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (!a->SystemLog)
	{	if (soap_element_empty(soap, "tds:SystemLog", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse *a, const char *type)
{
	size_t soap_flag_SystemLog = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemLogResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLogResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SystemLog))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_new__tds__GetSystemLogResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemLogResponse *p;
	struct _tds__GetSystemLogResponse *a = (struct _tds__GetSystemLogResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLogResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLogResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLogResponse(soap, tag ? tag : "tds:GetSystemLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->LogType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_LogType = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->LogType, "tt:SystemLogType"))
				{	soap_flag_LogType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_new__tds__GetSystemLog(struct soap *soap, int n)
{
	struct _tds__GetSystemLog *p;
	struct _tds__GetSystemLog *a = (struct _tds__GetSystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLog));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const struct tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_new_tt__SupportInformation(struct soap *soap, int n)
{
	struct tt__SupportInformation *p;
	struct tt__SupportInformation *a = (struct tt__SupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportInformation(soap, &a->SupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (!a->SupportInformation)
	{	if (soap_element_empty(soap, "tds:SupportInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->SupportInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	size_t soap_flag_SupportInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemSupportInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformationResponse *p;
	struct _tds__GetSystemSupportInformationResponse *a = (struct _tds__GetSystemSupportInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag ? tag : "tds:GetSystemSupportInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemSupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformation(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformation *p;
	struct _tds__GetSystemSupportInformation *a = (struct _tds__GetSystemSupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeBackupFiles");
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemBackupResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackupResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_alloc_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block_max(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeBackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
		{	a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		}
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_new__tds__GetSystemBackupResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemBackupResponse *p;
	struct _tds__GetSystemBackupResponse *a = (struct _tds__GetSystemBackupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackupResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemBackup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackup(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_new__tds__GetSystemBackup(struct soap *soap, int n)
{
	struct _tds__GetSystemBackup *p;
	struct _tds__GetSystemBackup *a = (struct _tds__GetSystemBackup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackup));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
