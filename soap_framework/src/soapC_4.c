/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IANA_IfTypes(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tt__IANA_IfTypes);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_tt__IANA_IfTypes(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_tt__IANA_IfTypes);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IANA_IfTypes(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_tt__IANA_IfTypes(soap, tag ? tag : "tt:IANA-IfTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_tt__IANA_IfTypes(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IANA_IfTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *p;
	float *a = (float*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(float));
	for (p = a; p && n--; p++)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *p;
	double *a = (double*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(double));
	for (p = a; p && n--; p++)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *p;
	unsigned char *a = (unsigned char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned char));
	for (p = a; p && n--; p++)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__MetadataVersion(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__MetadataVersion(soap, tag ? tag : "wsdd:MetadataVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyAfter(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyAfter(soap, tag ? tag : "wsa:ReplyAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *p;
	unsigned int *a = (unsigned int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned int));
	for (p = a; p && n--; p++)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *p;
	ULONG64 *a = (ULONG64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(ULONG64));
	for (p = a; p && n--; p++)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *p;
	time_t *a = (time_t*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(time_t));
	for (p = a; p && n--; p++)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Entity[] =
{	{ (LONG64)tt__Entity__Device, "Device" },
	{ (LONG64)tt__Entity__VideoSource, "VideoSource" },
	{ (LONG64)tt__Entity__AudioSource, "AudioSource" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Entity2s(struct soap *soap, enum tt__Entity n)
{
	const char *s = soap_code_str(soap_codes_tt__Entity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Entity(struct soap *soap, const char *tag, int id, const enum tt__Entity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Entity), type) || soap_send(soap, soap_tt__Entity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Entity(struct soap *soap, const char *s, enum tt__Entity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Entity, s);
	if (map)
		*a = (enum tt__Entity)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Entity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Entity * SOAP_FMAC4 soap_in_tt__Entity(struct soap *soap, const char *tag, enum tt__Entity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Entity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Entity, sizeof(enum tt__Entity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Entity(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Entity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Entity, SOAP_TYPE_tt__Entity, sizeof(enum tt__Entity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Entity * SOAP_FMAC4 soap_new_tt__Entity(struct soap *soap, int n)
{
	enum tt__Entity *p;
	enum tt__Entity *a = (enum tt__Entity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Entity));
	for (p = a; p && n--; p++)
		soap_default_tt__Entity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Entity(struct soap *soap, const enum tt__Entity *a, const char *tag, const char *type)
{
	if (soap_out_tt__Entity(soap, tag ? tag : "tt:Entity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Entity * SOAP_FMAC4 soap_get_tt__Entity(struct soap *soap, enum tt__Entity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MoveStatus[] =
{	{ (LONG64)tt__MoveStatus__IDLE, "IDLE" },
	{ (LONG64)tt__MoveStatus__MOVING, "MOVING" },
	{ (LONG64)tt__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap *soap, enum tt__MoveStatus n)
{
	const char *s = soap_code_str(soap_codes_tt__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap *soap, const char *tag, int id, const enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveStatus), type) || soap_send(soap, soap_tt__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap *soap, const char *s, enum tt__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveStatus, s);
	if (map)
		*a = (enum tt__MoveStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MoveStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_new_tt__MoveStatus(struct soap *soap, int n)
{
	enum tt__MoveStatus *p;
	enum tt__MoveStatus *a = (enum tt__MoveStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MoveStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap *soap, const enum tt__MoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__OSDType[] =
{	{ (LONG64)tt__OSDType__Text, "Text" },
	{ (LONG64)tt__OSDType__Image, "Image" },
	{ (LONG64)tt__OSDType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__OSDType2s(struct soap *soap, enum tt__OSDType n)
{
	const char *s = soap_code_str(soap_codes_tt__OSDType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDType(struct soap *soap, const char *tag, int id, const enum tt__OSDType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDType), type) || soap_send(soap, soap_tt__OSDType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__OSDType(struct soap *soap, const char *s, enum tt__OSDType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__OSDType, s);
	if (map)
		*a = (enum tt__OSDType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__OSDType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__OSDType * SOAP_FMAC4 soap_in_tt__OSDType(struct soap *soap, const char *tag, enum tt__OSDType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__OSDType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__OSDType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__OSDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDType, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__OSDType * SOAP_FMAC4 soap_new_tt__OSDType(struct soap *soap, int n)
{
	enum tt__OSDType *p;
	enum tt__OSDType *a = (enum tt__OSDType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__OSDType));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDType(struct soap *soap, const enum tt__OSDType *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDType(soap, tag ? tag : "tt:OSDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__OSDType * SOAP_FMAC4 soap_get_tt__OSDType(struct soap *soap, enum tt__OSDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioClassType[] =
{	{ (LONG64)tt__AudioClassType__gun_USCOREshot, "gun_shot" },
	{ (LONG64)tt__AudioClassType__scream, "scream" },
	{ (LONG64)tt__AudioClassType__glass_USCOREbreaking, "glass_breaking" },
	{ (LONG64)tt__AudioClassType__tire_USCOREscreech, "tire_screech" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioClassType2s(struct soap *soap, enum tt__AudioClassType n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioClassType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassType(struct soap *soap, const char *tag, int id, const enum tt__AudioClassType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassType), type) || soap_send(soap, soap_tt__AudioClassType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioClassType(struct soap *soap, const char *s, enum tt__AudioClassType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioClassType, s);
	if (map)
		*a = (enum tt__AudioClassType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioClassType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioClassType * SOAP_FMAC4 soap_in_tt__AudioClassType(struct soap *soap, const char *tag, enum tt__AudioClassType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioClassType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassType, sizeof(enum tt__AudioClassType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioClassType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassType, SOAP_TYPE_tt__AudioClassType, sizeof(enum tt__AudioClassType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioClassType * SOAP_FMAC4 soap_new_tt__AudioClassType(struct soap *soap, int n)
{
	enum tt__AudioClassType *p;
	enum tt__AudioClassType *a = (enum tt__AudioClassType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioClassType));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassType(struct soap *soap, const enum tt__AudioClassType *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassType(soap, tag ? tag : "tt:AudioClassType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioClassType * SOAP_FMAC4 soap_get_tt__AudioClassType(struct soap *soap, enum tt__AudioClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ModeOfOperation[] =
{	{ (LONG64)tt__ModeOfOperation__Idle, "Idle" },
	{ (LONG64)tt__ModeOfOperation__Active, "Active" },
	{ (LONG64)tt__ModeOfOperation__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ModeOfOperation2s(struct soap *soap, enum tt__ModeOfOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__ModeOfOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ModeOfOperation(struct soap *soap, const char *tag, int id, const enum tt__ModeOfOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ModeOfOperation), type) || soap_send(soap, soap_tt__ModeOfOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ModeOfOperation(struct soap *soap, const char *s, enum tt__ModeOfOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ModeOfOperation, s);
	if (map)
		*a = (enum tt__ModeOfOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ModeOfOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ModeOfOperation * SOAP_FMAC4 soap_in_tt__ModeOfOperation(struct soap *soap, const char *tag, enum tt__ModeOfOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ModeOfOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ModeOfOperation, sizeof(enum tt__ModeOfOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ModeOfOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ModeOfOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ModeOfOperation, SOAP_TYPE_tt__ModeOfOperation, sizeof(enum tt__ModeOfOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ModeOfOperation * SOAP_FMAC4 soap_new_tt__ModeOfOperation(struct soap *soap, int n)
{
	enum tt__ModeOfOperation *p;
	enum tt__ModeOfOperation *a = (enum tt__ModeOfOperation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ModeOfOperation));
	for (p = a; p && n--; p++)
		soap_default_tt__ModeOfOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ModeOfOperation(struct soap *soap, const enum tt__ModeOfOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__ModeOfOperation(soap, tag ? tag : "tt:ModeOfOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ModeOfOperation * SOAP_FMAC4 soap_get_tt__ModeOfOperation(struct soap *soap, enum tt__ModeOfOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ModeOfOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__TrackType[] =
{	{ (LONG64)tt__TrackType__Video, "Video" },
	{ (LONG64)tt__TrackType__Audio, "Audio" },
	{ (LONG64)tt__TrackType__Metadata, "Metadata" },
	{ (LONG64)tt__TrackType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TrackType2s(struct soap *soap, enum tt__TrackType n)
{
	const char *s = soap_code_str(soap_codes_tt__TrackType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackType(struct soap *soap, const char *tag, int id, const enum tt__TrackType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackType), type) || soap_send(soap, soap_tt__TrackType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TrackType(struct soap *soap, const char *s, enum tt__TrackType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__TrackType, s);
	if (map)
		*a = (enum tt__TrackType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__TrackType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TrackType * SOAP_FMAC4 soap_in_tt__TrackType(struct soap *soap, const char *tag, enum tt__TrackType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__TrackType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackType, sizeof(enum tt__TrackType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__TrackType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__TrackType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackType, SOAP_TYPE_tt__TrackType, sizeof(enum tt__TrackType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__TrackType * SOAP_FMAC4 soap_new_tt__TrackType(struct soap *soap, int n)
{
	enum tt__TrackType *p;
	enum tt__TrackType *a = (enum tt__TrackType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__TrackType));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackType(struct soap *soap, const enum tt__TrackType *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackType(soap, tag ? tag : "tt:TrackType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TrackType * SOAP_FMAC4 soap_get_tt__TrackType(struct soap *soap, enum tt__TrackType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RecordingStatus[] =
{	{ (LONG64)tt__RecordingStatus__Initiated, "Initiated" },
	{ (LONG64)tt__RecordingStatus__Recording, "Recording" },
	{ (LONG64)tt__RecordingStatus__Stopped, "Stopped" },
	{ (LONG64)tt__RecordingStatus__Removing, "Removing" },
	{ (LONG64)tt__RecordingStatus__Removed, "Removed" },
	{ (LONG64)tt__RecordingStatus__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RecordingStatus2s(struct soap *soap, enum tt__RecordingStatus n)
{
	const char *s = soap_code_str(soap_codes_tt__RecordingStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingStatus(struct soap *soap, const char *tag, int id, const enum tt__RecordingStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingStatus), type) || soap_send(soap, soap_tt__RecordingStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RecordingStatus(struct soap *soap, const char *s, enum tt__RecordingStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RecordingStatus, s);
	if (map)
		*a = (enum tt__RecordingStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RecordingStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RecordingStatus * SOAP_FMAC4 soap_in_tt__RecordingStatus(struct soap *soap, const char *tag, enum tt__RecordingStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RecordingStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingStatus, sizeof(enum tt__RecordingStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RecordingStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RecordingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingStatus, SOAP_TYPE_tt__RecordingStatus, sizeof(enum tt__RecordingStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RecordingStatus * SOAP_FMAC4 soap_new_tt__RecordingStatus(struct soap *soap, int n)
{
	enum tt__RecordingStatus *p;
	enum tt__RecordingStatus *a = (enum tt__RecordingStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RecordingStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingStatus(struct soap *soap, const enum tt__RecordingStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingStatus(soap, tag ? tag : "tt:RecordingStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RecordingStatus * SOAP_FMAC4 soap_get_tt__RecordingStatus(struct soap *soap, enum tt__RecordingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SearchState[] =
{	{ (LONG64)tt__SearchState__Queued, "Queued" },
	{ (LONG64)tt__SearchState__Searching, "Searching" },
	{ (LONG64)tt__SearchState__Completed, "Completed" },
	{ (LONG64)tt__SearchState__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SearchState2s(struct soap *soap, enum tt__SearchState n)
{
	const char *s = soap_code_str(soap_codes_tt__SearchState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchState(struct soap *soap, const char *tag, int id, const enum tt__SearchState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchState), type) || soap_send(soap, soap_tt__SearchState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SearchState(struct soap *soap, const char *s, enum tt__SearchState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SearchState, s);
	if (map)
		*a = (enum tt__SearchState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SearchState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SearchState * SOAP_FMAC4 soap_in_tt__SearchState(struct soap *soap, const char *tag, enum tt__SearchState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SearchState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchState, sizeof(enum tt__SearchState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SearchState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchState, SOAP_TYPE_tt__SearchState, sizeof(enum tt__SearchState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SearchState * SOAP_FMAC4 soap_new_tt__SearchState(struct soap *soap, int n)
{
	enum tt__SearchState *p;
	enum tt__SearchState *a = (enum tt__SearchState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SearchState));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchState(struct soap *soap, const enum tt__SearchState *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchState(soap, tag ? tag : "tt:SearchState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SearchState * SOAP_FMAC4 soap_get_tt__SearchState(struct soap *soap, enum tt__SearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ReceiverState[] =
{	{ (LONG64)tt__ReceiverState__NotConnected, "NotConnected" },
	{ (LONG64)tt__ReceiverState__Connecting, "Connecting" },
	{ (LONG64)tt__ReceiverState__Connected, "Connected" },
	{ (LONG64)tt__ReceiverState__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReceiverState2s(struct soap *soap, enum tt__ReceiverState n)
{
	const char *s = soap_code_str(soap_codes_tt__ReceiverState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverState(struct soap *soap, const char *tag, int id, const enum tt__ReceiverState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverState), type) || soap_send(soap, soap_tt__ReceiverState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReceiverState(struct soap *soap, const char *s, enum tt__ReceiverState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReceiverState, s);
	if (map)
		*a = (enum tt__ReceiverState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReceiverState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReceiverState * SOAP_FMAC4 soap_in_tt__ReceiverState(struct soap *soap, const char *tag, enum tt__ReceiverState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReceiverState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverState, sizeof(enum tt__ReceiverState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ReceiverState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverState, SOAP_TYPE_tt__ReceiverState, sizeof(enum tt__ReceiverState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReceiverState * SOAP_FMAC4 soap_new_tt__ReceiverState(struct soap *soap, int n)
{
	enum tt__ReceiverState *p;
	enum tt__ReceiverState *a = (enum tt__ReceiverState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReceiverState));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverState(struct soap *soap, const enum tt__ReceiverState *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverState(soap, tag ? tag : "tt:ReceiverState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReceiverState * SOAP_FMAC4 soap_get_tt__ReceiverState(struct soap *soap, enum tt__ReceiverState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ReceiverMode[] =
{	{ (LONG64)tt__ReceiverMode__AutoConnect, "AutoConnect" },
	{ (LONG64)tt__ReceiverMode__AlwaysConnect, "AlwaysConnect" },
	{ (LONG64)tt__ReceiverMode__NeverConnect, "NeverConnect" },
	{ (LONG64)tt__ReceiverMode__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReceiverMode2s(struct soap *soap, enum tt__ReceiverMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ReceiverMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverMode(struct soap *soap, const char *tag, int id, const enum tt__ReceiverMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverMode), type) || soap_send(soap, soap_tt__ReceiverMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReceiverMode(struct soap *soap, const char *s, enum tt__ReceiverMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReceiverMode, s);
	if (map)
		*a = (enum tt__ReceiverMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReceiverMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReceiverMode * SOAP_FMAC4 soap_in_tt__ReceiverMode(struct soap *soap, const char *tag, enum tt__ReceiverMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReceiverMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverMode, sizeof(enum tt__ReceiverMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ReceiverMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverMode, SOAP_TYPE_tt__ReceiverMode, sizeof(enum tt__ReceiverMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReceiverMode * SOAP_FMAC4 soap_new_tt__ReceiverMode(struct soap *soap, int n)
{
	enum tt__ReceiverMode *p;
	enum tt__ReceiverMode *a = (enum tt__ReceiverMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReceiverMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverMode(struct soap *soap, const enum tt__ReceiverMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverMode(soap, tag ? tag : "tt:ReceiverMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReceiverMode * SOAP_FMAC4 soap_get_tt__ReceiverMode(struct soap *soap, enum tt__ReceiverMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Direction[] =
{	{ (LONG64)tt__Direction__Left, "Left" },
	{ (LONG64)tt__Direction__Right, "Right" },
	{ (LONG64)tt__Direction__Any, "Any" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Direction2s(struct soap *soap, enum tt__Direction n)
{
	const char *s = soap_code_str(soap_codes_tt__Direction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Direction(struct soap *soap, const char *tag, int id, const enum tt__Direction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Direction), type) || soap_send(soap, soap_tt__Direction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Direction(struct soap *soap, const char *s, enum tt__Direction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Direction, s);
	if (map)
		*a = (enum tt__Direction)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Direction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Direction * SOAP_FMAC4 soap_in_tt__Direction(struct soap *soap, const char *tag, enum tt__Direction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Direction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Direction, sizeof(enum tt__Direction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Direction(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Direction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Direction, SOAP_TYPE_tt__Direction, sizeof(enum tt__Direction), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Direction * SOAP_FMAC4 soap_new_tt__Direction(struct soap *soap, int n)
{
	enum tt__Direction *p;
	enum tt__Direction *a = (enum tt__Direction*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Direction));
	for (p = a; p && n--; p++)
		soap_default_tt__Direction(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Direction(struct soap *soap, const enum tt__Direction *a, const char *tag, const char *type)
{
	if (soap_out_tt__Direction(soap, tag ? tag : "tt:Direction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Direction * SOAP_FMAC4 soap_get_tt__Direction(struct soap *soap, enum tt__Direction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Direction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PropertyOperation[] =
{	{ (LONG64)tt__PropertyOperation__Initialized, "Initialized" },
	{ (LONG64)tt__PropertyOperation__Deleted, "Deleted" },
	{ (LONG64)tt__PropertyOperation__Changed, "Changed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PropertyOperation2s(struct soap *soap, enum tt__PropertyOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__PropertyOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation(struct soap *soap, const char *tag, int id, const enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PropertyOperation), type) || soap_send(soap, soap_tt__PropertyOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PropertyOperation(struct soap *soap, const char *s, enum tt__PropertyOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PropertyOperation, s);
	if (map)
		*a = (enum tt__PropertyOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PropertyOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_in_tt__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PropertyOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PropertyOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PropertyOperation, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_new_tt__PropertyOperation(struct soap *soap, int n)
{
	enum tt__PropertyOperation *p;
	enum tt__PropertyOperation *a = (enum tt__PropertyOperation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PropertyOperation));
	for (p = a; p && n--; p++)
		soap_default_tt__PropertyOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PropertyOperation(struct soap *soap, const enum tt__PropertyOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_get_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ImageSendingType[] =
{	{ (LONG64)tt__ImageSendingType__Embedded, "Embedded" },
	{ (LONG64)tt__ImageSendingType__LocalStorage, "LocalStorage" },
	{ (LONG64)tt__ImageSendingType__RemoteStorage, "RemoteStorage" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ImageSendingType2s(struct soap *soap, enum tt__ImageSendingType n)
{
	const char *s = soap_code_str(soap_codes_tt__ImageSendingType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageSendingType(struct soap *soap, const char *tag, int id, const enum tt__ImageSendingType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageSendingType), type) || soap_send(soap, soap_tt__ImageSendingType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ImageSendingType(struct soap *soap, const char *s, enum tt__ImageSendingType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ImageSendingType, s);
	if (map)
		*a = (enum tt__ImageSendingType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ImageSendingType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ImageSendingType * SOAP_FMAC4 soap_in_tt__ImageSendingType(struct soap *soap, const char *tag, enum tt__ImageSendingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ImageSendingType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageSendingType, sizeof(enum tt__ImageSendingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ImageSendingType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ImageSendingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageSendingType, SOAP_TYPE_tt__ImageSendingType, sizeof(enum tt__ImageSendingType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ImageSendingType * SOAP_FMAC4 soap_new_tt__ImageSendingType(struct soap *soap, int n)
{
	enum tt__ImageSendingType *p;
	enum tt__ImageSendingType *a = (enum tt__ImageSendingType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ImageSendingType));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageSendingType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageSendingType(struct soap *soap, const enum tt__ImageSendingType *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageSendingType(soap, tag ? tag : "tt:ImageSendingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageSendingType * SOAP_FMAC4 soap_get_tt__ImageSendingType(struct soap *soap, enum tt__ImageSendingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageSendingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DefoggingMode[] =
{	{ (LONG64)tt__DefoggingMode__OFF, "OFF" },
	{ (LONG64)tt__DefoggingMode__ON, "ON" },
	{ (LONG64)tt__DefoggingMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DefoggingMode2s(struct soap *soap, enum tt__DefoggingMode n)
{
	const char *s = soap_code_str(soap_codes_tt__DefoggingMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingMode(struct soap *soap, const char *tag, int id, const enum tt__DefoggingMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingMode), type) || soap_send(soap, soap_tt__DefoggingMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DefoggingMode(struct soap *soap, const char *s, enum tt__DefoggingMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DefoggingMode, s);
	if (map)
		*a = (enum tt__DefoggingMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DefoggingMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DefoggingMode * SOAP_FMAC4 soap_in_tt__DefoggingMode(struct soap *soap, const char *tag, enum tt__DefoggingMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DefoggingMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingMode, sizeof(enum tt__DefoggingMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DefoggingMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DefoggingMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingMode, SOAP_TYPE_tt__DefoggingMode, sizeof(enum tt__DefoggingMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DefoggingMode * SOAP_FMAC4 soap_new_tt__DefoggingMode(struct soap *soap, int n)
{
	enum tt__DefoggingMode *p;
	enum tt__DefoggingMode *a = (enum tt__DefoggingMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DefoggingMode));
	for (p = a; p && n--; p++)
		soap_default_tt__DefoggingMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DefoggingMode(struct soap *soap, const enum tt__DefoggingMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__DefoggingMode(soap, tag ? tag : "tt:DefoggingMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DefoggingMode * SOAP_FMAC4 soap_get_tt__DefoggingMode(struct soap *soap, enum tt__DefoggingMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ToneCompensationMode[] =
{	{ (LONG64)tt__ToneCompensationMode__OFF, "OFF" },
	{ (LONG64)tt__ToneCompensationMode__ON, "ON" },
	{ (LONG64)tt__ToneCompensationMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ToneCompensationMode2s(struct soap *soap, enum tt__ToneCompensationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ToneCompensationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationMode(struct soap *soap, const char *tag, int id, const enum tt__ToneCompensationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationMode), type) || soap_send(soap, soap_tt__ToneCompensationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ToneCompensationMode(struct soap *soap, const char *s, enum tt__ToneCompensationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ToneCompensationMode, s);
	if (map)
		*a = (enum tt__ToneCompensationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ToneCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ToneCompensationMode * SOAP_FMAC4 soap_in_tt__ToneCompensationMode(struct soap *soap, const char *tag, enum tt__ToneCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ToneCompensationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationMode, sizeof(enum tt__ToneCompensationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ToneCompensationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ToneCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationMode, SOAP_TYPE_tt__ToneCompensationMode, sizeof(enum tt__ToneCompensationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ToneCompensationMode * SOAP_FMAC4 soap_new_tt__ToneCompensationMode(struct soap *soap, int n)
{
	enum tt__ToneCompensationMode *p;
	enum tt__ToneCompensationMode *a = (enum tt__ToneCompensationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ToneCompensationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensationMode(struct soap *soap, const enum tt__ToneCompensationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensationMode(soap, tag ? tag : "tt:ToneCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ToneCompensationMode * SOAP_FMAC4 soap_get_tt__ToneCompensationMode(struct soap *soap, enum tt__ToneCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IrCutFilterAutoBoundaryType[] =
{	{ (LONG64)tt__IrCutFilterAutoBoundaryType__Common, "Common" },
	{ (LONG64)tt__IrCutFilterAutoBoundaryType__ToOn, "ToOn" },
	{ (LONG64)tt__IrCutFilterAutoBoundaryType__ToOff, "ToOff" },
	{ (LONG64)tt__IrCutFilterAutoBoundaryType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterAutoBoundaryType2s(struct soap *soap, enum tt__IrCutFilterAutoBoundaryType n)
{
	const char *s = soap_code_str(soap_codes_tt__IrCutFilterAutoBoundaryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoBoundaryType(struct soap *soap, const char *tag, int id, const enum tt__IrCutFilterAutoBoundaryType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType), type) || soap_send(soap, soap_tt__IrCutFilterAutoBoundaryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterAutoBoundaryType(struct soap *soap, const char *s, enum tt__IrCutFilterAutoBoundaryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IrCutFilterAutoBoundaryType, s);
	if (map)
		*a = (enum tt__IrCutFilterAutoBoundaryType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IrCutFilterAutoBoundaryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IrCutFilterAutoBoundaryType * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoBoundaryType(struct soap *soap, const char *tag, enum tt__IrCutFilterAutoBoundaryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IrCutFilterAutoBoundaryType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, sizeof(enum tt__IrCutFilterAutoBoundaryType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IrCutFilterAutoBoundaryType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterAutoBoundaryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, SOAP_TYPE_tt__IrCutFilterAutoBoundaryType, sizeof(enum tt__IrCutFilterAutoBoundaryType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IrCutFilterAutoBoundaryType * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoBoundaryType(struct soap *soap, int n)
{
	enum tt__IrCutFilterAutoBoundaryType *p;
	enum tt__IrCutFilterAutoBoundaryType *a = (enum tt__IrCutFilterAutoBoundaryType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IrCutFilterAutoBoundaryType));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoBoundaryType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoBoundaryType(struct soap *soap, const enum tt__IrCutFilterAutoBoundaryType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoBoundaryType(soap, tag ? tag : "tt:IrCutFilterAutoBoundaryType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterAutoBoundaryType * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoBoundaryType(struct soap *soap, enum tt__IrCutFilterAutoBoundaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoBoundaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ImageStabilizationMode[] =
{	{ (LONG64)tt__ImageStabilizationMode__OFF, "OFF" },
	{ (LONG64)tt__ImageStabilizationMode__ON, "ON" },
	{ (LONG64)tt__ImageStabilizationMode__AUTO, "AUTO" },
	{ (LONG64)tt__ImageStabilizationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ImageStabilizationMode2s(struct soap *soap, enum tt__ImageStabilizationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ImageStabilizationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const enum tt__ImageStabilizationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationMode), type) || soap_send(soap, soap_tt__ImageStabilizationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ImageStabilizationMode(struct soap *soap, const char *s, enum tt__ImageStabilizationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ImageStabilizationMode, s);
	if (map)
		*a = (enum tt__ImageStabilizationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ImageStabilizationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_in_tt__ImageStabilizationMode(struct soap *soap, const char *tag, enum tt__ImageStabilizationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ImageStabilizationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ImageStabilizationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ImageStabilizationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_new_tt__ImageStabilizationMode(struct soap *soap, int n)
{
	enum tt__ImageStabilizationMode *p;
	enum tt__ImageStabilizationMode *a = (enum tt__ImageStabilizationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ImageStabilizationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationMode(struct soap *soap, const enum tt__ImageStabilizationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationMode(soap, tag ? tag : "tt:ImageStabilizationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode * SOAP_FMAC4 soap_get_tt__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IrCutFilterMode[] =
{	{ (LONG64)tt__IrCutFilterMode__ON, "ON" },
	{ (LONG64)tt__IrCutFilterMode__OFF, "OFF" },
	{ (LONG64)tt__IrCutFilterMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterMode2s(struct soap *soap, enum tt__IrCutFilterMode n)
{
	const char *s = soap_code_str(soap_codes_tt__IrCutFilterMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterMode), type) || soap_send(soap, soap_tt__IrCutFilterMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterMode(struct soap *soap, const char *s, enum tt__IrCutFilterMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IrCutFilterMode, s);
	if (map)
		*a = (enum tt__IrCutFilterMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IrCutFilterMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_in_tt__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IrCutFilterMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IrCutFilterMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_new_tt__IrCutFilterMode(struct soap *soap, int n)
{
	enum tt__IrCutFilterMode *p;
	enum tt__IrCutFilterMode *a = (enum tt__IrCutFilterMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IrCutFilterMode));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterMode(struct soap *soap, const enum tt__IrCutFilterMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterMode(soap, tag ? tag : "tt:IrCutFilterMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_get_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__WhiteBalanceMode[] =
{	{ (LONG64)tt__WhiteBalanceMode__AUTO, "AUTO" },
	{ (LONG64)tt__WhiteBalanceMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WhiteBalanceMode2s(struct soap *soap, enum tt__WhiteBalanceMode n)
{
	const char *s = soap_code_str(soap_codes_tt__WhiteBalanceMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceMode), type) || soap_send(soap, soap_tt__WhiteBalanceMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WhiteBalanceMode(struct soap *soap, const char *s, enum tt__WhiteBalanceMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WhiteBalanceMode, s);
	if (map)
		*a = (enum tt__WhiteBalanceMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WhiteBalanceMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WhiteBalanceMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__WhiteBalanceMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_new_tt__WhiteBalanceMode(struct soap *soap, int n)
{
	enum tt__WhiteBalanceMode *p;
	enum tt__WhiteBalanceMode *a = (enum tt__WhiteBalanceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__WhiteBalanceMode));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceMode(struct soap *soap, const enum tt__WhiteBalanceMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceMode(soap, tag ? tag : "tt:WhiteBalanceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Enabled[] =
{	{ (LONG64)tt__Enabled__ENABLED, "ENABLED" },
	{ (LONG64)tt__Enabled__DISABLED, "DISABLED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Enabled2s(struct soap *soap, enum tt__Enabled n)
{
	const char *s = soap_code_str(soap_codes_tt__Enabled, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Enabled(struct soap *soap, const char *tag, int id, const enum tt__Enabled *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Enabled), type) || soap_send(soap, soap_tt__Enabled2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Enabled(struct soap *soap, const char *s, enum tt__Enabled *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Enabled, s);
	if (map)
		*a = (enum tt__Enabled)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Enabled)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Enabled * SOAP_FMAC4 soap_in_tt__Enabled(struct soap *soap, const char *tag, enum tt__Enabled *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Enabled*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Enabled, sizeof(enum tt__Enabled), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Enabled(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Enabled *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Enabled, SOAP_TYPE_tt__Enabled, sizeof(enum tt__Enabled), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Enabled * SOAP_FMAC4 soap_new_tt__Enabled(struct soap *soap, int n)
{
	enum tt__Enabled *p;
	enum tt__Enabled *a = (enum tt__Enabled*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Enabled));
	for (p = a; p && n--; p++)
		soap_default_tt__Enabled(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Enabled(struct soap *soap, const enum tt__Enabled *a, const char *tag, const char *type)
{
	if (soap_out_tt__Enabled(soap, tag ? tag : "tt:Enabled", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Enabled * SOAP_FMAC4 soap_get_tt__Enabled(struct soap *soap, enum tt__Enabled *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Enabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ExposureMode[] =
{	{ (LONG64)tt__ExposureMode__AUTO, "AUTO" },
	{ (LONG64)tt__ExposureMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposureMode2s(struct soap *soap, enum tt__ExposureMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ExposureMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode(struct soap *soap, const char *tag, int id, const enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureMode), type) || soap_send(soap, soap_tt__ExposureMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposureMode(struct soap *soap, const char *s, enum tt__ExposureMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposureMode, s);
	if (map)
		*a = (enum tt__ExposureMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposureMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_in_tt__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposureMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ExposureMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_new_tt__ExposureMode(struct soap *soap, int n)
{
	enum tt__ExposureMode *p;
	enum tt__ExposureMode *a = (enum tt__ExposureMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ExposureMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ExposureMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureMode(struct soap *soap, const enum tt__ExposureMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposureMode(soap, tag ? tag : "tt:ExposureMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_get_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ExposurePriority[] =
{	{ (LONG64)tt__ExposurePriority__LowNoise, "LowNoise" },
	{ (LONG64)tt__ExposurePriority__FrameRate, "FrameRate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposurePriority2s(struct soap *soap, enum tt__ExposurePriority n)
{
	const char *s = soap_code_str(soap_codes_tt__ExposurePriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority(struct soap *soap, const char *tag, int id, const enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposurePriority), type) || soap_send(soap, soap_tt__ExposurePriority2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposurePriority(struct soap *soap, const char *s, enum tt__ExposurePriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposurePriority, s);
	if (map)
		*a = (enum tt__ExposurePriority)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposurePriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_in_tt__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposurePriority*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ExposurePriority(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_new_tt__ExposurePriority(struct soap *soap, int n)
{
	enum tt__ExposurePriority *p;
	enum tt__ExposurePriority *a = (enum tt__ExposurePriority*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ExposurePriority));
	for (p = a; p && n--; p++)
		soap_default_tt__ExposurePriority(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposurePriority(struct soap *soap, const enum tt__ExposurePriority *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposurePriority(soap, tag ? tag : "tt:ExposurePriority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_get_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__BacklightCompensationMode[] =
{	{ (LONG64)tt__BacklightCompensationMode__OFF, "OFF" },
	{ (LONG64)tt__BacklightCompensationMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__BacklightCompensationMode2s(struct soap *soap, enum tt__BacklightCompensationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__BacklightCompensationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationMode), type) || soap_send(soap, soap_tt__BacklightCompensationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__BacklightCompensationMode(struct soap *soap, const char *s, enum tt__BacklightCompensationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__BacklightCompensationMode, s);
	if (map)
		*a = (enum tt__BacklightCompensationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__BacklightCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__BacklightCompensationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__BacklightCompensationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_new_tt__BacklightCompensationMode(struct soap *soap, int n)
{
	enum tt__BacklightCompensationMode *p;
	enum tt__BacklightCompensationMode *a = (enum tt__BacklightCompensationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__BacklightCompensationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationMode(struct soap *soap, const enum tt__BacklightCompensationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensationMode(soap, tag ? tag : "tt:BacklightCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__WideDynamicMode[] =
{	{ (LONG64)tt__WideDynamicMode__OFF, "OFF" },
	{ (LONG64)tt__WideDynamicMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WideDynamicMode2s(struct soap *soap, enum tt__WideDynamicMode n)
{
	const char *s = soap_code_str(soap_codes_tt__WideDynamicMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode(struct soap *soap, const char *tag, int id, const enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicMode), type) || soap_send(soap, soap_tt__WideDynamicMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WideDynamicMode(struct soap *soap, const char *s, enum tt__WideDynamicMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WideDynamicMode, s);
	if (map)
		*a = (enum tt__WideDynamicMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WideDynamicMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_in_tt__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WideDynamicMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__WideDynamicMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_new_tt__WideDynamicMode(struct soap *soap, int n)
{
	enum tt__WideDynamicMode *p;
	enum tt__WideDynamicMode *a = (enum tt__WideDynamicMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__WideDynamicMode));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicMode(struct soap *soap, const enum tt__WideDynamicMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicMode(soap, tag ? tag : "tt:WideDynamicMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_get_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AFModes[] =
{	{ (LONG64)tt__AFModes__OnceAfterMove, "OnceAfterMove" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AFModes2s(struct soap *soap, enum tt__AFModes n)
{
	const char *s = soap_code_str(soap_codes_tt__AFModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AFModes(struct soap *soap, const char *tag, int id, const enum tt__AFModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AFModes), type) || soap_send(soap, soap_tt__AFModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AFModes(struct soap *soap, const char *s, enum tt__AFModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AFModes, s);
	if (map)
		*a = (enum tt__AFModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AFModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AFModes * SOAP_FMAC4 soap_in_tt__AFModes(struct soap *soap, const char *tag, enum tt__AFModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AFModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AFModes, sizeof(enum tt__AFModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AFModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AFModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AFModes, SOAP_TYPE_tt__AFModes, sizeof(enum tt__AFModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AFModes * SOAP_FMAC4 soap_new_tt__AFModes(struct soap *soap, int n)
{
	enum tt__AFModes *p;
	enum tt__AFModes *a = (enum tt__AFModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AFModes));
	for (p = a; p && n--; p++)
		soap_default_tt__AFModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AFModes(struct soap *soap, const enum tt__AFModes *a, const char *tag, const char *type)
{
	if (soap_out_tt__AFModes(soap, tag ? tag : "tt:AFModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AFModes * SOAP_FMAC4 soap_get_tt__AFModes(struct soap *soap, enum tt__AFModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AFModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AutoFocusMode[] =
{	{ (LONG64)tt__AutoFocusMode__AUTO, "AUTO" },
	{ (LONG64)tt__AutoFocusMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AutoFocusMode2s(struct soap *soap, enum tt__AutoFocusMode n)
{
	const char *s = soap_code_str(soap_codes_tt__AutoFocusMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode(struct soap *soap, const char *tag, int id, const enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AutoFocusMode), type) || soap_send(soap, soap_tt__AutoFocusMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AutoFocusMode(struct soap *soap, const char *s, enum tt__AutoFocusMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AutoFocusMode, s);
	if (map)
		*a = (enum tt__AutoFocusMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AutoFocusMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_in_tt__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AutoFocusMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AutoFocusMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_new_tt__AutoFocusMode(struct soap *soap, int n)
{
	enum tt__AutoFocusMode *p;
	enum tt__AutoFocusMode *a = (enum tt__AutoFocusMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AutoFocusMode));
	for (p = a; p && n--; p++)
		soap_default_tt__AutoFocusMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AutoFocusMode(struct soap *soap, const enum tt__AutoFocusMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__AutoFocusMode(soap, tag ? tag : "tt:AutoFocusMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_get_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MoveAndTrackMethod[] =
{	{ (LONG64)tt__MoveAndTrackMethod__PresetToken, "PresetToken" },
	{ (LONG64)tt__MoveAndTrackMethod__GeoLocation, "GeoLocation" },
	{ (LONG64)tt__MoveAndTrackMethod__PTZVector, "PTZVector" },
	{ (LONG64)tt__MoveAndTrackMethod__ObjectID, "ObjectID" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveAndTrackMethod2s(struct soap *soap, enum tt__MoveAndTrackMethod n)
{
	const char *s = soap_code_str(soap_codes_tt__MoveAndTrackMethod, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveAndTrackMethod(struct soap *soap, const char *tag, int id, const enum tt__MoveAndTrackMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveAndTrackMethod), type) || soap_send(soap, soap_tt__MoveAndTrackMethod2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveAndTrackMethod(struct soap *soap, const char *s, enum tt__MoveAndTrackMethod *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveAndTrackMethod, s);
	if (map)
		*a = (enum tt__MoveAndTrackMethod)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveAndTrackMethod)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveAndTrackMethod * SOAP_FMAC4 soap_in_tt__MoveAndTrackMethod(struct soap *soap, const char *tag, enum tt__MoveAndTrackMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveAndTrackMethod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveAndTrackMethod, sizeof(enum tt__MoveAndTrackMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MoveAndTrackMethod(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MoveAndTrackMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveAndTrackMethod, SOAP_TYPE_tt__MoveAndTrackMethod, sizeof(enum tt__MoveAndTrackMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MoveAndTrackMethod * SOAP_FMAC4 soap_new_tt__MoveAndTrackMethod(struct soap *soap, int n)
{
	enum tt__MoveAndTrackMethod *p;
	enum tt__MoveAndTrackMethod *a = (enum tt__MoveAndTrackMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MoveAndTrackMethod));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveAndTrackMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveAndTrackMethod(struct soap *soap, const enum tt__MoveAndTrackMethod *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveAndTrackMethod(soap, tag ? tag : "tt:MoveAndTrackMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveAndTrackMethod * SOAP_FMAC4 soap_get_tt__MoveAndTrackMethod(struct soap *soap, enum tt__MoveAndTrackMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveAndTrackMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourOperation[] =
{	{ (LONG64)tt__PTZPresetTourOperation__Start, "Start" },
	{ (LONG64)tt__PTZPresetTourOperation__Stop, "Stop" },
	{ (LONG64)tt__PTZPresetTourOperation__Pause, "Pause" },
	{ (LONG64)tt__PTZPresetTourOperation__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourOperation2s(struct soap *soap, enum tt__PTZPresetTourOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourOperation), type) || soap_send(soap, soap_tt__PTZPresetTourOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourOperation(struct soap *soap, const char *s, enum tt__PTZPresetTourOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourOperation, s);
	if (map)
		*a = (enum tt__PTZPresetTourOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_in_tt__PTZPresetTourOperation(struct soap *soap, const char *tag, enum tt__PTZPresetTourOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_new_tt__PTZPresetTourOperation(struct soap *soap, int n)
{
	enum tt__PTZPresetTourOperation *p;
	enum tt__PTZPresetTourOperation *a = (enum tt__PTZPresetTourOperation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourOperation));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourOperation(struct soap *soap, const enum tt__PTZPresetTourOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourOperation(soap, tag ? tag : "tt:PTZPresetTourOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_get_tt__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourDirection[] =
{	{ (LONG64)tt__PTZPresetTourDirection__Forward, "Forward" },
	{ (LONG64)tt__PTZPresetTourDirection__Backward, "Backward" },
	{ (LONG64)tt__PTZPresetTourDirection__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourDirection2s(struct soap *soap, enum tt__PTZPresetTourDirection n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourDirection, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourDirection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourDirection), type) || soap_send(soap, soap_tt__PTZPresetTourDirection2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourDirection(struct soap *soap, const char *s, enum tt__PTZPresetTourDirection *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourDirection, s);
	if (map)
		*a = (enum tt__PTZPresetTourDirection)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourDirection)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_in_tt__PTZPresetTourDirection(struct soap *soap, const char *tag, enum tt__PTZPresetTourDirection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourDirection(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_new_tt__PTZPresetTourDirection(struct soap *soap, int n)
{
	enum tt__PTZPresetTourDirection *p;
	enum tt__PTZPresetTourDirection *a = (enum tt__PTZPresetTourDirection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourDirection));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourDirection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourDirection(struct soap *soap, const enum tt__PTZPresetTourDirection *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourDirection(soap, tag ? tag : "tt:PTZPresetTourDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_get_tt__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourState[] =
{	{ (LONG64)tt__PTZPresetTourState__Idle, "Idle" },
	{ (LONG64)tt__PTZPresetTourState__Touring, "Touring" },
	{ (LONG64)tt__PTZPresetTourState__Paused, "Paused" },
	{ (LONG64)tt__PTZPresetTourState__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourState2s(struct soap *soap, enum tt__PTZPresetTourState n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourState(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourState), type) || soap_send(soap, soap_tt__PTZPresetTourState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourState(struct soap *soap, const char *s, enum tt__PTZPresetTourState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourState, s);
	if (map)
		*a = (enum tt__PTZPresetTourState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_in_tt__PTZPresetTourState(struct soap *soap, const char *tag, enum tt__PTZPresetTourState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourState, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_new_tt__PTZPresetTourState(struct soap *soap, int n)
{
	enum tt__PTZPresetTourState *p;
	enum tt__PTZPresetTourState *a = (enum tt__PTZPresetTourState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourState));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourState(struct soap *soap, const enum tt__PTZPresetTourState *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourState(soap, tag ? tag : "tt:PTZPresetTourState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_get_tt__PTZPresetTourState(struct soap *soap, enum tt__PTZPresetTourState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ReverseMode[] =
{	{ (LONG64)tt__ReverseMode__OFF, "OFF" },
	{ (LONG64)tt__ReverseMode__ON, "ON" },
	{ (LONG64)tt__ReverseMode__AUTO, "AUTO" },
	{ (LONG64)tt__ReverseMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReverseMode2s(struct soap *soap, enum tt__ReverseMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ReverseMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode(struct soap *soap, const char *tag, int id, const enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseMode), type) || soap_send(soap, soap_tt__ReverseMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReverseMode(struct soap *soap, const char *s, enum tt__ReverseMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReverseMode, s);
	if (map)
		*a = (enum tt__ReverseMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReverseMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_in_tt__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReverseMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ReverseMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_new_tt__ReverseMode(struct soap *soap, int n)
{
	enum tt__ReverseMode *p;
	enum tt__ReverseMode *a = (enum tt__ReverseMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReverseMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseMode(struct soap *soap, const enum tt__ReverseMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseMode(soap, tag ? tag : "tt:ReverseMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_get_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__EFlipMode[] =
{	{ (LONG64)tt__EFlipMode__OFF, "OFF" },
	{ (LONG64)tt__EFlipMode__ON, "ON" },
	{ (LONG64)tt__EFlipMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__EFlipMode2s(struct soap *soap, enum tt__EFlipMode n)
{
	const char *s = soap_code_str(soap_codes_tt__EFlipMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode(struct soap *soap, const char *tag, int id, const enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipMode), type) || soap_send(soap, soap_tt__EFlipMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__EFlipMode(struct soap *soap, const char *s, enum tt__EFlipMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__EFlipMode, s);
	if (map)
		*a = (enum tt__EFlipMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__EFlipMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_in_tt__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__EFlipMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__EFlipMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_new_tt__EFlipMode(struct soap *soap, int n)
{
	enum tt__EFlipMode *p;
	enum tt__EFlipMode *a = (enum tt__EFlipMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__EFlipMode));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipMode(struct soap *soap, const enum tt__EFlipMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipMode(soap, tag ? tag : "tt:EFlipMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_get_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DigitalIdleState[] =
{	{ (LONG64)tt__DigitalIdleState__closed, "closed" },
	{ (LONG64)tt__DigitalIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DigitalIdleState2s(struct soap *soap, enum tt__DigitalIdleState n)
{
	const char *s = soap_code_str(soap_codes_tt__DigitalIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalIdleState(struct soap *soap, const char *tag, int id, const enum tt__DigitalIdleState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalIdleState), type) || soap_send(soap, soap_tt__DigitalIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DigitalIdleState(struct soap *soap, const char *s, enum tt__DigitalIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DigitalIdleState, s);
	if (map)
		*a = (enum tt__DigitalIdleState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DigitalIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_in_tt__DigitalIdleState(struct soap *soap, const char *tag, enum tt__DigitalIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DigitalIdleState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DigitalIdleState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DigitalIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalIdleState, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_new_tt__DigitalIdleState(struct soap *soap, int n)
{
	enum tt__DigitalIdleState *p;
	enum tt__DigitalIdleState *a = (enum tt__DigitalIdleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DigitalIdleState));
	for (p = a; p && n--; p++)
		soap_default_tt__DigitalIdleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DigitalIdleState(struct soap *soap, const enum tt__DigitalIdleState *a, const char *tag, const char *type)
{
	if (soap_out_tt__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_get_tt__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayMode[] =
{	{ (LONG64)tt__RelayMode__Monostable, "Monostable" },
	{ (LONG64)tt__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayMode2s(struct soap *soap, enum tt__RelayMode n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode(struct soap *soap, const char *tag, int id, const enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayMode), type) || soap_send(soap, soap_tt__RelayMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayMode(struct soap *soap, const char *s, enum tt__RelayMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayMode, s);
	if (map)
		*a = (enum tt__RelayMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_in_tt__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_new_tt__RelayMode(struct soap *soap, int n)
{
	enum tt__RelayMode *p;
	enum tt__RelayMode *a = (enum tt__RelayMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayMode));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayMode(struct soap *soap, const enum tt__RelayMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayMode(soap, tag ? tag : "tt:RelayMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_get_tt__RelayMode(struct soap *soap, enum tt__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayIdleState[] =
{	{ (LONG64)tt__RelayIdleState__closed, "closed" },
	{ (LONG64)tt__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayIdleState2s(struct soap *soap, enum tt__RelayIdleState n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState(struct soap *soap, const char *tag, int id, const enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayIdleState), type) || soap_send(soap, soap_tt__RelayIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayIdleState(struct soap *soap, const char *s, enum tt__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayIdleState, s);
	if (map)
		*a = (enum tt__RelayIdleState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_in_tt__RelayIdleState(struct soap *soap, const char *tag, enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayIdleState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayIdleState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_new_tt__RelayIdleState(struct soap *soap, int n)
{
	enum tt__RelayIdleState *p;
	enum tt__RelayIdleState *a = (enum tt__RelayIdleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayIdleState));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayIdleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayIdleState(struct soap *soap, const enum tt__RelayIdleState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayIdleState(soap, tag ? tag : "tt:RelayIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_get_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayLogicalState[] =
{	{ (LONG64)tt__RelayLogicalState__active, "active" },
	{ (LONG64)tt__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayLogicalState2s(struct soap *soap, enum tt__RelayLogicalState n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayLogicalState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayLogicalState), type) || soap_send(soap, soap_tt__RelayLogicalState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayLogicalState(struct soap *soap, const char *s, enum tt__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayLogicalState, s);
	if (map)
		*a = (enum tt__RelayLogicalState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_in_tt__RelayLogicalState(struct soap *soap, const char *tag, enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayLogicalState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayLogicalState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_new_tt__RelayLogicalState(struct soap *soap, int n)
{
	enum tt__RelayLogicalState *p;
	enum tt__RelayLogicalState *a = (enum tt__RelayLogicalState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayLogicalState));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayLogicalState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayLogicalState(struct soap *soap, const enum tt__RelayLogicalState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayLogicalState(soap, tag ? tag : "tt:RelayLogicalState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_get_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__UserLevel[] =
{	{ (LONG64)tt__UserLevel__Administrator, "Administrator" },
	{ (LONG64)tt__UserLevel__Operator, "Operator" },
	{ (LONG64)tt__UserLevel__User, "User" },
	{ (LONG64)tt__UserLevel__Anonymous, "Anonymous" },
	{ (LONG64)tt__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__UserLevel2s(struct soap *soap, enum tt__UserLevel n)
{
	const char *s = soap_code_str(soap_codes_tt__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel(struct soap *soap, const char *tag, int id, const enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserLevel), type) || soap_send(soap, soap_tt__UserLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__UserLevel(struct soap *soap, const char *s, enum tt__UserLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__UserLevel, s);
	if (map)
		*a = (enum tt__UserLevel)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_in_tt__UserLevel(struct soap *soap, const char *tag, enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__UserLevel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__UserLevel(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_new_tt__UserLevel(struct soap *soap, int n)
{
	enum tt__UserLevel *p;
	enum tt__UserLevel *a = (enum tt__UserLevel*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__UserLevel));
	for (p = a; p && n--; p++)
		soap_default_tt__UserLevel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserLevel(struct soap *soap, const enum tt__UserLevel *a, const char *tag, const char *type)
{
	if (soap_out_tt__UserLevel(soap, tag ? tag : "tt:UserLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_get_tt__UserLevel(struct soap *soap, enum tt__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SetDateTimeType[] =
{	{ (LONG64)tt__SetDateTimeType__Manual, "Manual" },
	{ (LONG64)tt__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SetDateTimeType2s(struct soap *soap, enum tt__SetDateTimeType n)
{
	const char *s = soap_code_str(soap_codes_tt__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SetDateTimeType), type) || soap_send(soap, soap_tt__SetDateTimeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SetDateTimeType(struct soap *soap, const char *s, enum tt__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SetDateTimeType, s);
	if (map)
		*a = (enum tt__SetDateTimeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_in_tt__SetDateTimeType(struct soap *soap, const char *tag, enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SetDateTimeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SetDateTimeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_new_tt__SetDateTimeType(struct soap *soap, int n)
{
	enum tt__SetDateTimeType *p;
	enum tt__SetDateTimeType *a = (enum tt__SetDateTimeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SetDateTimeType));
	for (p = a; p && n--; p++)
		soap_default_tt__SetDateTimeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SetDateTimeType(struct soap *soap, const enum tt__SetDateTimeType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SetDateTimeType(soap, tag ? tag : "tt:SetDateTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_get_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__FactoryDefaultType[] =
{	{ (LONG64)tt__FactoryDefaultType__Hard, "Hard" },
	{ (LONG64)tt__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__FactoryDefaultType2s(struct soap *soap, enum tt__FactoryDefaultType n)
{
	const char *s = soap_code_str(soap_codes_tt__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FactoryDefaultType), type) || soap_send(soap, soap_tt__FactoryDefaultType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__FactoryDefaultType(struct soap *soap, const char *s, enum tt__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__FactoryDefaultType, s);
	if (map)
		*a = (enum tt__FactoryDefaultType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_in_tt__FactoryDefaultType(struct soap *soap, const char *tag, enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__FactoryDefaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__FactoryDefaultType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_new_tt__FactoryDefaultType(struct soap *soap, int n)
{
	enum tt__FactoryDefaultType *p;
	enum tt__FactoryDefaultType *a = (enum tt__FactoryDefaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__FactoryDefaultType));
	for (p = a; p && n--; p++)
		soap_default_tt__FactoryDefaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FactoryDefaultType(struct soap *soap, const enum tt__FactoryDefaultType *a, const char *tag, const char *type)
{
	if (soap_out_tt__FactoryDefaultType(soap, tag ? tag : "tt:FactoryDefaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_get_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SystemLogType[] =
{	{ (LONG64)tt__SystemLogType__System, "System" },
	{ (LONG64)tt__SystemLogType__Access, "Access" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SystemLogType2s(struct soap *soap, enum tt__SystemLogType n)
{
	const char *s = soap_code_str(soap_codes_tt__SystemLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogType(struct soap *soap, const char *tag, int id, const enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogType), type) || soap_send(soap, soap_tt__SystemLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SystemLogType(struct soap *soap, const char *s, enum tt__SystemLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SystemLogType, s);
	if (map)
		*a = (enum tt__SystemLogType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SystemLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_in_tt__SystemLogType(struct soap *soap, const char *tag, enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SystemLogType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SystemLogType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogType, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_new_tt__SystemLogType(struct soap *soap, int n)
{
	enum tt__SystemLogType *p;
	enum tt__SystemLogType *a = (enum tt__SystemLogType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SystemLogType));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogType(struct soap *soap, const enum tt__SystemLogType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogType(soap, tag ? tag : "tt:SystemLogType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_get_tt__SystemLogType(struct soap *soap, enum tt__SystemLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	{ (LONG64)tt__CapabilityCategory__All, "All" },
	{ (LONG64)tt__CapabilityCategory__Analytics, "Analytics" },
	{ (LONG64)tt__CapabilityCategory__Device, "Device" },
	{ (LONG64)tt__CapabilityCategory__Events, "Events" },
	{ (LONG64)tt__CapabilityCategory__Imaging, "Imaging" },
	{ (LONG64)tt__CapabilityCategory__Media, "Media" },
	{ (LONG64)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{
	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__CapabilityCategory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__CapabilityCategory(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_new_tt__CapabilityCategory(struct soap *soap, int n)
{
	enum tt__CapabilityCategory *p;
	enum tt__CapabilityCategory *a = (enum tt__CapabilityCategory*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__CapabilityCategory));
	for (p = a; p && n--; p++)
		soap_default_tt__CapabilityCategory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11AuthAndMangementSuite[] =
{	{ (LONG64)tt__Dot11AuthAndMangementSuite__None, "None" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__PSK, "PSK" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11AuthAndMangementSuite2s(struct soap *soap, enum tt__Dot11AuthAndMangementSuite n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11AuthAndMangementSuite, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite), type) || soap_send(soap, soap_tt__Dot11AuthAndMangementSuite2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *s, enum tt__Dot11AuthAndMangementSuite *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11AuthAndMangementSuite, s);
	if (map)
		*a = (enum tt__Dot11AuthAndMangementSuite)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11AuthAndMangementSuite)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_in_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11AuthAndMangementSuite*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11AuthAndMangementSuite(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_new_tt__Dot11AuthAndMangementSuite(struct soap *soap, int n)
{
	enum tt__Dot11AuthAndMangementSuite *p;
	enum tt__Dot11AuthAndMangementSuite *a = (enum tt__Dot11AuthAndMangementSuite*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11AuthAndMangementSuite));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11AuthAndMangementSuite(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AuthAndMangementSuite(struct soap *soap, const enum tt__Dot11AuthAndMangementSuite *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag ? tag : "tt:Dot11AuthAndMangementSuite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_get_tt__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SignalStrength[] =
{	{ (LONG64)tt__Dot11SignalStrength__None, "None" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Bad, "Very Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Bad, "Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Good, "Good" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Good, "Very Good" },
	{ (LONG64)tt__Dot11SignalStrength__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SignalStrength2s(struct soap *soap, enum tt__Dot11SignalStrength n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11SignalStrength, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SignalStrength(struct soap *soap, const char *tag, int id, const enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SignalStrength), type) || soap_send(soap, soap_tt__Dot11SignalStrength2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SignalStrength(struct soap *soap, const char *s, enum tt__Dot11SignalStrength *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SignalStrength, s);
	if (map)
		*a = (enum tt__Dot11SignalStrength)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SignalStrength)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_in_tt__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SignalStrength*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11SignalStrength(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SignalStrength, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_new_tt__Dot11SignalStrength(struct soap *soap, int n)
{
	enum tt__Dot11SignalStrength *p;
	enum tt__Dot11SignalStrength *a = (enum tt__Dot11SignalStrength*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SignalStrength));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SignalStrength(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SignalStrength(struct soap *soap, const enum tt__Dot11SignalStrength *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_get_tt__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11Cipher[] =
{	{ (LONG64)tt__Dot11Cipher__CCMP, "CCMP" },
	{ (LONG64)tt__Dot11Cipher__TKIP, "TKIP" },
	{ (LONG64)tt__Dot11Cipher__Any, "Any" },
	{ (LONG64)tt__Dot11Cipher__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11Cipher2s(struct soap *soap, enum tt__Dot11Cipher n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11Cipher, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Cipher(struct soap *soap, const char *tag, int id, const enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Cipher), type) || soap_send(soap, soap_tt__Dot11Cipher2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11Cipher(struct soap *soap, const char *s, enum tt__Dot11Cipher *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11Cipher, s);
	if (map)
		*a = (enum tt__Dot11Cipher)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11Cipher)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_in_tt__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11Cipher*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11Cipher(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_new_tt__Dot11Cipher(struct soap *soap, int n)
{
	enum tt__Dot11Cipher *p;
	enum tt__Dot11Cipher *a = (enum tt__Dot11Cipher*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11Cipher));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Cipher(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Cipher(struct soap *soap, const enum tt__Dot11Cipher *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_get_tt__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SecurityMode[] =
{	{ (LONG64)tt__Dot11SecurityMode__None, "None" },
	{ (LONG64)tt__Dot11SecurityMode__WEP, "WEP" },
	{ (LONG64)tt__Dot11SecurityMode__PSK, "PSK" },
	{ (LONG64)tt__Dot11SecurityMode__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11SecurityMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SecurityMode2s(struct soap *soap, enum tt__Dot11SecurityMode n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11SecurityMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityMode), type) || soap_send(soap, soap_tt__Dot11SecurityMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SecurityMode(struct soap *soap, const char *s, enum tt__Dot11SecurityMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SecurityMode, s);
	if (map)
		*a = (enum tt__Dot11SecurityMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SecurityMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_in_tt__Dot11SecurityMode(struct soap *soap, const char *tag, enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SecurityMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11SecurityMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SecurityMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityMode, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_new_tt__Dot11SecurityMode(struct soap *soap, int n)
{
	enum tt__Dot11SecurityMode *p;
	enum tt__Dot11SecurityMode *a = (enum tt__Dot11SecurityMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SecurityMode));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SecurityMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityMode(struct soap *soap, const enum tt__Dot11SecurityMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SecurityMode(soap, tag ? tag : "tt:Dot11SecurityMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_get_tt__Dot11SecurityMode(struct soap *soap, enum tt__Dot11SecurityMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11StationMode[] =
{	{ (LONG64)tt__Dot11StationMode__Ad_hoc, "Ad-hoc" },
	{ (LONG64)tt__Dot11StationMode__Infrastructure, "Infrastructure" },
	{ (LONG64)tt__Dot11StationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11StationMode2s(struct soap *soap, enum tt__Dot11StationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11StationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11StationMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11StationMode), type) || soap_send(soap, soap_tt__Dot11StationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11StationMode(struct soap *soap, const char *s, enum tt__Dot11StationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11StationMode, s);
	if (map)
		*a = (enum tt__Dot11StationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11StationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_in_tt__Dot11StationMode(struct soap *soap, const char *tag, enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11StationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11StationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11StationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11StationMode, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_new_tt__Dot11StationMode(struct soap *soap, int n)
{
	enum tt__Dot11StationMode *p;
	enum tt__Dot11StationMode *a = (enum tt__Dot11StationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11StationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11StationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11StationMode(struct soap *soap, const enum tt__Dot11StationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11StationMode(soap, tag ? tag : "tt:Dot11StationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_get_tt__Dot11StationMode(struct soap *soap, enum tt__Dot11StationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11StationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DynamicDNSType[] =
{	{ (LONG64)tt__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (LONG64)tt__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (LONG64)tt__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DynamicDNSType2s(struct soap *soap, enum tt__DynamicDNSType n)
{
	const char *s = soap_code_str(soap_codes_tt__DynamicDNSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSType), type) || soap_send(soap, soap_tt__DynamicDNSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DynamicDNSType(struct soap *soap, const char *s, enum tt__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DynamicDNSType, s);
	if (map)
		*a = (enum tt__DynamicDNSType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_in_tt__DynamicDNSType(struct soap *soap, const char *tag, enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DynamicDNSType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DynamicDNSType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_new_tt__DynamicDNSType(struct soap *soap, int n)
{
	enum tt__DynamicDNSType *p;
	enum tt__DynamicDNSType *a = (enum tt__DynamicDNSType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DynamicDNSType));
	for (p = a; p && n--; p++)
		soap_default_tt__DynamicDNSType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSType(struct soap *soap, const enum tt__DynamicDNSType *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSType(soap, tag ? tag : "tt:DynamicDNSType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_get_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPAddressFilterType[] =
{	{ (LONG64)tt__IPAddressFilterType__Allow, "Allow" },
	{ (LONG64)tt__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPAddressFilterType2s(struct soap *soap, enum tt__IPAddressFilterType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPAddressFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterType), type) || soap_send(soap, soap_tt__IPAddressFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPAddressFilterType(struct soap *soap, const char *s, enum tt__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPAddressFilterType, s);
	if (map)
		*a = (enum tt__IPAddressFilterType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_in_tt__IPAddressFilterType(struct soap *soap, const char *tag, enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPAddressFilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPAddressFilterType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_new_tt__IPAddressFilterType(struct soap *soap, int n)
{
	enum tt__IPAddressFilterType *p;
	enum tt__IPAddressFilterType *a = (enum tt__IPAddressFilterType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPAddressFilterType));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddressFilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterType(struct soap *soap, const enum tt__IPAddressFilterType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilterType(soap, tag ? tag : "tt:IPAddressFilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_get_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (LONG64)tt__IPType__IPv4, "IPv4" },
	{ (LONG64)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n)
{
	enum tt__IPType *p;
	enum tt__IPType *a = (enum tt__IPType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPType));
	for (p = a; p && n--; p++)
		soap_default_tt__IPType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPType(soap, tag ? tag : "tt:IPType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkHostType[] =
{	{ (LONG64)tt__NetworkHostType__IPv4, "IPv4" },
	{ (LONG64)tt__NetworkHostType__IPv6, "IPv6" },
	{ (LONG64)tt__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkHostType2s(struct soap *soap, enum tt__NetworkHostType n)
{
	const char *s = soap_code_str(soap_codes_tt__NetworkHostType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType(struct soap *soap, const char *tag, int id, const enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostType), type) || soap_send(soap, soap_tt__NetworkHostType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkHostType(struct soap *soap, const char *s, enum tt__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkHostType, s);
	if (map)
		*a = (enum tt__NetworkHostType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_in_tt__NetworkHostType(struct soap *soap, const char *tag, enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkHostType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__NetworkHostType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_new_tt__NetworkHostType(struct soap *soap, int n)
{
	enum tt__NetworkHostType *p;
	enum tt__NetworkHostType *a = (enum tt__NetworkHostType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkHostType));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHostType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostType(struct soap *soap, const enum tt__NetworkHostType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHostType(soap, tag ? tag : "tt:NetworkHostType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_get_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkProtocolType[] =
{	{ (LONG64)tt__NetworkProtocolType__HTTP, "HTTP" },
	{ (LONG64)tt__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (LONG64)tt__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkProtocolType2s(struct soap *soap, enum tt__NetworkProtocolType n)
{
	const char *s = soap_code_str(soap_codes_tt__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolType), type) || soap_send(soap, soap_tt__NetworkProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkProtocolType(struct soap *soap, const char *s, enum tt__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkProtocolType, s);
	if (map)
		*a = (enum tt__NetworkProtocolType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_in_tt__NetworkProtocolType(struct soap *soap, const char *tag, enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkProtocolType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__NetworkProtocolType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_new_tt__NetworkProtocolType(struct soap *soap, int n)
{
	enum tt__NetworkProtocolType *p;
	enum tt__NetworkProtocolType *a = (enum tt__NetworkProtocolType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkProtocolType));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkProtocolType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolType(struct soap *soap, const enum tt__NetworkProtocolType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocolType(soap, tag ? tag : "tt:NetworkProtocolType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_get_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	{ (LONG64)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{
	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPv6DHCPConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_new_tt__IPv6DHCPConfiguration(struct soap *soap, int n)
{
	enum tt__IPv6DHCPConfiguration *p;
	enum tt__IPv6DHCPConfiguration *a = (enum tt__IPv6DHCPConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPv6DHCPConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6DHCPConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	{ (LONG64)tt__Duplex__Full, "Full" },
	{ (LONG64)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{
	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Duplex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Duplex(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_new_tt__Duplex(struct soap *soap, int n)
{
	enum tt__Duplex *p;
	enum tt__Duplex *a = (enum tt__Duplex*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Duplex));
	for (p = a; p && n--; p++)
		soap_default_tt__Duplex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	if (soap_out_tt__Duplex(soap, tag ? tag : "tt:Duplex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DiscoveryMode[] =
{	{ (LONG64)tt__DiscoveryMode__Discoverable, "Discoverable" },
	{ (LONG64)tt__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DiscoveryMode2s(struct soap *soap, enum tt__DiscoveryMode n)
{
	const char *s = soap_code_str(soap_codes_tt__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DiscoveryMode), type) || soap_send(soap, soap_tt__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DiscoveryMode(struct soap *soap, const char *s, enum tt__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DiscoveryMode, s);
	if (map)
		*a = (enum tt__DiscoveryMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_in_tt__DiscoveryMode(struct soap *soap, const char *tag, enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DiscoveryMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_new_tt__DiscoveryMode(struct soap *soap, int n)
{
	enum tt__DiscoveryMode *p;
	enum tt__DiscoveryMode *a = (enum tt__DiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default_tt__DiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DiscoveryMode(struct soap *soap, const enum tt__DiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__DiscoveryMode(soap, tag ? tag : "tt:DiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_get_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ScopeDefinition[] =
{	{ (LONG64)tt__ScopeDefinition__Fixed, "Fixed" },
	{ (LONG64)tt__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ScopeDefinition2s(struct soap *soap, enum tt__ScopeDefinition n)
{
	const char *s = soap_code_str(soap_codes_tt__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ScopeDefinition), type) || soap_send(soap, soap_tt__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ScopeDefinition(struct soap *soap, const char *s, enum tt__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ScopeDefinition, s);
	if (map)
		*a = (enum tt__ScopeDefinition)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_in_tt__ScopeDefinition(struct soap *soap, const char *tag, enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ScopeDefinition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ScopeDefinition(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_new_tt__ScopeDefinition(struct soap *soap, int n)
{
	enum tt__ScopeDefinition *p;
	enum tt__ScopeDefinition *a = (enum tt__ScopeDefinition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ScopeDefinition));
	for (p = a; p && n--; p++)
		soap_default_tt__ScopeDefinition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ScopeDefinition(struct soap *soap, const enum tt__ScopeDefinition *a, const char *tag, const char *type)
{
	if (soap_out_tt__ScopeDefinition(soap, tag ? tag : "tt:ScopeDefinition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_get_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__TransportProtocol[] =
{	{ (LONG64)tt__TransportProtocol__UDP, "UDP" },
	{ (LONG64)tt__TransportProtocol__TCP, "TCP" },
	{ (LONG64)tt__TransportProtocol__RTSP, "RTSP" },
	{ (LONG64)tt__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TransportProtocol2s(struct soap *soap, enum tt__TransportProtocol n)
{
	const char *s = soap_code_str(soap_codes_tt__TransportProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol(struct soap *soap, const char *tag, int id, const enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransportProtocol), type) || soap_send(soap, soap_tt__TransportProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TransportProtocol(struct soap *soap, const char *s, enum tt__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__TransportProtocol, s);
	if (map)
		*a = (enum tt__TransportProtocol)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_in_tt__TransportProtocol(struct soap *soap, const char *tag, enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__TransportProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__TransportProtocol(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_new_tt__TransportProtocol(struct soap *soap, int n)
{
	enum tt__TransportProtocol *p;
	enum tt__TransportProtocol *a = (enum tt__TransportProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__TransportProtocol));
	for (p = a; p && n--; p++)
		soap_default_tt__TransportProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransportProtocol(struct soap *soap, const enum tt__TransportProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tt__TransportProtocol(soap, tag ? tag : "tt:TransportProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_get_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__StreamType[] =
{	{ (LONG64)tt__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (LONG64)tt__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__StreamType2s(struct soap *soap, enum tt__StreamType n)
{
	const char *s = soap_code_str(soap_codes_tt__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType(struct soap *soap, const char *tag, int id, const enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamType), type) || soap_send(soap, soap_tt__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__StreamType(struct soap *soap, const char *s, enum tt__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__StreamType, s);
	if (map)
		*a = (enum tt__StreamType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_in_tt__StreamType(struct soap *soap, const char *tag, enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__StreamType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__StreamType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_new_tt__StreamType(struct soap *soap, int n)
{
	enum tt__StreamType *p;
	enum tt__StreamType *a = (enum tt__StreamType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__StreamType));
	for (p = a; p && n--; p++)
		soap_default_tt__StreamType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamType(struct soap *soap, const enum tt__StreamType *a, const char *tag, const char *type)
{
	if (soap_out_tt__StreamType(soap, tag ? tag : "tt:StreamType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_get_tt__StreamType(struct soap *soap, enum tt__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MetadataCompressionType[] =
{	{ (LONG64)tt__MetadataCompressionType__None, "None" },
	{ (LONG64)tt__MetadataCompressionType__GZIP, "GZIP" },
	{ (LONG64)tt__MetadataCompressionType__EXI, "EXI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MetadataCompressionType2s(struct soap *soap, enum tt__MetadataCompressionType n)
{
	const char *s = soap_code_str(soap_codes_tt__MetadataCompressionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataCompressionType(struct soap *soap, const char *tag, int id, const enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataCompressionType), type) || soap_send(soap, soap_tt__MetadataCompressionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MetadataCompressionType(struct soap *soap, const char *s, enum tt__MetadataCompressionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MetadataCompressionType, s);
	if (map)
		*a = (enum tt__MetadataCompressionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MetadataCompressionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_in_tt__MetadataCompressionType(struct soap *soap, const char *tag, enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MetadataCompressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MetadataCompressionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MetadataCompressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataCompressionType, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_new_tt__MetadataCompressionType(struct soap *soap, int n)
{
	enum tt__MetadataCompressionType *p;
	enum tt__MetadataCompressionType *a = (enum tt__MetadataCompressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MetadataCompressionType));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataCompressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataCompressionType(struct soap *soap, const enum tt__MetadataCompressionType *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataCompressionType(soap, tag ? tag : "tt:MetadataCompressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_get_tt__MetadataCompressionType(struct soap *soap, enum tt__MetadataCompressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataCompressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncodingMimeNames[] =
{	{ (LONG64)tt__AudioEncodingMimeNames__PCMU, "PCMU" },
	{ (LONG64)tt__AudioEncodingMimeNames__G726, "G726" },
	{ (LONG64)tt__AudioEncodingMimeNames__MP4A_LATM, "MP4A-LATM" },
	{ (LONG64)tt__AudioEncodingMimeNames__mpeg4_generic, "mpeg4-generic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncodingMimeNames2s(struct soap *soap, enum tt__AudioEncodingMimeNames n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncodingMimeNames), type) || soap_send(soap, soap_tt__AudioEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncodingMimeNames(struct soap *soap, const char *s, enum tt__AudioEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncodingMimeNames, s);
	if (map)
		*a = (enum tt__AudioEncodingMimeNames)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_in_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncodingMimeNames*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioEncodingMimeNames(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncodingMimeNames, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_new_tt__AudioEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__AudioEncodingMimeNames *p;
	enum tt__AudioEncodingMimeNames *a = (enum tt__AudioEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncodingMimeNames(struct soap *soap, const enum tt__AudioEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncodingMimeNames(soap, tag ? tag : "tt:AudioEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_get_tt__AudioEncodingMimeNames(struct soap *soap, enum tt__AudioEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	{ (LONG64)tt__AudioEncoding__G711, "G711" },
	{ (LONG64)tt__AudioEncoding__G726, "G726" },
	{ (LONG64)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map)
		*a = (enum tt__AudioEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_new_tt__AudioEncoding(struct soap *soap, int n)
{
	enum tt__AudioEncoding *p;
	enum tt__AudioEncoding *a = (enum tt__AudioEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoding(soap, tag ? tag : "tt:AudioEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingProfiles[] =
{	{ (LONG64)tt__VideoEncodingProfiles__Simple, "Simple" },
	{ (LONG64)tt__VideoEncodingProfiles__AdvancedSimple, "AdvancedSimple" },
	{ (LONG64)tt__VideoEncodingProfiles__Baseline, "Baseline" },
	{ (LONG64)tt__VideoEncodingProfiles__Main, "Main" },
	{ (LONG64)tt__VideoEncodingProfiles__Main10, "Main10" },
	{ (LONG64)tt__VideoEncodingProfiles__Extended, "Extended" },
	{ (LONG64)tt__VideoEncodingProfiles__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingProfiles2s(struct soap *soap, enum tt__VideoEncodingProfiles n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncodingProfiles, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingProfiles), type) || soap_send(soap, soap_tt__VideoEncodingProfiles2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingProfiles(struct soap *soap, const char *s, enum tt__VideoEncodingProfiles *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingProfiles, s);
	if (map)
		*a = (enum tt__VideoEncodingProfiles)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingProfiles)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_in_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingProfiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncodingProfiles(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingProfiles, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_new_tt__VideoEncodingProfiles(struct soap *soap, int n)
{
	enum tt__VideoEncodingProfiles *p;
	enum tt__VideoEncodingProfiles *a = (enum tt__VideoEncodingProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingProfiles));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingProfiles(struct soap *soap, const enum tt__VideoEncodingProfiles *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingProfiles(soap, tag ? tag : "tt:VideoEncodingProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_get_tt__VideoEncodingProfiles(struct soap *soap, enum tt__VideoEncodingProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingMimeNames[] =
{	{ (LONG64)tt__VideoEncodingMimeNames__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncodingMimeNames__MPV4_ES, "MPV4-ES" },
	{ (LONG64)tt__VideoEncodingMimeNames__H264, "H264" },
	{ (LONG64)tt__VideoEncodingMimeNames__H265, "H265" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingMimeNames2s(struct soap *soap, enum tt__VideoEncodingMimeNames n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingMimeNames), type) || soap_send(soap, soap_tt__VideoEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingMimeNames(struct soap *soap, const char *s, enum tt__VideoEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingMimeNames, s);
	if (map)
		*a = (enum tt__VideoEncodingMimeNames)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_in_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingMimeNames*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncodingMimeNames(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingMimeNames, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_new_tt__VideoEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__VideoEncodingMimeNames *p;
	enum tt__VideoEncodingMimeNames *a = (enum tt__VideoEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingMimeNames(struct soap *soap, const enum tt__VideoEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingMimeNames(soap, tag ? tag : "tt:VideoEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_get_tt__VideoEncodingMimeNames(struct soap *soap, enum tt__VideoEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (LONG64)tt__H264Profile__Baseline, "Baseline" },
	{ (LONG64)tt__H264Profile__Main, "Main" },
	{ (LONG64)tt__H264Profile__Extended, "Extended" },
	{ (LONG64)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__H264Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n)
{
	enum tt__H264Profile *p;
	enum tt__H264Profile *a = (enum tt__H264Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__H264Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (LONG64)tt__Mpeg4Profile__SP, "SP" },
	{ (LONG64)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n)
{
	enum tt__Mpeg4Profile *p;
	enum tt__Mpeg4Profile *a = (enum tt__Mpeg4Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Mpeg4Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (LONG64)tt__VideoEncoding__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (LONG64)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n)
{
	enum tt__VideoEncoding *p;
	enum tt__VideoEncoding *a = (enum tt__VideoEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoding(soap, tag ? tag : "tt:VideoEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ViewModes[] =
{	{ (LONG64)tt__ViewModes__tt_x003aFisheye, "tt:Fisheye" },
	{ (LONG64)tt__ViewModes__tt_x003a360Panorama, "tt:360Panorama" },
	{ (LONG64)tt__ViewModes__tt_x003a180Panorama, "tt:180Panorama" },
	{ (LONG64)tt__ViewModes__tt_x003aQuad, "tt:Quad" },
	{ (LONG64)tt__ViewModes__tt_x003aOriginal, "tt:Original" },
	{ (LONG64)tt__ViewModes__tt_x003aLeftHalf, "tt:LeftHalf" },
	{ (LONG64)tt__ViewModes__tt_x003aRightHalf, "tt:RightHalf" },
	{ (LONG64)tt__ViewModes__tt_x003aDewarp, "tt:Dewarp" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ViewModes2s(struct soap *soap, enum tt__ViewModes n)
{
	const char *s = soap_code_str(soap_codes_tt__ViewModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ViewModes(struct soap *soap, const char *tag, int id, const enum tt__ViewModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ViewModes), type) || soap_send(soap, soap_tt__ViewModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ViewModes(struct soap *soap, const char *s, enum tt__ViewModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ViewModes, s);
	if (map)
		*a = (enum tt__ViewModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 7)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ViewModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_in_tt__ViewModes(struct soap *soap, const char *tag, enum tt__ViewModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ViewModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ViewModes, sizeof(enum tt__ViewModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ViewModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ViewModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ViewModes, SOAP_TYPE_tt__ViewModes, sizeof(enum tt__ViewModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_new_tt__ViewModes(struct soap *soap, int n)
{
	enum tt__ViewModes *p;
	enum tt__ViewModes *a = (enum tt__ViewModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ViewModes));
	for (p = a; p && n--; p++)
		soap_default_tt__ViewModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ViewModes(struct soap *soap, const enum tt__ViewModes *a, const char *tag, const char *type)
{
	if (soap_out_tt__ViewModes(soap, tag ? tag : "tt:ViewModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_get_tt__ViewModes(struct soap *soap, enum tt__ViewModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ViewModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SceneOrientationOption[] =
{	{ (LONG64)tt__SceneOrientationOption__Below, "Below" },
	{ (LONG64)tt__SceneOrientationOption__Horizon, "Horizon" },
	{ (LONG64)tt__SceneOrientationOption__Above, "Above" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationOption2s(struct soap *soap, enum tt__SceneOrientationOption n)
{
	const char *s = soap_code_str(soap_codes_tt__SceneOrientationOption, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationOption(struct soap *soap, const char *tag, int id, const enum tt__SceneOrientationOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientationOption), type) || soap_send(soap, soap_tt__SceneOrientationOption2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationOption(struct soap *soap, const char *s, enum tt__SceneOrientationOption *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SceneOrientationOption, s);
	if (map)
		*a = (enum tt__SceneOrientationOption)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SceneOrientationOption)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_in_tt__SceneOrientationOption(struct soap *soap, const char *tag, enum tt__SceneOrientationOption *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SceneOrientationOption*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SceneOrientationOption(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationOption, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_new_tt__SceneOrientationOption(struct soap *soap, int n)
{
	enum tt__SceneOrientationOption *p;
	enum tt__SceneOrientationOption *a = (enum tt__SceneOrientationOption*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SceneOrientationOption));
	for (p = a; p && n--; p++)
		soap_default_tt__SceneOrientationOption(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationOption(struct soap *soap, const enum tt__SceneOrientationOption *a, const char *tag, const char *type)
{
	if (soap_out_tt__SceneOrientationOption(soap, tag ? tag : "tt:SceneOrientationOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_get_tt__SceneOrientationOption(struct soap *soap, enum tt__SceneOrientationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SceneOrientationMode[] =
{	{ (LONG64)tt__SceneOrientationMode__MANUAL, "MANUAL" },
	{ (LONG64)tt__SceneOrientationMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationMode2s(struct soap *soap, enum tt__SceneOrientationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__SceneOrientationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientationMode), type) || soap_send(soap, soap_tt__SceneOrientationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationMode(struct soap *soap, const char *s, enum tt__SceneOrientationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SceneOrientationMode, s);
	if (map)
		*a = (enum tt__SceneOrientationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SceneOrientationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_in_tt__SceneOrientationMode(struct soap *soap, const char *tag, enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SceneOrientationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SceneOrientationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_new_tt__SceneOrientationMode(struct soap *soap, int n)
{
	enum tt__SceneOrientationMode *p;
	enum tt__SceneOrientationMode *a = (enum tt__SceneOrientationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SceneOrientationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__SceneOrientationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationMode(struct soap *soap, const enum tt__SceneOrientationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__SceneOrientationMode(soap, tag ? tag : "tt:SceneOrientationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_get_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RotateMode[] =
{	{ (LONG64)tt__RotateMode__OFF, "OFF" },
	{ (LONG64)tt__RotateMode__ON, "ON" },
	{ (LONG64)tt__RotateMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RotateMode2s(struct soap *soap, enum tt__RotateMode n)
{
	const char *s = soap_code_str(soap_codes_tt__RotateMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode(struct soap *soap, const char *tag, int id, const enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateMode), type) || soap_send(soap, soap_tt__RotateMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RotateMode(struct soap *soap, const char *s, enum tt__RotateMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RotateMode, s);
	if (map)
		*a = (enum tt__RotateMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RotateMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_in_tt__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RotateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RotateMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_new_tt__RotateMode(struct soap *soap, int n)
{
	enum tt__RotateMode *p;
	enum tt__RotateMode *a = (enum tt__RotateMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RotateMode));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateMode(struct soap *soap, const enum tt__RotateMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_get_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tds__StorageType[] =
{	{ (LONG64)tds__StorageType__NFS, "NFS" },
	{ (LONG64)tds__StorageType__CIFS, "CIFS" },
	{ (LONG64)tds__StorageType__CDMI, "CDMI" },
	{ (LONG64)tds__StorageType__FTP, "FTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tds__StorageType2s(struct soap *soap, enum tds__StorageType n)
{
	const char *s = soap_code_str(soap_codes_tds__StorageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageType(struct soap *soap, const char *tag, int id, const enum tds__StorageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageType), type) || soap_send(soap, soap_tds__StorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tds__StorageType(struct soap *soap, const char *s, enum tds__StorageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tds__StorageType, s);
	if (map)
		*a = (enum tds__StorageType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tds__StorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_in_tds__StorageType(struct soap *soap, const char *tag, enum tds__StorageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tds__StorageType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tds__StorageType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tds__StorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageType, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_new_tds__StorageType(struct soap *soap, int n)
{
	enum tds__StorageType *p;
	enum tds__StorageType *a = (enum tds__StorageType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tds__StorageType));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageType(struct soap *soap, const enum tds__StorageType *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageType(soap, tag ? tag : "tds:StorageType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_get_tds__StorageType(struct soap *soap, enum tds__StorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tds__AutoGeoModes[] =
{	{ (LONG64)tds__AutoGeoModes__Location, "Location" },
	{ (LONG64)tds__AutoGeoModes__Heading, "Heading" },
	{ (LONG64)tds__AutoGeoModes__Leveling, "Leveling" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tds__AutoGeoModes2s(struct soap *soap, enum tds__AutoGeoModes n)
{
	const char *s = soap_code_str(soap_codes_tds__AutoGeoModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__AutoGeoModes(struct soap *soap, const char *tag, int id, const enum tds__AutoGeoModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__AutoGeoModes), type) || soap_send(soap, soap_tds__AutoGeoModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tds__AutoGeoModes(struct soap *soap, const char *s, enum tds__AutoGeoModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tds__AutoGeoModes, s);
	if (map)
		*a = (enum tds__AutoGeoModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tds__AutoGeoModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_in_tds__AutoGeoModes(struct soap *soap, const char *tag, enum tds__AutoGeoModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tds__AutoGeoModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__AutoGeoModes, sizeof(enum tds__AutoGeoModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tds__AutoGeoModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tds__AutoGeoModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__AutoGeoModes, SOAP_TYPE_tds__AutoGeoModes, sizeof(enum tds__AutoGeoModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_new_tds__AutoGeoModes(struct soap *soap, int n)
{
	enum tds__AutoGeoModes *p;
	enum tds__AutoGeoModes *a = (enum tds__AutoGeoModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tds__AutoGeoModes));
	for (p = a; p && n--; p++)
		soap_default_tds__AutoGeoModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__AutoGeoModes(struct soap *soap, const enum tds__AutoGeoModes *a, const char *tag, const char *type)
{
	if (soap_out_tds__AutoGeoModes(soap, tag ? tag : "tds:AutoGeoModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_get_tds__AutoGeoModes(struct soap *soap, enum tds__AutoGeoModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__AutoGeoModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *p;
	enum _wsa5__IsReferenceParameter *a = (enum _wsa5__IsReferenceParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter));
	for (p = a; p && n--; p++)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *p;
	enum wsa5__FaultCodesType *a = (enum wsa5__FaultCodesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *p;
	enum wsa5__RelationshipType *a = (enum wsa5__RelationshipType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsdd__FaultCodeType[] =
{	{ (LONG64)wsdd__MatchingRuleNotSupported, "wsdd:MatchingRuleNotSupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsdd__FaultCodeType2s(struct soap *soap, enum wsdd__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsdd__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__FaultCodeType), type) || soap_send(soap, soap_wsdd__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsdd__FaultCodeType(struct soap *soap, const char *s, enum wsdd__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsdd__FaultCodeType, t);
	if (map)
		*a = (enum wsdd__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsdd__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_in_wsdd__FaultCodeType(struct soap *soap, const char *tag, enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsdd__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsdd__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsdd__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__FaultCodeType, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_new_wsdd__FaultCodeType(struct soap *soap, int n)
{
	enum wsdd__FaultCodeType *p;
	enum wsdd__FaultCodeType *a = (enum wsdd__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsdd__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeType(struct soap *soap, const enum wsdd__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeType(soap, tag ? tag : "wsdd:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_get_wsdd__FaultCodeType(struct soap *soap, enum wsdd__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (LONG64)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (LONG64)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (LONG64)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (LONG64)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (LONG64)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_new_wsa__FaultSubcodeValues(struct soap *soap, int n)
{
	enum wsa__FaultSubcodeValues *p;
	enum wsa__FaultSubcodeValues *a = (enum wsa__FaultSubcodeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__FaultSubcodeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__FaultSubcodeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__FaultSubcodeValues(soap, tag ? tag : "wsa:FaultSubcodeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (LONG64)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_new_wsa__RelationshipTypeValues(struct soap *soap, int n)
{
	enum wsa__RelationshipTypeValues *p;
	enum wsa__RelationshipTypeValues *a = (enum wsa__RelationshipTypeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__RelationshipTypeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__RelationshipTypeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__RelationshipTypeValues(soap, tag ? tag : "wsa:RelationshipTypeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml2__DecisionType[] =
{	{ (LONG64)saml2__DecisionType__Permit, "Permit" },
	{ (LONG64)saml2__DecisionType__Deny, "Deny" },
	{ (LONG64)saml2__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml2__DecisionType2s(struct soap *soap, enum saml2__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml2__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__DecisionType(struct soap *soap, const char *tag, int id, const enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__DecisionType), type) || soap_send(soap, soap_saml2__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml2__DecisionType(struct soap *soap, const char *s, enum saml2__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml2__DecisionType, s);
	if (map)
		*a = (enum saml2__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml2__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_in_saml2__DecisionType(struct soap *soap, const char *tag, enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml2__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml2__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_new_saml2__DecisionType(struct soap *soap, int n)
{
	enum saml2__DecisionType *p;
	enum saml2__DecisionType *a = (enum saml2__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml2__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__DecisionType(struct soap *soap, const enum saml2__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__DecisionType(soap, tag ? tag : "saml2:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_get_saml2__DecisionType(struct soap *soap, enum saml2__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml1__DecisionType[] =
{	{ (LONG64)saml1__DecisionType__Permit, "Permit" },
	{ (LONG64)saml1__DecisionType__Deny, "Deny" },
	{ (LONG64)saml1__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml1__DecisionType2s(struct soap *soap, enum saml1__DecisionType n)
{
	const char *s = soap_code_str(soap_codes_saml1__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DecisionType(struct soap *soap, const char *tag, int id, const enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DecisionType), type) || soap_send(soap, soap_saml1__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml1__DecisionType(struct soap *soap, const char *s, enum saml1__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml1__DecisionType, s);
	if (map)
		*a = (enum saml1__DecisionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml1__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_in_saml1__DecisionType(struct soap *soap, const char *tag, enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml1__DecisionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2saml1__DecisionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_new_saml1__DecisionType(struct soap *soap, int n)
{
	enum saml1__DecisionType *p;
	enum saml1__DecisionType *a = (enum saml1__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml1__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DecisionType(struct soap *soap, const enum saml1__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DecisionType(soap, tag ? tag : "saml1:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_get_saml1__DecisionType(struct soap *soap, enum saml1__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsc__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_new_wsc__FaultCodeType(struct soap *soap, int n)
{
	enum wsc__FaultCodeType *p;
	enum wsc__FaultCodeType *a = (enum wsc__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsc__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsc__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag ? tag : "wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{
	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_new_wsse__FaultcodeEnum(struct soap *soap, int n)
{
	enum wsse__FaultcodeEnum *p;
	enum wsse__FaultcodeEnum *a = (enum wsse__FaultcodeEnum*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsse__FaultcodeEnum));
	for (p = a; p && n--; p++)
		soap_default_wsse__FaultcodeEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag ? tag : "wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{
	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsu__tTimestampFault(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_new_wsu__tTimestampFault(struct soap *soap, int n)
{
	enum wsu__tTimestampFault *p;
	enum wsu__tTimestampFault *a = (enum wsu__tTimestampFault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsu__tTimestampFault));
	for (p = a; p && n--; p++)
		soap_default_wsu__tTimestampFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag ? tag : "wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__DeleteOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__DeleteOSD(soap, &a->trt__DeleteOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__DeleteOSD(struct soap *soap, const char *tag, int id, const struct __trt__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", -1, &a->trt__DeleteOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_in___trt__DeleteOSD(struct soap *soap, const char *tag, struct __trt__DeleteOSD *a, const char *type)
{
	size_t soap_flag_trt__DeleteOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__DeleteOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__DeleteOSD, sizeof(struct __trt__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__DeleteOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__DeleteOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", &a->trt__DeleteOSD, ""))
				{	soap_flag_trt__DeleteOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_new___trt__DeleteOSD(struct soap *soap, int n)
{
	struct __trt__DeleteOSD *p;
	struct __trt__DeleteOSD *a = (struct __trt__DeleteOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__DeleteOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__DeleteOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__DeleteOSD(soap, tag ? tag : "-trt:DeleteOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_get___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__CreateOSD(soap, &a->trt__CreateOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateOSD(struct soap *soap, const char *tag, int id, const struct __trt__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", -1, &a->trt__CreateOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_in___trt__CreateOSD(struct soap *soap, const char *tag, struct __trt__CreateOSD *a, const char *type)
{
	size_t soap_flag_trt__CreateOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__CreateOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateOSD, sizeof(struct __trt__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", &a->trt__CreateOSD, ""))
				{	soap_flag_trt__CreateOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_new___trt__CreateOSD(struct soap *soap, int n)
{
	struct __trt__CreateOSD *p;
	struct __trt__CreateOSD *a = (struct __trt__CreateOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__CreateOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__CreateOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__CreateOSD(soap, tag ? tag : "-trt:CreateOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_get___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetOSD(soap, &a->trt__SetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetOSD(struct soap *soap, const char *tag, int id, const struct __trt__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetOSD(soap, "trt:SetOSD", -1, &a->trt__SetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_in___trt__SetOSD(struct soap *soap, const char *tag, struct __trt__SetOSD *a, const char *type)
{
	size_t soap_flag_trt__SetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetOSD, sizeof(struct __trt__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetOSD(soap, "trt:SetOSD", &a->trt__SetOSD, ""))
				{	soap_flag_trt__SetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_new___trt__SetOSD(struct soap *soap, int n)
{
	struct __trt__SetOSD *p;
	struct __trt__SetOSD *a = (struct __trt__SetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__SetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetOSD(soap, tag ? tag : "-trt:SetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_get___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDOptions(soap, &a->trt__GetOSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", -1, &a->trt__GetOSDOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_in___trt__GetOSDOptions(struct soap *soap, const char *tag, struct __trt__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_trt__GetOSDOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDOptions, sizeof(struct __trt__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", &a->trt__GetOSDOptions, ""))
				{	soap_flag_trt__GetOSDOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_new___trt__GetOSDOptions(struct soap *soap, int n)
{
	struct __trt__GetOSDOptions *p;
	struct __trt__GetOSDOptions *a = (struct __trt__GetOSDOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSDOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSDOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDOptions(soap, tag ? tag : "-trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_get___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSD(soap, &a->trt__GetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSD(struct soap *soap, const char *tag, int id, const struct __trt__GetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSD(soap, "trt:GetOSD", -1, &a->trt__GetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_in___trt__GetOSD(struct soap *soap, const char *tag, struct __trt__GetOSD *a, const char *type)
{
	size_t soap_flag_trt__GetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSD, sizeof(struct __trt__GetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSD(soap, "trt:GetOSD", &a->trt__GetOSD, ""))
				{	soap_flag_trt__GetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_new___trt__GetOSD(struct soap *soap, int n)
{
	struct __trt__GetOSD *p;
	struct __trt__GetOSD *a = (struct __trt__GetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSD(soap, tag ? tag : "-trt:GetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_get___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDs(soap, &a->trt__GetOSDs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDs(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", -1, &a->trt__GetOSDs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_in___trt__GetOSDs(struct soap *soap, const char *tag, struct __trt__GetOSDs *a, const char *type)
{
	size_t soap_flag_trt__GetOSDs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDs*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDs, sizeof(struct __trt__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", &a->trt__GetOSDs, ""))
				{	soap_flag_trt__GetOSDs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_new___trt__GetOSDs(struct soap *soap, int n)
{
	struct __trt__GetOSDs *p;
	struct __trt__GetOSDs *a = (struct __trt__GetOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSDs));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDs(soap, tag ? tag : "-trt:GetOSDs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_get___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoSourceMode(soap, &a->trt__SetVideoSourceMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", -1, &a->trt__SetVideoSourceMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_in___trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct __trt__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoSourceMode*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceMode, sizeof(struct __trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", &a->trt__SetVideoSourceMode, ""))
				{	soap_flag_trt__SetVideoSourceMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_new___trt__SetVideoSourceMode(struct soap *soap, int n)
{
	struct __trt__SetVideoSourceMode *p;
	struct __trt__SetVideoSourceMode *a = (struct __trt__SetVideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetVideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default___trt__SetVideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoSourceMode(soap, tag ? tag : "-trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_get___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceModes(struct soap *soap, const struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceModes(soap, &a->trt__GetVideoSourceModes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceModes(soap, "trt:GetVideoSourceModes", -1, &a->trt__GetVideoSourceModes, ""))
		return soap->error;
	return SOAP_OK;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
