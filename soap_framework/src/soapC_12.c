/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WideDynamicRangeOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRangeOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->Level))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_new_tt__WideDynamicRangeOptions(struct soap *soap, int n)
{
	struct tt__WideDynamicRangeOptions *p;
	struct tt__WideDynamicRangeOptions *a = (struct tt__WideDynamicRangeOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WideDynamicRangeOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicRangeOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRangeOptions(struct soap *soap, const struct tt__WideDynamicRangeOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicRangeOptions(soap, tag ? tag : "tt:WideDynamicRangeOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions(struct soap *soap, struct tt__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions(struct soap *soap, const struct tt__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_tt__AutoFocusMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &a->FarLimit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
			if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (!a->DefaultSpeed)
	{	if (soap_element_empty(soap, "tt:DefaultSpeed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (!a->NearLimit)
	{	if (soap_element_empty(soap, "tt:NearLimit", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (!a->FarLimit)
	{	if (soap_element_empty(soap, "tt:FarLimit", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions * SOAP_FMAC4 soap_in_tt__FocusOptions(struct soap *soap, const char *tag, struct tt__FocusOptions *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_alloc_block(soap);
					a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_push_block_max(soap, soap_blist_AutoFocusModes, sizeof(enum tt__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_tt__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusModes", a->AutoFocusModes, "tt:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
		{	a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		}
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DefaultSpeed || !a->NearLimit || !a->FarLimit))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusOptions * SOAP_FMAC4 soap_new_tt__FocusOptions(struct soap *soap, int n)
{
	struct tt__FocusOptions *p;
	struct tt__FocusOptions *a = (struct tt__FocusOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions(struct soap *soap, const struct tt__FocusOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusOptions(soap, tag ? tag : "tt:FocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions * SOAP_FMAC4 soap_get_tt__FocusOptions(struct soap *soap, struct tt__FocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ExposureOptions(struct soap *soap, const struct tt__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_tt__ExposurePriority);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTott__FloatRange(soap, &a->Iris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions(struct soap *soap, const char *tag, int id, const struct tt__ExposureOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
			if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (!a->MinExposureTime)
	{	if (soap_element_empty(soap, "tt:MinExposureTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (!a->MaxExposureTime)
	{	if (soap_element_empty(soap, "tt:MaxExposureTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (!a->MinGain)
	{	if (soap_element_empty(soap, "tt:MinGain", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (!a->MaxGain)
	{	if (soap_element_empty(soap, "tt:MaxGain", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (!a->MinIris)
	{	if (soap_element_empty(soap, "tt:MinIris", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (!a->MaxIris)
	{	if (soap_element_empty(soap, "tt:MaxIris", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (!a->ExposureTime)
	{	if (soap_element_empty(soap, "tt:ExposureTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (!a->Gain)
	{	if (soap_element_empty(soap, "tt:Gain", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (!a->Iris)
	{	if (soap_element_empty(soap, "tt:Iris", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ExposureOptions * SOAP_FMAC4 soap_in_tt__ExposureOptions(struct soap *soap, const char *tag, struct tt__ExposureOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ExposureOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ExposureOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ExposureMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", a->Mode, "tt:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_alloc_block(soap);
					a->Priority = (enum tt__ExposurePriority *)soap_push_block_max(soap, soap_blist_Priority, sizeof(enum tt__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_tt__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", a->Priority, "tt:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->Gain, "tt:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->Iris, "tt:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
		{	a->Priority = (enum tt__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		}
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || a->__sizePriority < 1 || !a->MinExposureTime || !a->MaxExposureTime || !a->MinGain || !a->MaxGain || !a->MinIris || !a->MaxIris || !a->ExposureTime || !a->Gain || !a->Iris))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ExposureOptions * SOAP_FMAC4 soap_new_tt__ExposureOptions(struct soap *soap, int n)
{
	struct tt__ExposureOptions *p;
	struct tt__ExposureOptions *a = (struct tt__ExposureOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ExposureOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ExposureOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureOptions(struct soap *soap, const struct tt__ExposureOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposureOptions(soap, tag ? tag : "tt:ExposureOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions * SOAP_FMAC4 soap_get_tt__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensationOptions(struct soap *soap, const struct tt__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (!a->Level)
	{	if (soap_element_empty(soap, "tt:Level", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BacklightCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->Level))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions * SOAP_FMAC4 soap_new_tt__BacklightCompensationOptions(struct soap *soap, int n)
{
	struct tt__BacklightCompensationOptions *p;
	struct tt__BacklightCompensationOptions *a = (struct tt__BacklightCompensationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BacklightCompensationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationOptions(struct soap *soap, const struct tt__BacklightCompensationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensationOptions(soap, tag ? tag : "tt:BacklightCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions(struct soap *soap, struct tt__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions(struct soap *soap, const struct tt__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions(soap, &a->BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTott__ExposureOptions(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusOptions(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_tt__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions(soap, &a->WhiteBalance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions), type))
		return soap->error;
	if (!a->BacklightCompensation)
	{	if (soap_element_empty(soap, "tt:BacklightCompensation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (!a->Brightness)
	{	if (soap_element_empty(soap, "tt:Brightness", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (!a->ColorSaturation)
	{	if (soap_element_empty(soap, "tt:ColorSaturation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (!a->Contrast)
	{	if (soap_element_empty(soap, "tt:Contrast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (!a->Exposure)
	{	if (soap_element_empty(soap, "tt:Exposure", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ExposureOptions(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (!a->Focus)
	{	if (soap_element_empty(soap, "tt:Focus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusOptions(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
			if (soap_out_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (!a->Sharpness)
	{	if (soap_element_empty(soap, "tt:Sharpness", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (!a->WideDynamicRange)
	{	if (soap_element_empty(soap, "tt:WideDynamicRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (!a->WhiteBalance)
	{	if (soap_element_empty(soap, "tt:WhiteBalance", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions * SOAP_FMAC4 soap_in_tt__ImagingOptions(struct soap *soap, const char *tag, struct tt__ImagingOptions *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions, sizeof(struct tt__ImagingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensationOptions"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions(soap, "tt:Exposure", &a->Exposure, "tt:ExposureOptions"))
				{	soap_flag_Exposure--;
					continue;
				}
			}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions(soap, "tt:Focus", &a->Focus, "tt:FocusOptions"))
				{	soap_flag_Focus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_alloc_block(soap);
					a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_push_block_max(soap, soap_blist_IrCutFilterModes, sizeof(enum tt__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_tt__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", a->IrCutFilterModes, "tt:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRangeOptions"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalanceOptions"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
		{	a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		}
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->BacklightCompensation || !a->Brightness || !a->ColorSaturation || !a->Contrast || !a->Exposure || !a->Focus || a->__sizeIrCutFilterModes < 1 || !a->Sharpness || !a->WideDynamicRange || !a->WhiteBalance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions, SOAP_TYPE_tt__ImagingOptions, sizeof(struct tt__ImagingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions * SOAP_FMAC4 soap_new_tt__ImagingOptions(struct soap *soap, int n)
{
	struct tt__ImagingOptions *p;
	struct tt__ImagingOptions *a = (struct tt__ImagingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions(struct soap *soap, const struct tt__ImagingOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions(soap, tag ? tag : "tt:ImagingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions * SOAP_FMAC4 soap_get_tt__ImagingOptions(struct soap *soap, struct tt__ImagingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rectangle(struct soap *soap, struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bottom = NULL;
	a->top = NULL;
	a->right = NULL;
	a->left = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const struct tt__Rectangle *a, const char *type)
{
	if (a->bottom)
	{	soap_set_attr(soap, "bottom", soap_float2s(soap, *a->bottom), 1);
	}
	if (a->top)
	{	soap_set_attr(soap, "top", soap_float2s(soap, *a->top), 1);
	}
	if (a->right)
	{	soap_set_attr(soap, "right", soap_float2s(soap, *a->right), 1);
	}
	if (a->left)
	{	soap_set_attr(soap, "left", soap_float2s(soap, *a->left), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Rectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rectangle(soap, a);
	{
		const char *t = soap_attr_value(soap, "bottom", 5, 0);
		if (t)
		{
			if (!(a->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "top", 5, 0);
		if (t)
		{
			if (!(a->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "right", 5, 0);
		if (t)
		{
			if (!(a->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "left", 5, 0);
		if (t)
		{
			if (!(a->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_new_tt__Rectangle(struct soap *soap, int n)
{
	struct tt__Rectangle *p;
	struct tt__Rectangle *a = (struct tt__Rectangle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Rectangle));
	for (p = a; p && n--; p++)
		soap_default_tt__Rectangle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a, const char *tag, const char *type)
{
	if (soap_out_tt__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, struct tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension(struct soap *soap, const struct tt__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettingsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension * SOAP_FMAC4 soap_new_tt__ImagingSettingsExtension(struct soap *soap, int n)
{
	struct tt__ImagingSettingsExtension *p;
	struct tt__ImagingSettingsExtension *a = (struct tt__ImagingSettingsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettingsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettingsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension(struct soap *soap, const struct tt__ImagingSettingsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettingsExtension(soap, tag ? tag : "tt:ImagingSettingsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &a->Mode);
	soap_default_float(soap, &a->CrGain);
	soap_default_float(soap, &a->CbGain);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance(struct soap *soap, const struct tt__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WhiteBalanceMode);
	soap_embedded(soap, &a->CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->CbGain, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance * SOAP_FMAC4 soap_in_tt__WhiteBalance(struct soap *soap, const char *tag, struct tt__WhiteBalance *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_CrGain > 0 || soap_flag_CbGain > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalance * SOAP_FMAC4 soap_new_tt__WhiteBalance(struct soap *soap, int n)
{
	struct tt__WhiteBalance *p;
	struct tt__WhiteBalance *a = (struct tt__WhiteBalance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalance));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance(struct soap *soap, const struct tt__WhiteBalance *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalance(soap, tag ? tag : "tt:WhiteBalance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance * SOAP_FMAC4 soap_get_tt__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRange(struct soap *soap, const struct tt__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WideDynamicMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRange * SOAP_FMAC4 soap_in_tt__WideDynamicRange(struct soap *soap, const char *tag, struct tt__WideDynamicRange *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WideDynamicRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WideDynamicRange * SOAP_FMAC4 soap_new_tt__WideDynamicRange(struct soap *soap, int n)
{
	struct tt__WideDynamicRange *p;
	struct tt__WideDynamicRange *a = (struct tt__WideDynamicRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WideDynamicRange));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRange(struct soap *soap, const struct tt__WideDynamicRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicRange(soap, tag ? tag : "tt:WideDynamicRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange * SOAP_FMAC4 soap_get_tt__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Exposure(struct soap *soap, struct tt__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &a->Mode);
	soap_default_tt__ExposurePriority(soap, &a->Priority);
	a->Window = NULL;
	soap_default_float(soap, &a->MinExposureTime);
	soap_default_float(soap, &a->MaxExposureTime);
	soap_default_float(soap, &a->MinGain);
	soap_default_float(soap, &a->MaxGain);
	soap_default_float(soap, &a->MinIris);
	soap_default_float(soap, &a->MaxIris);
	soap_default_float(soap, &a->ExposureTime);
	soap_default_float(soap, &a->Gain);
	soap_default_float(soap, &a->Iris);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Exposure(struct soap *soap, const struct tt__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ExposureMode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_tt__ExposurePriority);
	soap_serialize_PointerTott__Rectangle(soap, &a->Window);
	soap_embedded(soap, &a->MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->Gain, SOAP_TYPE_float);
	soap_embedded(soap, &a->Iris, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure(struct soap *soap, const char *tag, int id, const struct tt__Exposure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (!a->Window)
	{	if (soap_element_empty(soap, "tt:Window", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->Window, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Exposure * SOAP_FMAC4 soap_in_tt__Exposure(struct soap *soap, const char *tag, struct tt__Exposure *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Exposure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Exposure(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->Mode, "tt:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposurePriority(soap, "tt:Priority", &a->Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->Window, "tt:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Priority > 0 || !a->Window || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Exposure * SOAP_FMAC4 soap_new_tt__Exposure(struct soap *soap, int n)
{
	struct tt__Exposure *p;
	struct tt__Exposure *a = (struct tt__Exposure*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Exposure));
	for (p = a; p && n--; p++)
		soap_default_tt__Exposure(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Exposure(struct soap *soap, const struct tt__Exposure *a, const char *tag, const char *type)
{
	if (soap_out_tt__Exposure(soap, tag ? tag : "tt:Exposure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure * SOAP_FMAC4 soap_get_tt__Exposure(struct soap *soap, struct tt__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensation(struct soap *soap, const struct tt__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__BacklightCompensationMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensation * SOAP_FMAC4 soap_in_tt__BacklightCompensation(struct soap *soap, const char *tag, struct tt__BacklightCompensation *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BacklightCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BacklightCompensation * SOAP_FMAC4 soap_new_tt__BacklightCompensation(struct soap *soap, int n)
{
	struct tt__BacklightCompensation *p;
	struct tt__BacklightCompensation *a = (struct tt__BacklightCompensation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BacklightCompensation));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensation(struct soap *soap, const struct tt__BacklightCompensation *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensation(soap, tag ? tag : "tt:BacklightCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation * SOAP_FMAC4 soap_get_tt__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettings(struct soap *soap, const struct tt__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTott__Exposure(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusConfiguration(soap, &a->Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRange(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettings * SOAP_FMAC4 soap_in_tt__ImagingSettings(struct soap *soap, const char *tag, struct tt__ImagingSettings *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensation"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure(soap, "tt:Exposure", &a->Exposure, "tt:Exposure"))
				{	soap_flag_Exposure--;
					continue;
				}
			}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration(soap, "tt:Focus", &a->Focus, "tt:FocusConfiguration"))
				{	soap_flag_Focus--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRange"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalance"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettings * SOAP_FMAC4 soap_new_tt__ImagingSettings(struct soap *soap, int n)
{
	struct tt__ImagingSettings *p;
	struct tt__ImagingSettings *a = (struct tt__ImagingSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettings));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettings(struct soap *soap, const struct tt__ImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings * SOAP_FMAC4 soap_get_tt__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &a->AutoFocusMode);
	soap_default_float(soap, &a->DefaultSpeed);
	soap_default_float(soap, &a->NearLimit);
	soap_default_float(soap, &a->FarLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration(struct soap *soap, const struct tt__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode);
	soap_embedded(soap, &a->DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &a->NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &a->FarLimit, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration * SOAP_FMAC4 soap_in_tt__FocusConfiguration(struct soap *soap, const char *tag, struct tt__FocusConfiguration *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0 || soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusConfiguration * SOAP_FMAC4 soap_new_tt__FocusConfiguration(struct soap *soap, int n)
{
	struct tt__FocusConfiguration *p;
	struct tt__FocusConfiguration *a = (struct tt__FocusConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration(struct soap *soap, const struct tt__FocusConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusConfiguration(soap, tag ? tag : "tt:FocusConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration * SOAP_FMAC4 soap_get_tt__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus(struct soap *soap, struct tt__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_tt__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus(struct soap *soap, const struct tt__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_string(soap, (char*const*)&a->Error);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (!a->Error)
	{	if (soap_element_empty(soap, "tt:Error", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus * SOAP_FMAC4 soap_in_tt__FocusStatus(struct soap *soap, const char *tag, struct tt__FocusStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0 || !a->Error))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusStatus * SOAP_FMAC4 soap_new_tt__FocusStatus(struct soap *soap, int n)
{
	struct tt__FocusStatus *p;
	struct tt__FocusStatus *a = (struct tt__FocusStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus(struct soap *soap, const struct tt__FocusStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusStatus(soap, tag ? tag : "tt:FocusStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus * SOAP_FMAC4 soap_get_tt__FocusStatus(struct soap *soap, struct tt__FocusStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus(struct soap *soap, struct tt__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus(struct soap *soap, const struct tt__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus(soap, &a->FocusStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus), type))
		return soap->error;
	if (!a->FocusStatus)
	{	if (soap_element_empty(soap, "tt:FocusStatus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusStatus(soap, "tt:FocusStatus", -1, &a->FocusStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus * SOAP_FMAC4 soap_in_tt__ImagingStatus(struct soap *soap, const char *tag, struct tt__ImagingStatus *a, const char *type)
{
	size_t soap_flag_FocusStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus, sizeof(struct tt__ImagingStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus(soap, "tt:FocusStatus", &a->FocusStatus, "tt:FocusStatus"))
				{	soap_flag_FocusStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->FocusStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus, SOAP_TYPE_tt__ImagingStatus, sizeof(struct tt__ImagingStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingStatus * SOAP_FMAC4 soap_new_tt__ImagingStatus(struct soap *soap, int n)
{
	struct tt__ImagingStatus *p;
	struct tt__ImagingStatus *a = (struct tt__ImagingStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus(struct soap *soap, const struct tt__ImagingStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingStatus(soap, tag ? tag : "tt:ImagingStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus * SOAP_FMAC4 soap_get_tt__ImagingStatus(struct soap *soap, struct tt__ImagingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const struct tt__PTZPresetTourStartingConditionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStartingConditionOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStartingConditionOptionsExtension *p;
	struct tt__PTZPresetTourStartingConditionOptionsExtension *a = (struct tt__PTZPresetTourStartingConditionOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStartingConditionOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const struct tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const struct tt__PTZPresetTourPresetDetailOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourPresetDetailOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourPresetDetailOptionsExtension *p;
	struct tt__PTZPresetTourPresetDetailOptionsExtension *a = (struct tt__PTZPresetTourPresetDetailOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourPresetDetailOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const struct tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePresetToken = 0;
	a->PresetToken = NULL;
	a->Home = NULL;
	a->PanTiltPositionSpace = NULL;
	a->ZoomPositionSpace = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const struct tt__PTZPresetTourPresetDetailOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PresetToken)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->PresetToken + i));
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->Home);
	soap_serialize_PointerTott__Space2DDescription(soap, &a->PanTiltPositionSpace);
	soap_serialize_PointerTott__Space1DDescription(soap, &a->ZoomPositionSpace);
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions), type))
		return soap->error;
	if (a->PresetToken)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetToken; i++)
			if (soap_out_string(soap, "tt:PresetToken", -1, (char*const*)(a->PresetToken + i), ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "tt:Home", -1, &a->Home, ""))
		return soap->error;
	if (soap_out_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", -1, &a->PanTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", -1, &a->ZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	struct soap_blist *soap_blist_PresetToken = NULL;
	size_t soap_flag_Home = 1;
	size_t soap_flag_PanTiltPositionSpace = 1;
	size_t soap_flag_ZoomPositionSpace = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourPresetDetailOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourPresetDetailOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PresetToken", 1, NULL))
			{	if (a->PresetToken == NULL)
				{	if (soap_blist_PresetToken == NULL)
						soap_blist_PresetToken = soap_alloc_block(soap);
					a->PresetToken = (char **)soap_push_block_max(soap, soap_blist_PresetToken, sizeof(char *));
					if (a->PresetToken == NULL)
						return NULL;
					*a->PresetToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:PresetToken", (char**)a->PresetToken, "tt:ReferenceToken"))
				{	a->__sizePresetToken++;
					a->PresetToken = NULL;
					continue;
				}
			}
			if (soap_flag_Home && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:Home", &a->Home, "xsd:boolean"))
				{	soap_flag_Home--;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSpace && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", &a->PanTiltPositionSpace, "tt:Space2DDescription"))
				{	soap_flag_PanTiltPositionSpace--;
					continue;
				}
			}
			if (soap_flag_ZoomPositionSpace && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", &a->ZoomPositionSpace, "tt:Space1DDescription"))
				{	soap_flag_ZoomPositionSpace--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourPresetDetailOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PresetToken)
			soap_pop_block(soap, soap_blist_PresetToken);
		if (a->__sizePresetToken)
		{	a->PresetToken = (char **)soap_save_block(soap, soap_blist_PresetToken, NULL, 1);
		}
		else
		{	a->PresetToken = NULL;
			if (soap_blist_PresetToken)
				soap_end_block(soap, soap_blist_PresetToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_new_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, int n)
{
	struct tt__PTZPresetTourPresetDetailOptions *p;
	struct tt__PTZPresetTourPresetDetailOptions *a = (struct tt__PTZPresetTourPresetDetailOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourPresetDetailOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourPresetDetailOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const struct tt__PTZPresetTourPresetDetailOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetDetail = NULL;
	a->StayTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSpotOptions(struct soap *soap, const struct tt__PTZPresetTourSpotOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(soap, &a->PresetDetail);
	soap_serialize_PointerTott__DurationRange(soap, &a->StayTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSpotOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions), type))
		return soap->error;
	if (!a->PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", -1, &a->PresetDetail, ""))
		return soap->error;
	if (!a->StayTime)
	{	if (soap_element_empty(soap, "tt:StayTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:StayTime", -1, &a->StayTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotOptions *a, const char *type)
{
	size_t soap_flag_PresetDetail = 1;
	size_t soap_flag_StayTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourSpotOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSpotOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", &a->PresetDetail, "tt:PTZPresetTourPresetDetailOptions"))
				{	soap_flag_PresetDetail--;
					continue;
				}
			}
			if (soap_flag_StayTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:StayTime", &a->StayTime, "tt:DurationRange"))
				{	soap_flag_StayTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetDetail || !a->StayTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotOptions, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_new_tt__PTZPresetTourSpotOptions(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSpotOptions *p;
	struct tt__PTZPresetTourSpotOptions *a = (struct tt__PTZPresetTourSpotOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSpotOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSpotOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSpotOptions(struct soap *soap, const struct tt__PTZPresetTourSpotOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSpotOptions(soap, tag ? tag : "tt:PTZPresetTourSpotOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecurringTime = NULL;
	a->RecurringDuration = NULL;
	a->__sizeDirection = 0;
	a->Direction = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const struct tt__PTZPresetTourStartingConditionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->RecurringTime);
	soap_serialize_PointerTott__DurationRange(soap, &a->RecurringDuration);
	if (a->Direction)
	{	int i;
		for (i = 0; i < (int)a->__sizeDirection; i++)
		{
			soap_embedded(soap, a->Direction + i, SOAP_TYPE_tt__PTZPresetTourDirection);
		}
	}
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:RecurringTime", -1, &a->RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:RecurringDuration", -1, &a->RecurringDuration, ""))
		return soap->error;
	if (a->Direction)
	{	int i;
		for (i = 0; i < (int)a->__sizeDirection; i++)
			if (soap_out_tt__PTZPresetTourDirection(soap, "tt:Direction", -1, a->Direction + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	size_t soap_flag_RecurringTime = 1;
	size_t soap_flag_RecurringDuration = 1;
	struct soap_blist *soap_blist_Direction = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStartingConditionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStartingConditionOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:RecurringTime", &a->RecurringTime, "tt:IntRange"))
				{	soap_flag_RecurringTime--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:RecurringDuration", &a->RecurringDuration, "tt:DurationRange"))
				{	soap_flag_RecurringDuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Direction", 1, NULL))
			{	if (a->Direction == NULL)
				{	if (soap_blist_Direction == NULL)
						soap_blist_Direction = soap_alloc_block(soap);
					a->Direction = (enum tt__PTZPresetTourDirection *)soap_push_block_max(soap, soap_blist_Direction, sizeof(enum tt__PTZPresetTourDirection));
					if (a->Direction == NULL)
						return NULL;
					soap_default_tt__PTZPresetTourDirection(soap, a->Direction);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPresetTourDirection(soap, "tt:Direction", a->Direction, "tt:PTZPresetTourDirection"))
				{	a->__sizeDirection++;
					a->Direction = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourStartingConditionOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Direction)
			soap_pop_block(soap, soap_blist_Direction);
		if (a->__sizeDirection)
		{	a->Direction = (enum tt__PTZPresetTourDirection *)soap_save_block(soap, soap_blist_Direction, NULL, 1);
		}
		else
		{	a->Direction = NULL;
			if (soap_blist_Direction)
				soap_end_block(soap, soap_blist_Direction);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_new_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStartingConditionOptions *p;
	struct tt__PTZPresetTourStartingConditionOptions *a = (struct tt__PTZPresetTourStartingConditionOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStartingConditionOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStartingConditionOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const struct tt__PTZPresetTourStartingConditionOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->AutoStart);
	a->StartingCondition = NULL;
	a->TourSpot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourOptions(struct soap *soap, const struct tt__PTZPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(soap, &a->StartingCondition);
	soap_serialize_PointerTott__PTZPresetTourSpotOptions(soap, &a->TourSpot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (!a->StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", -1, &a->StartingCondition, ""))
		return soap->error;
	if (!a->TourSpot)
	{	if (soap_element_empty(soap, "tt:TourSpot", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", -1, &a->TourSpot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourOptions *a, const char *type)
{
	size_t soap_flag_AutoStart = 1;
	size_t soap_flag_StartingCondition = 1;
	size_t soap_flag_TourSpot = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			}
			if (soap_flag_StartingCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", &a->StartingCondition, "tt:PTZPresetTourStartingConditionOptions"))
				{	soap_flag_StartingCondition--;
					continue;
				}
			}
			if (soap_flag_TourSpot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", &a->TourSpot, "tt:PTZPresetTourSpotOptions"))
				{	soap_flag_TourSpot--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoStart > 0 || !a->StartingCondition || !a->TourSpot))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOptions, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions * SOAP_FMAC4 soap_new_tt__PTZPresetTourOptions(struct soap *soap, int n)
{
	struct tt__PTZPresetTourOptions *p;
	struct tt__PTZPresetTourOptions *a = (struct tt__PTZPresetTourOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourOptions(struct soap *soap, const struct tt__PTZPresetTourOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourOptions(soap, tag ? tag : "tt:PTZPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const struct tt__PTZPresetTourStartingConditionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStartingConditionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStartingConditionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStartingConditionExtension *p;
	struct tt__PTZPresetTourStartingConditionExtension *a = (struct tt__PTZPresetTourStartingConditionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStartingConditionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStartingConditionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const struct tt__PTZPresetTourStartingConditionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStatusExtension(struct soap *soap, const struct tt__PTZPresetTourStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStatusExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatusExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStatusExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatusExtension, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourStatusExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStatusExtension *p;
	struct tt__PTZPresetTourStatusExtension *a = (struct tt__PTZPresetTourStatusExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStatusExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStatusExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStatusExtension(struct soap *soap, const struct tt__PTZPresetTourStatusExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStatusExtension(soap, tag ? tag : "tt:PTZPresetTourStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourTypeExtension(struct soap *soap, const struct tt__PTZPresetTourTypeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourTypeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourTypeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourTypeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourTypeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourTypeExtension, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourTypeExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourTypeExtension *p;
	struct tt__PTZPresetTourTypeExtension *a = (struct tt__PTZPresetTourTypeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourTypeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourTypeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourTypeExtension(struct soap *soap, const struct tt__PTZPresetTourTypeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSpotExtension(struct soap *soap, const struct tt__PTZPresetTourSpotExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourSpotExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSpotExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotExtension, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourSpotExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSpotExtension *p;
	struct tt__PTZPresetTourSpotExtension *a = (struct tt__PTZPresetTourSpotExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSpotExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSpotExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSpotExtension(struct soap *soap, const struct tt__PTZPresetTourSpotExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZPresetTourPresetDetail = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourPresetDetail(struct soap *soap, const struct tt__PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZPresetTourPresetDetail(soap, a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourPresetDetail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail), type))
		return soap->error;
	if (soap_out__tt__union_PTZPresetTourPresetDetail(soap, a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourPresetDetail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourPresetDetail(soap, a);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__tt__union_PTZPresetTourPresetDetail(soap, &a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetail, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_new_tt__PTZPresetTourPresetDetail(struct soap *soap, int n)
{
	struct tt__PTZPresetTourPresetDetail *p;
	struct tt__PTZPresetTourPresetDetail *a = (struct tt__PTZPresetTourPresetDetail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourPresetDetail));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourPresetDetail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourPresetDetail(struct soap *soap, const struct tt__PTZPresetTourPresetDetail *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourExtension(struct soap *soap, const struct tt__PTZPresetTourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourExtension, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourExtension *p;
	struct tt__PTZPresetTourExtension *a = (struct tt__PTZPresetTourExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourExtension(struct soap *soap, const struct tt__PTZPresetTourExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetDetail = NULL;
	a->Speed = NULL;
	soap_default_xsd__duration(soap, &a->StayTime);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSpot(struct soap *soap, const struct tt__PTZPresetTourSpot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetail(soap, &a->PresetDetail);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
	soap_serialize_xsd__duration(soap, (char*const*)&a->StayTime);
	soap_serialize_PointerTott__PTZPresetTourSpotExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSpot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpot), type))
		return soap->error;
	if (!a->PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", -1, &a->PresetDetail, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:StayTime", -1, (char*const*)&a->StayTime, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpot *a, const char *type)
{
	size_t soap_flag_PresetDetail = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_StayTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourSpot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSpot(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", &a->PresetDetail, "tt:PTZPresetTourPresetDetail"))
				{	soap_flag_PresetDetail--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap_flag_StayTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:StayTime", (char**)&a->StayTime, "xsd:duration"))
				{	soap_flag_StayTime--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourSpotExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetDetail))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_new_tt__PTZPresetTourSpot(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSpot *p;
	struct tt__PTZPresetTourSpot *a = (struct tt__PTZPresetTourSpot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSpot));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSpot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSpot(struct soap *soap, const struct tt__PTZPresetTourSpot *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecurringTime = NULL;
	soap_default_xsd__duration(soap, &a->RecurringDuration);
	a->Direction = NULL;
	a->Extension = NULL;
	a->RandomPresetOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStartingCondition(struct soap *soap, const struct tt__PTZPresetTourStartingCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->RecurringTime);
	soap_serialize_xsd__duration(soap, (char*const*)&a->RecurringDuration);
	soap_serialize_PointerTott__PTZPresetTourDirection(soap, &a->Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStartingCondition *a, const char *type)
{
	if (a->RandomPresetOrder)
	{	soap_set_attr(soap, "RandomPresetOrder", soap_xsd__boolean2s(soap, *a->RandomPresetOrder), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RecurringTime", -1, &a->RecurringTime, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:RecurringDuration", -1, (char*const*)&a->RecurringDuration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingCondition *a, const char *type)
{
	size_t soap_flag_RecurringTime = 1;
	size_t soap_flag_RecurringDuration = 1;
	size_t soap_flag_Direction = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStartingCondition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStartingCondition(soap, a);
	{
		const char *t = soap_attr_value(soap, "RandomPresetOrder", 5, 0);
		if (t)
		{
			if (!(a->RandomPresetOrder = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RandomPresetOrder))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RecurringTime", &a->RecurringTime, "xsd:int"))
				{	soap_flag_RecurringTime--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:RecurringDuration", (char**)&a->RecurringDuration, "xsd:duration"))
				{	soap_flag_RecurringDuration--;
					continue;
				}
			}
			if (soap_flag_Direction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", &a->Direction, "tt:PTZPresetTourDirection"))
				{	soap_flag_Direction--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourStartingConditionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingCondition, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_new_tt__PTZPresetTourStartingCondition(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStartingCondition *p;
	struct tt__PTZPresetTourStartingCondition *a = (struct tt__PTZPresetTourStartingCondition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStartingCondition));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStartingCondition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStartingCondition(struct soap *soap, const struct tt__PTZPresetTourStartingCondition *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourState(soap, &a->State);
	a->CurrentTourSpot = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStatus(struct soap *soap, const struct tt__PTZPresetTourStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSpot(soap, &a->CurrentTourSpot);
	soap_serialize_PointerTott__PTZPresetTourStatusExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatus), type))
		return soap->error;
	if (soap_out_tt__PTZPresetTourState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", -1, &a->CurrentTourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatus *a, const char *type)
{
	size_t soap_flag_State = 1;
	size_t soap_flag_CurrentTourSpot = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__PTZPresetTourState(soap, "tt:State", &a->State, "tt:PTZPresetTourState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap_flag_CurrentTourSpot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", &a->CurrentTourSpot, "tt:PTZPresetTourSpot"))
				{	soap_flag_CurrentTourSpot--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourStatusExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatus, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_new_tt__PTZPresetTourStatus(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStatus *p;
	struct tt__PTZPresetTourStatus *a = (struct tt__PTZPresetTourStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStatus(struct soap *soap, const struct tt__PTZPresetTourStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PresetTour(struct soap *soap, struct tt__PresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->Status = NULL;
	soap_default_xsd__boolean(soap, &a->AutoStart);
	a->StartingCondition = NULL;
	a->__sizeTourSpot = 0;
	a->TourSpot = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PresetTour(struct soap *soap, const struct tt__PresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZPresetTourStatus(soap, &a->Status);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__PTZPresetTourStartingCondition(soap, &a->StartingCondition);
	if (a->TourSpot)
	{	int i;
		for (i = 0; i < (int)a->__sizeTourSpot; i++)
		{
			soap_embedded(soap, a->TourSpot + i, SOAP_TYPE_tt__PTZPresetTourSpot);
			soap_serialize_tt__PTZPresetTourSpot(soap, a->TourSpot + i);
		}
	}
	soap_serialize_PointerTott__PTZPresetTourExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PresetTour(struct soap *soap, const char *tag, int id, const struct tt__PresetTour *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PresetTour), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Status)
	{	if (soap_element_empty(soap, "tt:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStatus(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (!a->StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", -1, &a->StartingCondition, ""))
		return soap->error;
	if (a->TourSpot)
	{	int i;
		for (i = 0; i < (int)a->__sizeTourSpot; i++)
			if (soap_out_tt__PTZPresetTourSpot(soap, "tt:TourSpot", -1, a->TourSpot + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_in_tt__PresetTour(struct soap *soap, const char *tag, struct tt__PresetTour *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_AutoStart = 1;
	size_t soap_flag_StartingCondition = 1;
	struct soap_blist *soap_blist_TourSpot = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PresetTour(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 0), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatus(soap, "tt:Status", &a->Status, "tt:PTZPresetTourStatus"))
				{	soap_flag_Status--;
					continue;
				}
			}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			}
			if (soap_flag_StartingCondition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", &a->StartingCondition, "tt:PTZPresetTourStartingCondition"))
				{	soap_flag_StartingCondition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TourSpot", 1, NULL))
			{	if (a->TourSpot == NULL)
				{	if (soap_blist_TourSpot == NULL)
						soap_blist_TourSpot = soap_alloc_block(soap);
					a->TourSpot = (struct tt__PTZPresetTourSpot *)soap_push_block_max(soap, soap_blist_TourSpot, sizeof(struct tt__PTZPresetTourSpot));
					if (a->TourSpot == NULL)
						return NULL;
					soap_default_tt__PTZPresetTourSpot(soap, a->TourSpot);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPresetTourSpot(soap, "tt:TourSpot", a->TourSpot, "tt:PTZPresetTourSpot"))
				{	a->__sizeTourSpot++;
					a->TourSpot = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TourSpot)
			soap_pop_block(soap, soap_blist_TourSpot);
		if (a->__sizeTourSpot)
		{	a->TourSpot = (struct tt__PTZPresetTourSpot *)soap_save_block(soap, soap_blist_TourSpot, NULL, 1);
		}
		else
		{	a->TourSpot = NULL;
			if (soap_blist_TourSpot)
				soap_end_block(soap, soap_blist_TourSpot);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status || soap_flag_AutoStart > 0 || !a->StartingCondition))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PresetTour, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_new_tt__PresetTour(struct soap *soap, int n)
{
	struct tt__PresetTour *p;
	struct tt__PresetTour *a = (struct tt__PresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PresetTour));
	for (p = a; p && n--; p++)
		soap_default_tt__PresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PresetTour(struct soap *soap, const struct tt__PresetTour *a, const char *tag, const char *type)
{
	if (soap_out_tt__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_get_tt__PresetTour(struct soap *soap, struct tt__PresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZVector(struct soap *soap, struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const struct tt__PTZVector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZVector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZVector(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_new_tt__PTZVector(struct soap *soap, int n)
{
	struct tt__PTZVector *p;
	struct tt__PTZVector *a = (struct tt__PTZVector*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZVector));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZVector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, struct tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->PTZPosition = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const struct tt__PTZPreset *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_PTZPosition = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPreset(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 0), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_new_tt__PTZPreset(struct soap *soap, int n)
{
	struct tt__PTZPreset *p;
	struct tt__PTZPreset *a = (struct tt__PTZPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPreset));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector1D(struct soap *soap, struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const struct tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &a->x))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 4, 0), &a->space))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_new_tt__Vector1D(struct soap *soap, int n)
{
	struct tt__Vector1D *p;
	struct tt__Vector1D *a = (struct tt__Vector1D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector1D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector1D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, struct tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector2D(struct soap *soap, struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const struct tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &a->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 1), &a->y))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 4, 0), &a->space))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_new_tt__Vector2D(struct soap *soap, int n)
{
	struct tt__Vector2D *p;
	struct tt__Vector2D *a = (struct tt__Vector2D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector2D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector2D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, struct tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const struct tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpeed(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_new_tt__PTZSpeed(struct soap *soap, int n)
{
	struct tt__PTZSpeed *p;
	struct tt__PTZSpeed *a = (struct tt__PTZSpeed*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpeed));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpeed(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZSpacesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, struct tt__PTZSpacesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZSpacesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpacesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_new_tt__PTZSpacesExtension(struct soap *soap, int n)
{
	struct tt__PTZSpacesExtension *p;
	struct tt__PTZSpacesExtension *a = (struct tt__PTZSpacesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpacesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpacesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_empty(soap, "tt:URI", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space1DDescription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_new_tt__Space1DDescription(struct soap *soap, int n)
{
	struct tt__Space1DDescription *p;
	struct tt__Space1DDescription *a = (struct tt__Space1DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space1DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space1DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const struct tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ZoomLimits(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->Range, "tt:Space1DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_new_tt__ZoomLimits(struct soap *soap, int n)
{
	struct tt__ZoomLimits *p;
	struct tt__ZoomLimits *a = (struct tt__ZoomLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ZoomLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__ZoomLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTott__FloatRange(soap, &a->YRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_empty(soap, "tt:URI", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	if (!a->YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->YRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space2DDescription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->YRange, "tt:FloatRange"))
				{	soap_flag_YRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->URI || !a->XRange || !a->YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_new_tt__Space2DDescription(struct soap *soap, int n)
{
	struct tt__Space2DDescription *p;
	struct tt__Space2DDescription *a = (struct tt__Space2DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space2DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space2DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PanTiltLimits(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->Range, "tt:Space2DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_new_tt__PanTiltLimits(struct soap *soap, int n)
{
	struct tt__PanTiltLimits *p;
	struct tt__PanTiltLimits *a = (struct tt__PanTiltLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PanTiltLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__PanTiltLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReverseOptionsExtension(struct soap *soap, const struct tt__ReverseOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__ReverseOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_in_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, struct tt__ReverseOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ReverseOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReverseOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptionsExtension, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_new_tt__ReverseOptionsExtension(struct soap *soap, int n)
{
	struct tt__ReverseOptionsExtension *p;
	struct tt__ReverseOptionsExtension *a = (struct tt__ReverseOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReverseOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseOptionsExtension(struct soap *soap, const struct tt__ReverseOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_get_tt__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlipOptionsExtension(struct soap *soap, const struct tt__EFlipOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__EFlipOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_in_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, struct tt__EFlipOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EFlipOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlipOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptionsExtension, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_new_tt__EFlipOptionsExtension(struct soap *soap, int n)
{
	struct tt__EFlipOptionsExtension *p;
	struct tt__EFlipOptionsExtension *a = (struct tt__EFlipOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlipOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipOptionsExtension(struct soap *soap, const struct tt__EFlipOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_get_tt__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionOptionsExtension(struct soap *soap, const struct tt__PTControlDirectionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTControlDirectionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_new_tt__PTControlDirectionOptionsExtension(struct soap *soap, int n)
{
	struct tt__PTControlDirectionOptionsExtension *p;
	struct tt__PTControlDirectionOptionsExtension *a = (struct tt__PTControlDirectionOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionOptionsExtension(struct soap *soap, const struct tt__PTControlDirectionOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReverseOptions(struct soap *soap, const struct tt__ReverseOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ReverseMode);
		}
	}
	soap_serialize_PointerTott__ReverseOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptions(struct soap *soap, const char *tag, int id, const struct tt__ReverseOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_in_tt__ReverseOptions(struct soap *soap, const char *tag, struct tt__ReverseOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ReverseOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReverseOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ReverseMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ReverseMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ReverseMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ReverseMode(soap, "tt:Mode", a->Mode, "tt:ReverseMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:ReverseOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ReverseMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptions, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_new_tt__ReverseOptions(struct soap *soap, int n)
{
	struct tt__ReverseOptions *p;
	struct tt__ReverseOptions *a = (struct tt__ReverseOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReverseOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseOptions(struct soap *soap, const struct tt__ReverseOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_get_tt__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlipOptions(struct soap *soap, const struct tt__EFlipOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__EFlipMode);
		}
	}
	soap_serialize_PointerTott__EFlipOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptions(struct soap *soap, const char *tag, int id, const struct tt__EFlipOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_in_tt__EFlipOptions(struct soap *soap, const char *tag, struct tt__EFlipOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EFlipOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlipOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__EFlipMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__EFlipMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__EFlipMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__EFlipMode(soap, "tt:Mode", a->Mode, "tt:EFlipMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:EFlipOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__EFlipMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptions, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_new_tt__EFlipOptions(struct soap *soap, int n)
{
	struct tt__EFlipOptions *p;
	struct tt__EFlipOptions *a = (struct tt__EFlipOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlipOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipOptions(struct soap *soap, const struct tt__EFlipOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_get_tt__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationOptions2(struct soap *soap, const struct tt__PTZConfigurationOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZConfigurationOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationOptions2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions2, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_new_tt__PTZConfigurationOptions2(struct soap *soap, int n)
{
	struct tt__PTZConfigurationOptions2 *p;
	struct tt__PTZConfigurationOptions2 *a = (struct tt__PTZConfigurationOptions2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationOptions2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationOptions2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationOptions2(struct soap *soap, const struct tt__PTZConfigurationOptions2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionOptions(struct soap *soap, const struct tt__PTControlDirectionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlipOptions(soap, &a->EFlip);
	soap_serialize_PointerTott__ReverseOptions(soap, &a->Reverse);
	soap_serialize_PointerTott__PTControlDirectionOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptions(soap, "tt:EFlip", -1, &a->EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptions(soap, "tt:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptions *a, const char *type)
{
	size_t soap_flag_EFlip = 1;
	size_t soap_flag_Reverse = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTControlDirectionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptions(soap, "tt:EFlip", &a->EFlip, "tt:EFlipOptions"))
				{	soap_flag_EFlip--;
					continue;
				}
			}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptions(soap, "tt:Reverse", &a->Reverse, "tt:ReverseOptions"))
				{	soap_flag_Reverse--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTControlDirectionOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptions, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_new_tt__PTControlDirectionOptions(struct soap *soap, int n)
{
	struct tt__PTControlDirectionOptions *p;
	struct tt__PTControlDirectionOptions *a = (struct tt__PTControlDirectionOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionOptions(struct soap *soap, const struct tt__PTControlDirectionOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAbsolutePanTiltPositionSpace = 0;
	a->AbsolutePanTiltPositionSpace = NULL;
	a->__sizeAbsoluteZoomPositionSpace = 0;
	a->AbsoluteZoomPositionSpace = NULL;
	a->__sizeRelativePanTiltTranslationSpace = 0;
	a->RelativePanTiltTranslationSpace = NULL;
	a->__sizeRelativeZoomTranslationSpace = 0;
	a->RelativeZoomTranslationSpace = NULL;
	a->__sizeContinuousPanTiltVelocitySpace = 0;
	a->ContinuousPanTiltVelocitySpace = NULL;
	a->__sizeContinuousZoomVelocitySpace = 0;
	a->ContinuousZoomVelocitySpace = NULL;
	a->__sizePanTiltSpeedSpace = 0;
	a->PanTiltSpeedSpace = NULL;
	a->__sizeZoomSpeedSpace = 0;
	a->ZoomSpeedSpace = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsolutePanTiltPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsolutePanTiltPositionSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace + i);
		}
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsoluteZoomPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsoluteZoomPositionSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace + i);
		}
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativePanTiltTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativePanTiltTranslationSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace + i);
		}
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativeZoomTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativeZoomTranslationSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace + i);
		}
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousPanTiltVelocitySpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace + i);
		}
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousZoomVelocitySpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace + i);
		}
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
		{
			soap_embedded(soap, a->PanTiltSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->PanTiltSpeedSpace + i);
		}
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
		{
			soap_embedded(soap, a->ZoomSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ZoomSpeedSpace + i);
		}
	}
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const struct tt__PTZSpaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsolutePanTiltPositionSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, a->AbsolutePanTiltPositionSpace + i, ""))
				return soap->error;
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsoluteZoomPositionSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, a->AbsoluteZoomPositionSpace + i, ""))
				return soap->error;
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativePanTiltTranslationSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, a->RelativePanTiltTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativeZoomTranslationSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, a->RelativeZoomTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, a->ContinuousPanTiltVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, a->ContinuousZoomVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, a->PanTiltSpeedSpace + i, ""))
				return soap->error;
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, a->ZoomSpeedSpace + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces *a, const char *type)
{
	struct soap_blist *soap_blist_AbsolutePanTiltPositionSpace = NULL;
	struct soap_blist *soap_blist_AbsoluteZoomPositionSpace = NULL;
	struct soap_blist *soap_blist_RelativePanTiltTranslationSpace = NULL;
	struct soap_blist *soap_blist_RelativeZoomTranslationSpace = NULL;
	struct soap_blist *soap_blist_ContinuousPanTiltVelocitySpace = NULL;
	struct soap_blist *soap_blist_ContinuousZoomVelocitySpace = NULL;
	struct soap_blist *soap_blist_PanTiltSpeedSpace = NULL;
	struct soap_blist *soap_blist_ZoomSpeedSpace = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZSpaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpaces(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsolutePanTiltPositionSpace", 1, NULL))
			{	if (a->AbsolutePanTiltPositionSpace == NULL)
				{	if (soap_blist_AbsolutePanTiltPositionSpace == NULL)
						soap_blist_AbsolutePanTiltPositionSpace = soap_alloc_block(soap);
					a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_AbsolutePanTiltPositionSpace, sizeof(struct tt__Space2DDescription));
					if (a->AbsolutePanTiltPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", a->AbsolutePanTiltPositionSpace, "tt:Space2DDescription"))
				{	a->__sizeAbsolutePanTiltPositionSpace++;
					a->AbsolutePanTiltPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsoluteZoomPositionSpace", 1, NULL))
			{	if (a->AbsoluteZoomPositionSpace == NULL)
				{	if (soap_blist_AbsoluteZoomPositionSpace == NULL)
						soap_blist_AbsoluteZoomPositionSpace = soap_alloc_block(soap);
					a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_AbsoluteZoomPositionSpace, sizeof(struct tt__Space1DDescription));
					if (a->AbsoluteZoomPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", a->AbsoluteZoomPositionSpace, "tt:Space1DDescription"))
				{	a->__sizeAbsoluteZoomPositionSpace++;
					a->AbsoluteZoomPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativePanTiltTranslationSpace", 1, NULL))
			{	if (a->RelativePanTiltTranslationSpace == NULL)
				{	if (soap_blist_RelativePanTiltTranslationSpace == NULL)
						soap_blist_RelativePanTiltTranslationSpace = soap_alloc_block(soap);
					a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_RelativePanTiltTranslationSpace, sizeof(struct tt__Space2DDescription));
					if (a->RelativePanTiltTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", a->RelativePanTiltTranslationSpace, "tt:Space2DDescription"))
				{	a->__sizeRelativePanTiltTranslationSpace++;
					a->RelativePanTiltTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativeZoomTranslationSpace", 1, NULL))
			{	if (a->RelativeZoomTranslationSpace == NULL)
				{	if (soap_blist_RelativeZoomTranslationSpace == NULL)
						soap_blist_RelativeZoomTranslationSpace = soap_alloc_block(soap);
					a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_RelativeZoomTranslationSpace, sizeof(struct tt__Space1DDescription));
					if (a->RelativeZoomTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", a->RelativeZoomTranslationSpace, "tt:Space1DDescription"))
				{	a->__sizeRelativeZoomTranslationSpace++;
					a->RelativeZoomTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousPanTiltVelocitySpace", 1, NULL))
			{	if (a->ContinuousPanTiltVelocitySpace == NULL)
				{	if (soap_blist_ContinuousPanTiltVelocitySpace == NULL)
						soap_blist_ContinuousPanTiltVelocitySpace = soap_alloc_block(soap);
					a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_ContinuousPanTiltVelocitySpace, sizeof(struct tt__Space2DDescription));
					if (a->ContinuousPanTiltVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", a->ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
				{	a->__sizeContinuousPanTiltVelocitySpace++;
					a->ContinuousPanTiltVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousZoomVelocitySpace", 1, NULL))
			{	if (a->ContinuousZoomVelocitySpace == NULL)
				{	if (soap_blist_ContinuousZoomVelocitySpace == NULL)
						soap_blist_ContinuousZoomVelocitySpace = soap_alloc_block(soap);
					a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ContinuousZoomVelocitySpace, sizeof(struct tt__Space1DDescription));
					if (a->ContinuousZoomVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", a->ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
				{	a->__sizeContinuousZoomVelocitySpace++;
					a->ContinuousZoomVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PanTiltSpeedSpace", 1, NULL))
			{	if (a->PanTiltSpeedSpace == NULL)
				{	if (soap_blist_PanTiltSpeedSpace == NULL)
						soap_blist_PanTiltSpeedSpace = soap_alloc_block(soap);
					a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_PanTiltSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->PanTiltSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->PanTiltSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", a->PanTiltSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizePanTiltSpeedSpace++;
					a->PanTiltSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ZoomSpeedSpace", 1, NULL))
			{	if (a->ZoomSpeedSpace == NULL)
				{	if (soap_blist_ZoomSpeedSpace == NULL)
						soap_blist_ZoomSpeedSpace = soap_alloc_block(soap);
					a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ZoomSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->ZoomSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ZoomSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", a->ZoomSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizeZoomSpeedSpace++;
					a->ZoomSpeedSpace = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &a->Extension, "tt:PTZSpacesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AbsolutePanTiltPositionSpace)
			soap_pop_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		if (a->__sizeAbsolutePanTiltPositionSpace)
		{	a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_AbsolutePanTiltPositionSpace, NULL, 1);
		}
		else
		{	a->AbsolutePanTiltPositionSpace = NULL;
			if (soap_blist_AbsolutePanTiltPositionSpace)
				soap_end_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		}
		if (a->AbsoluteZoomPositionSpace)
			soap_pop_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		if (a->__sizeAbsoluteZoomPositionSpace)
		{	a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_AbsoluteZoomPositionSpace, NULL, 1);
		}
		else
		{	a->AbsoluteZoomPositionSpace = NULL;
			if (soap_blist_AbsoluteZoomPositionSpace)
				soap_end_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		}
		if (a->RelativePanTiltTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		if (a->__sizeRelativePanTiltTranslationSpace)
		{	a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_RelativePanTiltTranslationSpace, NULL, 1);
		}
		else
		{	a->RelativePanTiltTranslationSpace = NULL;
			if (soap_blist_RelativePanTiltTranslationSpace)
				soap_end_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		}
		if (a->RelativeZoomTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativeZoomTranslationSpace);
		if (a->__sizeRelativeZoomTranslationSpace)
		{	a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_RelativeZoomTranslationSpace, NULL, 1);
		}
		else
		{	a->RelativeZoomTranslationSpace = NULL;
			if (soap_blist_RelativeZoomTranslationSpace)
				soap_end_block(soap, soap_blist_RelativeZoomTranslationSpace);
		}
		if (a->ContinuousPanTiltVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		if (a->__sizeContinuousPanTiltVelocitySpace)
		{	a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousPanTiltVelocitySpace = NULL;
			if (soap_blist_ContinuousPanTiltVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		}
		if (a->ContinuousZoomVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		if (a->__sizeContinuousZoomVelocitySpace)
		{	a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ContinuousZoomVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousZoomVelocitySpace = NULL;
			if (soap_blist_ContinuousZoomVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		}
		if (a->PanTiltSpeedSpace)
			soap_pop_block(soap, soap_blist_PanTiltSpeedSpace);
		if (a->__sizePanTiltSpeedSpace)
		{	a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_PanTiltSpeedSpace, NULL, 1);
		}
		else
		{	a->PanTiltSpeedSpace = NULL;
			if (soap_blist_PanTiltSpeedSpace)
				soap_end_block(soap, soap_blist_PanTiltSpeedSpace);
		}
		if (a->ZoomSpeedSpace)
			soap_pop_block(soap, soap_blist_ZoomSpeedSpace);
		if (a->__sizeZoomSpeedSpace)
		{	a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ZoomSpeedSpace, NULL, 1);
		}
		else
		{	a->ZoomSpeedSpace = NULL;
			if (soap_blist_ZoomSpeedSpace)
				soap_end_block(soap, soap_blist_ZoomSpeedSpace);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_new_tt__PTZSpaces(struct soap *soap, int n)
{
	struct tt__PTZSpaces *p;
	struct tt__PTZSpaces *a = (struct tt__PTZSpaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpaces));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spaces = NULL;
	a->PTZTimeout = NULL;
	a->PTControlDirection = NULL;
	a->Extension = NULL;
	soap_default_tt__IntList(soap, &a->PTZRamps);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZSpaces(soap, &a->Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &a->PTZTimeout);
	soap_serialize_PointerTott__PTControlDirectionOptions(soap, &a->PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationOptions2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationOptions *a, const char *type)
{
	if (a->PTZRamps)
		soap_set_attr(soap, "PTZRamps", soap_tt__IntList2s(soap, a->PTZRamps), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (!a->Spaces)
	{	if (soap_element_empty(soap, "tt:Spaces", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->Spaces, ""))
		return soap->error;
	if (!a->PTZTimeout)
	{	if (soap_element_empty(soap, "tt:PTZTimeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->PTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", -1, &a->PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Spaces = 1;
	size_t soap_flag_PTZTimeout = 1;
	size_t soap_flag_PTControlDirection = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationOptions(soap, a);
	if (soap_s2tt__IntList(soap, soap_attr_value(soap, "PTZRamps", 1, 0), &a->PTZRamps))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &a->Spaces, "tt:PTZSpaces"))
				{	soap_flag_Spaces--;
					continue;
				}
			}
			if (soap_flag_PTZTimeout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &a->PTZTimeout, "tt:DurationRange"))
				{	soap_flag_PTZTimeout--;
					continue;
				}
			}
			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", &a->PTControlDirection, "tt:PTControlDirectionOptions"))
				{	soap_flag_PTControlDirection--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationOptions2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Spaces || !a->PTZTimeout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_new_tt__PTZConfigurationOptions(struct soap *soap, int n)
{
	struct tt__PTZConfigurationOptions *p;
	struct tt__PTZConfigurationOptions *a = (struct tt__PTZConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionExtension(struct soap *soap, const struct tt__PTControlDirectionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTControlDirectionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_new_tt__PTControlDirectionExtension(struct soap *soap, int n)
{
	struct tt__PTControlDirectionExtension *p;
	struct tt__PTControlDirectionExtension *a = (struct tt__PTControlDirectionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionExtension(struct soap *soap, const struct tt__PTControlDirectionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Reverse(struct soap *soap, struct tt__Reverse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReverseMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Reverse(struct soap *soap, const struct tt__Reverse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ReverseMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const struct tt__Reverse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, struct tt__Reverse *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Reverse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Reverse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->Mode, "tt:ReverseMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_new_tt__Reverse(struct soap *soap, int n)
{
	struct tt__Reverse *p;
	struct tt__Reverse *a = (struct tt__Reverse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Reverse));
	for (p = a; p && n--; p++)
		soap_default_tt__Reverse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Reverse(struct soap *soap, const struct tt__Reverse *a, const char *tag, const char *type)
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, struct tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlip(struct soap *soap, struct tt__EFlip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__EFlipMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlip(struct soap *soap, const struct tt__EFlip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__EFlipMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const struct tt__EFlip *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, struct tt__EFlip *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EFlip*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlip(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->Mode, "tt:EFlipMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_new_tt__EFlip(struct soap *soap, int n)
{
	struct tt__EFlip *p;
	struct tt__EFlip *a = (struct tt__EFlip*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlip));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlip(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlip(struct soap *soap, const struct tt__EFlip *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, struct tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension2(struct soap *soap, const struct tt__PTZConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_new_tt__PTZConfigurationExtension2(struct soap *soap, int n)
{
	struct tt__PTZConfigurationExtension2 *p;
	struct tt__PTZConfigurationExtension2 *a = (struct tt__PTZConfigurationExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension2(struct soap *soap, const struct tt__PTZConfigurationExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirection(struct soap *soap, const struct tt__PTControlDirection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &a->EFlip);
	soap_serialize_PointerTott__Reverse(soap, &a->Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, struct tt__PTControlDirection *a, const char *type)
{
	size_t soap_flag_EFlip = 1;
	size_t soap_flag_Reverse = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTControlDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirection(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->EFlip, "tt:EFlip"))
				{	soap_flag_EFlip--;
					continue;
				}
			}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->Reverse, "tt:Reverse"))
				{	soap_flag_Reverse--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_new_tt__PTControlDirection(struct soap *soap, int n)
{
	struct tt__PTControlDirection *p;
	struct tt__PTControlDirection *a = (struct tt__PTControlDirection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirection));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirection(struct soap *soap, const struct tt__PTControlDirection *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTControlDirection = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTControlDirection(soap, &a->PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension *a, const char *type)
{
	size_t soap_flag_PTControlDirection = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_new_tt__PTZConfigurationExtension(struct soap *soap, int n)
{
	struct tt__PTZConfigurationExtension *p;
	struct tt__PTZConfigurationExtension *a = (struct tt__PTZConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSupportedExtension(struct soap *soap, const struct tt__PTZPresetTourSupportedExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourSupportedExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSupportedExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupportedExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourSupportedExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSupportedExtension *p;
	struct tt__PTZPresetTourSupportedExtension *a = (struct tt__PTZPresetTourSupportedExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSupportedExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSupportedExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSupportedExtension(struct soap *soap, const struct tt__PTZPresetTourSupportedExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNodeExtension2(struct soap *soap, const struct tt__PTZNodeExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension2(struct soap *soap, const char *tag, int id, const struct tt__PTZNodeExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_in_tt__PTZNodeExtension2(struct soap *soap, const char *tag, struct tt__PTZNodeExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZNodeExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNodeExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension2, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_new_tt__PTZNodeExtension2(struct soap *soap, int n)
{
	struct tt__PTZNodeExtension2 *p;
	struct tt__PTZNodeExtension2 *a = (struct tt__PTZNodeExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNodeExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNodeExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNodeExtension2(struct soap *soap, const struct tt__PTZNodeExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_get_tt__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfPresetTours);
	a->__sizePTZPresetTourOperation = 0;
	a->PTZPresetTourOperation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSupported(struct soap *soap, const struct tt__PTZPresetTourSupported *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaximumNumberOfPresetTours, SOAP_TYPE_int);
	if (a->PTZPresetTourOperation)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZPresetTourOperation; i++)
		{
			soap_embedded(soap, a->PTZPresetTourOperation + i, SOAP_TYPE_tt__PTZPresetTourOperation);
		}
	}
	soap_serialize_PointerTott__PTZPresetTourSupportedExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSupported *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupported), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresetTours", -1, &a->MaximumNumberOfPresetTours, ""))
		return soap->error;
	if (a->PTZPresetTourOperation)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZPresetTourOperation; i++)
			if (soap_out_tt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", -1, a->PTZPresetTourOperation + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupported *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfPresetTours = 1;
	struct soap_blist *soap_blist_PTZPresetTourOperation = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPresetTourSupported*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSupported(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfPresetTours && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresetTours", &a->MaximumNumberOfPresetTours, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresetTours--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PTZPresetTourOperation", 1, NULL))
			{	if (a->PTZPresetTourOperation == NULL)
				{	if (soap_blist_PTZPresetTourOperation == NULL)
						soap_blist_PTZPresetTourOperation = soap_alloc_block(soap);
					a->PTZPresetTourOperation = (enum tt__PTZPresetTourOperation *)soap_push_block_max(soap, soap_blist_PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation));
					if (a->PTZPresetTourOperation == NULL)
						return NULL;
					soap_default_tt__PTZPresetTourOperation(soap, a->PTZPresetTourOperation);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", a->PTZPresetTourOperation, "tt:PTZPresetTourOperation"))
				{	a->__sizePTZPresetTourOperation++;
					a->PTZPresetTourOperation = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourSupportedExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZPresetTourOperation)
			soap_pop_block(soap, soap_blist_PTZPresetTourOperation);
		if (a->__sizePTZPresetTourOperation)
		{	a->PTZPresetTourOperation = (enum tt__PTZPresetTourOperation *)soap_save_block(soap, soap_blist_PTZPresetTourOperation, NULL, 1);
		}
		else
		{	a->PTZPresetTourOperation = NULL;
			if (soap_blist_PTZPresetTourOperation)
				soap_end_block(soap, soap_blist_PTZPresetTourOperation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfPresetTours > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupported *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupported, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_new_tt__PTZPresetTourSupported(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSupported *p;
	struct tt__PTZPresetTourSupported *a = (struct tt__PTZPresetTourSupported*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSupported));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSupported(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSupported(struct soap *soap, const struct tt__PTZPresetTourSupported *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportedPresetTour = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSupported(soap, &a->SupportedPresetTour);
	soap_serialize_PointerTott__PTZNodeExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZNodeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", -1, &a->SupportedPresetTour, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension *a, const char *type)
{
	size_t soap_flag_SupportedPresetTour = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZNodeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNodeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedPresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", &a->SupportedPresetTour, "tt:PTZPresetTourSupported"))
				{	soap_flag_SupportedPresetTour--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension2(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_new_tt__PTZNodeExtension(struct soap *soap, int n)
{
	struct tt__PTZNodeExtension *p;
	struct tt__PTZNodeExtension *a = (struct tt__PTZNodeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNodeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNodeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_in_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GenericEapPwdConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GenericEapPwdConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_new_tt__GenericEapPwdConfigurationExtension(struct soap *soap, int n)
{
	struct tt__GenericEapPwdConfigurationExtension *p;
	struct tt__GenericEapPwdConfigurationExtension *a = (struct tt__GenericEapPwdConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GenericEapPwdConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__GenericEapPwdConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__GenericEapPwdConfigurationExtension(soap, tag ? tag : "tt:GenericEapPwdConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_get_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GenericEapPwdConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const struct tt__EapMethodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EapMethodExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, struct tt__EapMethodExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EapMethodExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EapMethodExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_new_tt__EapMethodExtension(struct soap *soap, int n)
{
	struct tt__EapMethodExtension *p;
	struct tt__EapMethodExtension *a = (struct tt__EapMethodExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EapMethodExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EapMethodExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TLSConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tt:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, struct tt__TLSConfiguration *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TLSConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TLSConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_new_tt__TLSConfiguration(struct soap *soap, int n)
{
	struct tt__TLSConfiguration *p;
	struct tt__TLSConfiguration *a = (struct tt__TLSConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TLSConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__TLSConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Dot1XConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_new_tt__Dot1XConfigurationExtension(struct soap *soap, int n)
{
	struct tt__Dot1XConfigurationExtension *p;
	struct tt__Dot1XConfigurationExtension *a = (struct tt__Dot1XConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot1XConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot1XConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLSConfiguration = NULL;
	soap_default_string(soap, &a->Password);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TLSConfiguration(soap, &a->TLSConfiguration);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EAPMethodConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->TLSConfiguration, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, struct tt__EAPMethodConfiguration *a, const char *type)
{
	size_t soap_flag_TLSConfiguration = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EAPMethodConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EAPMethodConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_new_tt__EAPMethodConfiguration(struct soap *soap, int n)
{
	struct tt__EAPMethodConfiguration *p;
	struct tt__EAPMethodConfiguration *a = (struct tt__EAPMethodConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EAPMethodConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__EAPMethodConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, struct tt__CertificateInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_new_tt__CertificateInformationExtension(struct soap *soap, int n)
{
	struct tt__CertificateInformationExtension *p;
	struct tt__CertificateInformationExtension *a = (struct tt__CertificateInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->From);
	soap_default_dateTime(soap, &a->Until);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->Until, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const struct tt__DateTimeRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, struct tt__DateTimeRange *a, const char *type)
{
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DateTimeRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTimeRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From > 0 || soap_flag_Until > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_new_tt__DateTimeRange(struct soap *soap, int n)
{
	struct tt__DateTimeRange *p;
	struct tt__DateTimeRange *a = (struct tt__DateTimeRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DateTimeRange));
	for (p = a; p && n--; p++)
		soap_default_tt__DateTimeRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__boolean(soap, &a->Critical);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const struct tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_xsd__boolean2s(soap, a->Critical), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, struct tt__CertificateUsage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct tt__CertificateUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__CertificateUsage(soap, a);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "Critical", 5, 1), &a->Critical))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_new_tt__CertificateUsage(struct soap *soap, int n)
{
	struct tt__CertificateUsage *p;
	struct tt__CertificateUsage *a = (struct tt__CertificateUsage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateUsage));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateUsage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateGenerationParametersExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParametersExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_new_tt__CertificateGenerationParametersExtension(struct soap *soap, int n)
{
	struct tt__CertificateGenerationParametersExtension *p;
	struct tt__CertificateGenerationParametersExtension *a = (struct tt__CertificateGenerationParametersExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateGenerationParametersExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateGenerationParametersExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateGenerationParametersExtension(soap, tag ? tag : "tt:CertificateGenerationParametersExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	soap_default_xsd__token(soap, &a->ValidNotBefore);
	soap_default_xsd__token(soap, &a->ValidNotAfter);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->Subject);
	soap_serialize_xsd__token(soap, (char*const*)&a->ValidNotBefore);
	soap_serialize_xsd__token(soap, (char*const*)&a->ValidNotAfter);
	soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Subject", -1, (char*const*)&a->Subject, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotBefore", -1, (char*const*)&a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotAfter", -1, (char*const*)&a->ValidNotAfter, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_in_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, struct tt__CertificateGenerationParameters *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateGenerationParameters*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParameters(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Subject", (char**)&a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:ValidNotBefore", (char**)&a->ValidNotBefore, "xsd:token"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:ValidNotAfter", (char**)&a->ValidNotAfter, "xsd:token"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_new_tt__CertificateGenerationParameters(struct soap *soap, int n)
{
	struct tt__CertificateGenerationParameters *p;
	struct tt__CertificateGenerationParameters *a = (struct tt__CertificateGenerationParameters*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateGenerationParameters));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateGenerationParameters(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateGenerationParameters(soap, tag ? tag : "tt:CertificateGenerationParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_get_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserExtension(struct soap *soap, struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const struct tt__UserExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__UserExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__UserExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_new_tt__UserExtension(struct soap *soap, int n)
{
	struct tt__UserExtension *p;
	struct tt__UserExtension *a = (struct tt__UserExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__UserExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__UserExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, struct tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Date(struct soap *soap, struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Year);
	soap_default_int(soap, &a->Month);
	soap_default_int(soap, &a->Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Date(struct soap *soap, const struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Year, SOAP_TYPE_int);
	soap_embedded(soap, &a->Month, SOAP_TYPE_int);
	soap_embedded(soap, &a->Day, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const struct tt__Date *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->Day, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, struct tt__Date *a, const char *type)
{
	size_t soap_flag_Year = 1;
	size_t soap_flag_Month = 1;
	size_t soap_flag_Day = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Date*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Date(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Year", &a->Year, "xsd:int"))
				{	soap_flag_Year--;
					continue;
				}
			}
			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Month", &a->Month, "xsd:int"))
				{	soap_flag_Month--;
					continue;
				}
			}
			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Day", &a->Day, "xsd:int"))
				{	soap_flag_Day--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_new_tt__Date(struct soap *soap, int n)
{
	struct tt__Date *p;
	struct tt__Date *a = (struct tt__Date*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Date));
	for (p = a; p && n--; p++)
		soap_default_tt__Date(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Date(struct soap *soap, const struct tt__Date *a, const char *tag, const char *type)
{
	if (soap_out_tt__Date(soap, tag ? tag : "tt:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, struct tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Time(struct soap *soap, struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Hour);
	soap_default_int(soap, &a->Minute);
	soap_default_int(soap, &a->Second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Time(struct soap *soap, const struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Hour, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minute, SOAP_TYPE_int);
	soap_embedded(soap, &a->Second, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const struct tt__Time *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->Second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, struct tt__Time *a, const char *type)
{
	size_t soap_flag_Hour = 1;
	size_t soap_flag_Minute = 1;
	size_t soap_flag_Second = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Time*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Time(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Hour", &a->Hour, "xsd:int"))
				{	soap_flag_Hour--;
					continue;
				}
			}
			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minute", &a->Minute, "xsd:int"))
				{	soap_flag_Minute--;
					continue;
				}
			}
			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Second", &a->Second, "xsd:int"))
				{	soap_flag_Second--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_new_tt__Time(struct soap *soap, int n)
{
	struct tt__Time *p;
	struct tt__Time *a = (struct tt__Time*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Time));
	for (p = a; p && n--; p++)
		soap_default_tt__Time(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Time(struct soap *soap, const struct tt__Time *a, const char *tag, const char *type)
{
	if (soap_out_tt__Time(soap, tag ? tag : "tt:Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, struct tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTimeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemDateTimeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTimeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_new_tt__SystemDateTimeExtension(struct soap *soap, int n)
{
	struct tt__SystemDateTimeExtension *p;
	struct tt__SystemDateTimeExtension *a = (struct tt__SystemDateTimeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemDateTimeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemDateTimeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->Type);
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (!a->Uri)
	{	if (soap_element_empty(soap, "tt:Uri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, struct tt__SystemLogUri *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemLogUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->Type, "tt:SystemLogType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || !a->Uri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_new_tt__SystemLogUri(struct soap *soap, int n)
{
	struct tt__SystemLogUri *p;
	struct tt__SystemLogUri *a = (struct tt__SystemLogUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLogUri));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsDeviceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceExtension *p;
	struct tt__AnalyticsDeviceExtension *a = (struct tt__AnalyticsDeviceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__SystemCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__SystemCapabilitiesExtension2 *p;
	struct tt__SystemCapabilitiesExtension2 *a = (struct tt__SystemCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpFirmwareUpgrade);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSystemBackup);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSystemLogging);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpFirmwareUpgrade", -1, &a->HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSystemBackup", -1, &a->HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSystemLogging", -1, &a->HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSupportInformation", -1, &a->HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_HttpFirmwareUpgrade = 1;
	size_t soap_flag_HttpSystemBackup = 1;
	size_t soap_flag_HttpSystemLogging = 1;
	size_t soap_flag_HttpSupportInformation = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HttpFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:HttpFirmwareUpgrade", &a->HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade--;
					continue;
				}
			}
			if (soap_flag_HttpSystemBackup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSystemBackup", &a->HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup--;
					continue;
				}
			}
			if (soap_flag_HttpSystemLogging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSystemLogging", &a->HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging--;
					continue;
				}
			}
			if (soap_flag_HttpSupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSupportInformation", &a->HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__SystemCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__SystemCapabilitiesExtension *p;
	struct tt__SystemCapabilitiesExtension *a = (struct tt__SystemCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Dot1X);
	a->__sizeSupportedEAPMethod = 0;
	a->SupportedEAPMethod = NULL;
	soap_default_xsd__boolean(soap, &a->RemoteUserHandling);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Dot1X, SOAP_TYPE_xsd__boolean);
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedEAPMethod; i++)
		{
			soap_embedded(soap, a->SupportedEAPMethod + i, SOAP_TYPE_int);
		}
	}
	soap_embedded(soap, &a->RemoteUserHandling, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedEAPMethod; i++)
			if (soap_out_int(soap, "tt:SupportedEAPMethod", -1, a->SupportedEAPMethod + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "tt:RemoteUserHandling", -1, &a->RemoteUserHandling, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	size_t soap_flag_Dot1X = 1;
	struct soap_blist *soap_blist_SupportedEAPMethod = NULL;
	size_t soap_flag_RemoteUserHandling = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SecurityCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Dot1X", &a->Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedEAPMethod", 1, NULL))
			{	if (a->SupportedEAPMethod == NULL)
				{	if (soap_blist_SupportedEAPMethod == NULL)
						soap_blist_SupportedEAPMethod = soap_alloc_block(soap);
					a->SupportedEAPMethod = (int *)soap_push_block_max(soap, soap_blist_SupportedEAPMethod, sizeof(int));
					if (a->SupportedEAPMethod == NULL)
						return NULL;
					soap_default_int(soap, a->SupportedEAPMethod);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:SupportedEAPMethod", a->SupportedEAPMethod, "xsd:int"))
				{	a->__sizeSupportedEAPMethod++;
					a->SupportedEAPMethod = NULL;
					continue;
				}
			}
			if (soap_flag_RemoteUserHandling && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:RemoteUserHandling", &a->RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedEAPMethod)
			soap_pop_block(soap, soap_blist_SupportedEAPMethod);
		if (a->__sizeSupportedEAPMethod)
		{	a->SupportedEAPMethod = (int *)soap_save_block(soap, soap_blist_SupportedEAPMethod, NULL, 1);
		}
		else
		{	a->SupportedEAPMethod = NULL;
			if (soap_blist_SupportedEAPMethod)
				soap_end_block(soap, soap_blist_SupportedEAPMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X > 0 || soap_flag_RemoteUserHandling > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__SecurityCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__SecurityCapabilitiesExtension2 *p;
	struct tt__SecurityCapabilitiesExtension2 *a = (struct tt__SecurityCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SecurityCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__SecurityCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TLS1_x002e0);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TLS1_x002e0, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TLS1.0", -1, &a->TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_TLS1_x002e0 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SecurityCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:TLS1.0", &a->TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e0--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__SecurityCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__SecurityCapabilitiesExtension *p;
	struct tt__SecurityCapabilitiesExtension *a = (struct tt__SecurityCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SecurityCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SecurityCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__NetworkCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__NetworkCapabilitiesExtension2 *p;
	struct tt__NetworkCapabilitiesExtension2 *a = (struct tt__NetworkCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot11Configuration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Dot11Configuration", -1, &a->Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_Dot11Configuration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot11Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:Dot11Configuration", &a->Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
