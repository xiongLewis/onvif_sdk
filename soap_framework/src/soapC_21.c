/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description))
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause))
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description))
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationExtension))
		soap_serialize_tt__OSDConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfiguration))
		soap_serialize_tt__OSDImgConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDImgConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, struct tt__OSDImgConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDImgConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfiguration))
		soap_serialize_tt__OSDTextConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDTextConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, struct tt__OSDTextConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDTextConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfiguration))
		soap_serialize_tt__OSDPosConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDPosConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDPosConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, struct tt__OSDPosConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDPosConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDPosConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDPosConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDReference))
		soap_serialize_tt__OSDReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDReference(struct soap *soap, const char *tag, int id, struct tt__OSDReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDReference ** SOAP_FMAC4 soap_in_PointerTott__OSDReference(struct soap *soap, const char *tag, struct tt__OSDReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDReference **)soap_malloc(soap, sizeof(struct tt__OSDReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDReference ** SOAP_FMAC4 soap_get_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		soap_serialize_tt__MetadataInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, struct tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInput **)soap_malloc(soap, sizeof(struct tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		soap_serialize_tt__SourceIdentification(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, struct tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentification(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentification **)soap_malloc(soap, sizeof(struct tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		soap_serialize_tt__AnalyticsDeviceEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		soap_serialize_tt__PTZConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		soap_serialize_tt__ZoomLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, struct tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ZoomLimits **)soap_malloc(soap, sizeof(struct tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ZoomLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		soap_serialize_tt__PanTiltLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, struct tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PanTiltLimits **)soap_malloc(soap, sizeof(struct tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PanTiltLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		soap_serialize_tt__PTZNodeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__DigitalIdleState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, int id, enum tt__DigitalIdleState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalIdleState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalIdleState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_in_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, enum tt__DigitalIdleState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__DigitalIdleState **)soap_malloc(soap, sizeof(enum tt__DigitalIdleState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalIdleState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__DigitalIdleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_get_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		soap_serialize_tt__NetworkInterfaceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		soap_serialize_tt__IPv6NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		soap_serialize_tt__IPv4NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		soap_serialize_tt__NetworkInterfaceLink(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		soap_serialize_tt__NetworkInterfaceInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		soap_serialize_tt__VideoOutputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, struct tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, struct tt__VideoOutputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputExtension **)soap_malloc(soap, sizeof(struct tt__VideoOutputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutputExtension(soap, tag ? tag : "tt:VideoOutputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Layout))
		soap_serialize_tt__Layout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Layout(struct soap *soap, const char *tag, int id, struct tt__Layout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Layout, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Layout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_in_PointerTott__Layout(struct soap *soap, const char *tag, struct tt__Layout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Layout **)soap_malloc(soap, sizeof(struct tt__Layout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Layout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Layout(soap, tag ? tag : "tt:Layout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_get_PointerTott__Layout(struct soap *soap, struct tt__Layout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		soap_serialize_tt__MetadataConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		soap_serialize_tt__EventSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, struct tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, struct tt__EventSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventSubscription **)soap_malloc(soap, sizeof(struct tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		soap_serialize_tt__PTZFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, struct tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZFilter **)soap_malloc(soap, sizeof(struct tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		soap_serialize_tt__RuleEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		soap_serialize_tt__AnalyticsEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl2))
		soap_serialize_tt__VideoRateControl2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl2 ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, struct tt__VideoRateControl2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl2 **)soap_malloc(soap, sizeof(struct tt__VideoRateControl2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl2(soap, tag ? tag : "tt:VideoRateControl2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl2 ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		soap_serialize_tt__MulticastConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MulticastConfiguration **)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MulticastConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		soap_serialize_tt__H264Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, struct tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Configuration **)soap_malloc(soap, sizeof(struct tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		soap_serialize_tt__Mpeg4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		soap_serialize_tt__VideoRateControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl **)soap_malloc(soap, sizeof(struct tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		soap_serialize_tt__VideoSourceConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		soap_serialize_tt__IntRectangle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, struct tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangle **)soap_malloc(soap, sizeof(struct tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		soap_serialize_tt__VideoSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, struct tt__VideoSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		soap_serialize_tt__ImagingSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, struct tt__ImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings **)soap_malloc(soap, sizeof(struct tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptions))
		soap_serialize_tt__OSDConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfiguration))
		soap_serialize_tt__OSDConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, struct tt__OSDConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceMode))
		soap_serialize_trt__VideoSourceMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, int id, struct trt__VideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__VideoSourceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__VideoSourceMode ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, struct trt__VideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__VideoSourceMode **)soap_malloc(soap, sizeof(struct trt__VideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__VideoSourceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__VideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceMode(soap, tag ? tag : "trt:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceMode ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		soap_serialize_tt__MediaUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, struct tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaUri **)soap_malloc(soap, sizeof(struct tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		soap_serialize_tt__AudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptions))
		soap_serialize_tt__MetadataConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		soap_serialize_tt__AudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
		soap_serialize_tt__VideoEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		soap_serialize_tt__VideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		soap_serialize_tt__Profile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, struct tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, struct tt__Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Profile **)soap_malloc(soap, sizeof(struct tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, struct tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutput))
		soap_serialize_tt__AudioOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutput(struct soap *soap, const char *tag, int id, struct tt__AudioOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_in_PointerTott__AudioOutput(struct soap *soap, const char *tag, struct tt__AudioOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutput **)soap_malloc(soap, sizeof(struct tt__AudioOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_get_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSource))
		soap_serialize_tt__AudioSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSource(struct soap *soap, const char *tag, int id, struct tt__AudioSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_in_PointerTott__AudioSource(struct soap *soap, const char *tag, struct tt__AudioSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSource **)soap_malloc(soap, sizeof(struct tt__AudioSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_get_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSource))
		soap_serialize_tt__VideoSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSource(struct soap *soap, const char *tag, int id, struct tt__VideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_in_PointerTott__VideoSource(struct soap *soap, const char *tag, struct tt__VideoSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSource **)soap_malloc(soap, sizeof(struct tt__VideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_get_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		soap_serialize_trt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, struct trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__Capabilities **)soap_malloc(soap, sizeof(struct trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceModeExtension))
		soap_serialize_trt__VideoSourceModeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, int id, struct trt__VideoSourceModeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceModeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__VideoSourceModeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, struct trt__VideoSourceModeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__VideoSourceModeExtension **)soap_malloc(soap, sizeof(struct trt__VideoSourceModeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__VideoSourceModeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__VideoSourceModeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceModeExtension(soap, tag ? tag : "trt:VideoSourceModeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceModeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__StreamingCapabilities))
		soap_serialize_trt__StreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, int id, struct trt__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__StreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__StreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, struct trt__StreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__StreamingCapabilities **)soap_malloc(soap, sizeof(struct trt__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__StreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__StreamingCapabilities(soap, tag ? tag : "trt:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		soap_serialize_trt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		soap_serialize_wstop__Documentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, struct wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__Documentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__Documentation **)soap_malloc(soap, sizeof(struct wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__Documentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		soap_serialize_wsnt__SubscriptionPolicyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		soap_serialize_wstop__TopicSetType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, struct wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicSetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicSetType **)soap_malloc(soap, sizeof(struct wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicSetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		soap_serialize_wsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		soap_serialize_tt__MessageExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, struct tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageExtension **)soap_malloc(soap, sizeof(struct tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalOrientation))
		soap_serialize_tt__LocalOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalOrientation(struct soap *soap, const char *tag, int id, struct tt__LocalOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocalOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocalOrientation ** SOAP_FMAC4 soap_in_PointerTott__LocalOrientation(struct soap *soap, const char *tag, struct tt__LocalOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocalOrientation **)soap_malloc(soap, sizeof(struct tt__LocalOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocalOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalOrientation ** SOAP_FMAC4 soap_get_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalLocation))
		soap_serialize_tt__LocalLocation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalLocation(struct soap *soap, const char *tag, int id, struct tt__LocalLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalLocation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocalLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocalLocation ** SOAP_FMAC4 soap_in_PointerTott__LocalLocation(struct soap *soap, const char *tag, struct tt__LocalLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocalLocation **)soap_malloc(soap, sizeof(struct tt__LocalLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocalLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalLocation ** SOAP_FMAC4 soap_get_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoOrientation))
		soap_serialize_tt__GeoOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoOrientation(struct soap *soap, const char *tag, int id, struct tt__GeoOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GeoOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GeoOrientation ** SOAP_FMAC4 soap_in_PointerTott__GeoOrientation(struct soap *soap, const char *tag, struct tt__GeoOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GeoOrientation **)soap_malloc(soap, sizeof(struct tt__GeoOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GeoOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoOrientation ** SOAP_FMAC4 soap_get_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		soap_serialize_tt__GeoLocation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, struct tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GeoLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, struct tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GeoLocation **)soap_malloc(soap, sizeof(struct tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GeoLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		soap_serialize_tt__TransformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, struct tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TransformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TransformationExtension **)soap_malloc(soap, sizeof(struct tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TransformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster))
		soap_serialize__tt__ColorDescriptor_ColorCluster(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ColorDescriptor_ColorCluster(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(struct _tt__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag ? tag : "tt:ColorDescriptor-ColorCluster", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorCovariance))
		soap_serialize_tt__ColorCovariance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorCovariance(struct soap *soap, const char *tag, int id, struct tt__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorCovariance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorCovariance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTott__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorCovariance **)soap_malloc(soap, sizeof(struct tt__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorCovariance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		soap_serialize_tt__PTZMoveStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, struct tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZMoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZMoveStatus **)soap_malloc(soap, sizeof(struct tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZMoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StorageReferencePathExtension))
		soap_serialize_tt__StorageReferencePathExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, int id, struct tt__StorageReferencePathExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StorageReferencePathExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StorageReferencePathExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_in_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, struct tt__StorageReferencePathExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StorageReferencePathExtension **)soap_malloc(soap, sizeof(struct tt__StorageReferencePathExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StorageReferencePathExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePathExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, tag ? tag : "tt:StorageReferencePathExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_get_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StorageReferencePathExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ArrayOfFileProgressExtension))
		soap_serialize_tt__ArrayOfFileProgressExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, struct tt__ArrayOfFileProgressExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ArrayOfFileProgressExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ArrayOfFileProgressExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_in_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgressExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ArrayOfFileProgressExtension **)soap_malloc(soap, sizeof(struct tt__ArrayOfFileProgressExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ArrayOfFileProgressExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgressExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_get_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FileProgress))
		soap_serialize_tt__FileProgress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FileProgress(struct soap *soap, const char *tag, int id, struct tt__FileProgress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FileProgress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FileProgress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FileProgress ** SOAP_FMAC4 soap_in_PointerTott__FileProgress(struct soap *soap, const char *tag, struct tt__FileProgress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FileProgress **)soap_malloc(soap, sizeof(struct tt__FileProgress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FileProgress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FileProgress ** SOAP_FMAC4 soap_get_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension))
		soap_serialize_tt__OSDConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptions))
		soap_serialize_tt__OSDImgOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, int id, struct tt__OSDImgOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, struct tt__OSDImgOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgOptions **)soap_malloc(soap, sizeof(struct tt__OSDImgOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptions))
		soap_serialize_tt__OSDTextOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, int id, struct tt__OSDTextOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, struct tt__OSDTextOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextOptions **)soap_malloc(soap, sizeof(struct tt__OSDTextOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDType(struct soap *soap, enum tt__OSDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__OSDType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDType(struct soap *soap, const char *tag, int id, enum tt__OSDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__OSDType ** SOAP_FMAC4 soap_in_PointerTott__OSDType(struct soap *soap, const char *tag, enum tt__OSDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__OSDType **)soap_malloc(soap, sizeof(enum tt__OSDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__OSDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDType(struct soap *soap, enum tt__OSDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDType(soap, tag ? tag : "tt:OSDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__OSDType ** SOAP_FMAC4 soap_get_PointerTott__OSDType(struct soap *soap, enum tt__OSDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MaximumNumberOfOSDs))
		soap_serialize_tt__MaximumNumberOfOSDs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, struct tt__MaximumNumberOfOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MaximumNumberOfOSDs, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MaximumNumberOfOSDs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_in_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, struct tt__MaximumNumberOfOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MaximumNumberOfOSDs **)soap_malloc(soap, sizeof(struct tt__MaximumNumberOfOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MaximumNumberOfOSDs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MaximumNumberOfOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_get_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptionsExtension))
		soap_serialize_tt__OSDImgOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDImgOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDImgOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDImgOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptionsExtension))
		soap_serialize_tt__OSDTextOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDTextOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDTextOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDTextOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptions))
		soap_serialize_tt__OSDColorOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, int id, struct tt__OSDColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColorOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColorOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, struct tt__OSDColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColorOptions **)soap_malloc(soap, sizeof(struct tt__OSDColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColorOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptionsExtension))
		soap_serialize_tt__OSDColorOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDColorOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColorOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDColorOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColorOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDColorOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColorOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorOptions))
		soap_serialize_tt__ColorOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorOptions(struct soap *soap, const char *tag, int id, struct tt__ColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorOptions ** SOAP_FMAC4 soap_in_PointerTott__ColorOptions(struct soap *soap, const char *tag, struct tt__ColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorOptions **)soap_malloc(soap, sizeof(struct tt__ColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorOptions ** SOAP_FMAC4 soap_get_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorspaceRange))
		soap_serialize_tt__ColorspaceRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, struct tt__ColorspaceRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorspaceRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorspaceRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorspaceRange ** SOAP_FMAC4 soap_in_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, struct tt__ColorspaceRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorspaceRange **)soap_malloc(soap, sizeof(struct tt__ColorspaceRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorspaceRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorspaceRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorspaceRange ** SOAP_FMAC4 soap_get_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfigurationExtension))
		soap_serialize_tt__OSDImgConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDImgConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDImgConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDImgConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfigurationExtension))
		soap_serialize_tt__OSDTextConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDTextConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDTextConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDTextConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColor))
		soap_serialize_tt__OSDColor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColor(struct soap *soap, const char *tag, int id, struct tt__OSDColor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColor ** SOAP_FMAC4 soap_in_PointerTott__OSDColor(struct soap *soap, const char *tag, struct tt__OSDColor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColor **)soap_malloc(soap, sizeof(struct tt__OSDColor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColor ** SOAP_FMAC4 soap_get_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, struct tt__Color *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		soap_serialize_tt__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, struct tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, struct tt__Color **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Color **)soap_malloc(soap, sizeof(struct tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Color(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, struct tt__Color *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, struct tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfigurationExtension))
		soap_serialize_tt__OSDPosConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDPosConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDPosConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDPosConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDPosConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDPosConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDPosConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileStatusExtension))
		soap_serialize_tt__ProfileStatusExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileStatusExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileStatusExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, struct tt__ProfileStatusExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileStatusExtension **)soap_malloc(soap, sizeof(struct tt__ProfileStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileStatusExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActiveConnection))
		soap_serialize_tt__ActiveConnection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActiveConnection(struct soap *soap, const char *tag, int id, struct tt__ActiveConnection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActiveConnection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ActiveConnection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ActiveConnection ** SOAP_FMAC4 soap_in_PointerTott__ActiveConnection(struct soap *soap, const char *tag, struct tt__ActiveConnection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ActiveConnection **)soap_malloc(soap, sizeof(struct tt__ActiveConnection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ActiveConnection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ActiveConnection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActiveConnection ** SOAP_FMAC4 soap_get_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassDescriptorExtension))
		soap_serialize_tt__AudioClassDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__AudioClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__AudioClassDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioClassDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__AudioClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassCandidate))
		soap_serialize_tt__AudioClassCandidate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, int id, struct tt__AudioClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassCandidate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioClassCandidate ** SOAP_FMAC4 soap_in_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, struct tt__AudioClassCandidate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioClassCandidate **)soap_malloc(soap, sizeof(struct tt__AudioClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassCandidate ** SOAP_FMAC4 soap_get_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension))
		soap_serialize_tt__ActionEngineEventPayloadExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, struct tt__ActionEngineEventPayloadExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ActionEngineEventPayloadExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_in_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ActionEngineEventPayloadExtension **)soap_malloc(soap, sizeof(struct tt__ActionEngineEventPayloadExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_get_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_serialize_SOAP_ENV__Fault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Fault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Fault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Fault **)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Fault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Envelope))
		soap_serialize_SOAP_ENV__Envelope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Envelope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Envelope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Envelope **)soap_malloc(soap, sizeof(struct SOAP_ENV__Envelope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Envelope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsState))
		soap_serialize_tt__AnalyticsState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsState(struct soap *soap, const char *tag, int id, struct tt__AnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsState **)soap_malloc(soap, sizeof(struct tt__AnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInputExtension))
		soap_serialize_tt__MetadataInputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataInputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInputExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInputExtension **)soap_malloc(soap, sizeof(struct tt__MetadataInputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentificationExtension))
		soap_serialize_tt__SourceIdentificationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, struct tt__SourceIdentificationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentificationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentificationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentificationExtension **)soap_malloc(soap, sizeof(struct tt__SourceIdentificationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentificationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension))
		soap_serialize_tt__AnalyticsEngineInputInfoExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfoExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfo))
		soap_serialize_tt__AnalyticsEngineInputInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfo **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EngineConfiguration))
		soap_serialize_tt__EngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__EngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EngineConfiguration **)soap_malloc(soap, sizeof(struct tt__EngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfiguration))
		soap_serialize_tt__RecordingJobConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTrack))
		soap_serialize_tt__RecordingJobStateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTracks))
		soap_serialize_tt__RecordingJobStateTracks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTracks, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTracks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTracks **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTracks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformationExtension))
		soap_serialize_tt__RecordingJobStateInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateInformationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateSource))
		soap_serialize_tt__RecordingJobStateSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSourceExtension))
		soap_serialize_tt__RecordingJobSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSourceExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobTrack))
		soap_serialize_tt__RecordingJobTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfigurationExtension))
		soap_serialize_tt__RecordingJobConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSource))
		soap_serialize_tt__RecordingJobSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackConfiguration))
		soap_serialize_tt__TrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, int id, struct tt__TrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackConfiguration **)soap_malloc(soap, sizeof(struct tt__TrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseItem))
		soap_serialize_tt__GetTracksResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseItem **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseList))
		soap_serialize_tt__GetTracksResponseList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseList **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingConfiguration))
		soap_serialize_tt__RecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributesExtension))
		soap_serialize_tt__TrackAttributesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, int id, struct tt__TrackAttributesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributesExtension **)soap_malloc(soap, sizeof(struct tt__TrackAttributesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataAttributes))
		soap_serialize_tt__MetadataAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, int id, struct tt__MetadataAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_in_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataAttributes **)soap_malloc(soap, sizeof(struct tt__MetadataAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_get_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAttributes))
		soap_serialize_tt__AudioAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAttributes(struct soap *soap, const char *tag, int id, struct tt__AudioAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_in_PointerTott__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioAttributes **)soap_malloc(soap, sizeof(struct tt__AudioAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_get_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAttributes))
		soap_serialize_tt__VideoAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAttributes(struct soap *soap, const char *tag, int id, struct tt__VideoAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_in_PointerTott__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAttributes **)soap_malloc(soap, sizeof(struct tt__VideoAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_get_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributes))
		soap_serialize_tt__TrackAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, struct tt__TrackAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributes **)soap_malloc(soap, sizeof(struct tt__TrackAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackInformation))
		soap_serialize_tt__TrackInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackInformation(struct soap *soap, const char *tag, int id, struct tt__TrackInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_in_PointerTott__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackInformation **)soap_malloc(soap, sizeof(struct tt__TrackInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_get_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSourceInformation))
		soap_serialize_tt__RecordingSourceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingSourceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSourceInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingSourceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingSourceInformation **)soap_malloc(soap, sizeof(struct tt__RecordingSourceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingSourceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResult))
		soap_serialize_tt__FindMetadataResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, struct tt__FindMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindMetadataResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindMetadataResult **)soap_malloc(soap, sizeof(struct tt__FindMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindMetadataResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResult))
		soap_serialize_tt__FindPTZPositionResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, struct tt__FindPTZPositionResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindPTZPositionResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindPTZPositionResult **)soap_malloc(soap, sizeof(struct tt__FindPTZPositionResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindPTZPositionResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		soap_serialize_wsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResult))
		soap_serialize_tt__FindEventResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResult(struct soap *soap, const char *tag, int id, struct tt__FindEventResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindEventResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_in_PointerTott__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindEventResult **)soap_malloc(soap, sizeof(struct tt__FindEventResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindEventResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_get_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingInformation))
		soap_serialize_tt__RecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingInformation **)soap_malloc(soap, sizeof(struct tt__RecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScopeExtension))
		soap_serialize_tt__SearchScopeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, int id, struct tt__SearchScopeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScopeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchScopeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_in_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchScopeExtension **)soap_malloc(soap, sizeof(struct tt__SearchScopeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchScopeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_get_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingReference(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingReference))
		soap_serialize_tt__RecordingReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingReference(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__RecordingReference(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingReference, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
