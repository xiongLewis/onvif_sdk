/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_new_tt__OSDTextOptions(struct soap *soap, int n)
{
	struct tt__OSDTextOptions *p;
	struct tt__OSDTextOptions *a = (struct tt__OSDTextOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextOptions(struct soap *soap, const struct tt__OSDTextOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_get_tt__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDColorOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColorOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptionsExtension, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDColorOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDColorOptionsExtension *p;
	struct tt__OSDColorOptionsExtension *a = (struct tt__OSDColorOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorOptions(soap, &a->Color);
	soap_serialize_PointerTott__IntRange(soap, &a->Transparent);
	soap_serialize_PointerTott__OSDColorOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptions), type))
		return soap->error;
	if (soap_out_PointerTott__ColorOptions(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:Transparent", -1, &a->Transparent, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_in_tt__OSDColorOptions(struct soap *soap, const char *tag, struct tt__OSDColorOptions *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Transparent = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorOptions(soap, "tt:Color", &a->Color, "tt:ColorOptions"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Transparent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:Transparent", &a->Transparent, "tt:IntRange"))
				{	soap_flag_Transparent--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDColorOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_new_tt__OSDColorOptions(struct soap *soap, int n)
{
	struct tt__OSDColorOptions *p;
	struct tt__OSDColorOptions *a = (struct tt__OSDColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_get_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorList = 0;
	a->ColorList = NULL;
	a->__sizeColorspaceRange = 0;
	a->ColorspaceRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
		{
			soap_embedded(soap, a->ColorList + i, SOAP_TYPE_tt__Color);
			soap_serialize_tt__Color(soap, a->ColorList + i);
		}
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
		{
			soap_embedded(soap, a->ColorspaceRange + i, SOAP_TYPE_tt__ColorspaceRange);
			soap_serialize_tt__ColorspaceRange(soap, a->ColorspaceRange + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorOptions(struct soap *soap, const char *tag, int id, const struct tt__ColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorOptions), type))
		return soap->error;
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
			if (soap_out_tt__Color(soap, "tt:ColorList", -1, a->ColorList + i, ""))
				return soap->error;
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
			if (soap_out_tt__ColorspaceRange(soap, "tt:ColorspaceRange", -1, a->ColorspaceRange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_in_tt__ColorOptions(struct soap *soap, const char *tag, struct tt__ColorOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ColorList = NULL;
	struct soap_blist *soap_blist_ColorspaceRange = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorList", 1, NULL))
			{	if (a->ColorList == NULL)
				{	if (soap_blist_ColorList == NULL)
						soap_blist_ColorList = soap_alloc_block(soap);
					a->ColorList = (struct tt__Color *)soap_push_block_max(soap, soap_blist_ColorList, sizeof(struct tt__Color));
					if (a->ColorList == NULL)
						return NULL;
					soap_default_tt__Color(soap, a->ColorList);
				}
				soap_revert(soap);
				if (soap_in_tt__Color(soap, "tt:ColorList", a->ColorList, "tt:Color"))
				{	a->__sizeColorList++;
					a->ColorList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorspaceRange", 1, NULL))
			{	if (a->ColorspaceRange == NULL)
				{	if (soap_blist_ColorspaceRange == NULL)
						soap_blist_ColorspaceRange = soap_alloc_block(soap);
					a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_push_block_max(soap, soap_blist_ColorspaceRange, sizeof(struct tt__ColorspaceRange));
					if (a->ColorspaceRange == NULL)
						return NULL;
					soap_default_tt__ColorspaceRange(soap, a->ColorspaceRange);
				}
				soap_revert(soap);
				if (soap_in_tt__ColorspaceRange(soap, "tt:ColorspaceRange", a->ColorspaceRange, "tt:ColorspaceRange"))
				{	a->__sizeColorspaceRange++;
					a->ColorspaceRange = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorList)
			soap_pop_block(soap, soap_blist_ColorList);
		if (a->__sizeColorList)
		{	a->ColorList = (struct tt__Color *)soap_save_block(soap, soap_blist_ColorList, NULL, 1);
		}
		else
		{	a->ColorList = NULL;
			if (soap_blist_ColorList)
				soap_end_block(soap, soap_blist_ColorList);
		}
		if (a->ColorspaceRange)
			soap_pop_block(soap, soap_blist_ColorspaceRange);
		if (a->__sizeColorspaceRange)
		{	a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_save_block(soap, soap_blist_ColorspaceRange, NULL, 1);
		}
		else
		{	a->ColorspaceRange = NULL;
			if (soap_blist_ColorspaceRange)
				soap_end_block(soap, soap_blist_ColorspaceRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_new_tt__ColorOptions(struct soap *soap, int n)
{
	struct tt__ColorOptions *p;
	struct tt__ColorOptions *a = (struct tt__ColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_get_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X = NULL;
	a->Y = NULL;
	a->Z = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->X);
	soap_serialize_PointerTott__FloatRange(soap, &a->Y);
	soap_serialize_PointerTott__FloatRange(soap, &a->Z);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Colorspace);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorspaceRange(struct soap *soap, const char *tag, int id, const struct tt__ColorspaceRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorspaceRange), type))
		return soap->error;
	if (!a->X)
	{	if (soap_element_empty(soap, "tt:X", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:X", -1, &a->X, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_empty(soap, "tt:Y", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Y", -1, &a->Y, ""))
		return soap->error;
	if (!a->Z)
	{	if (soap_element_empty(soap, "tt:Z", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Z", -1, &a->Z, ""))
		return soap->error;
	if (!a->Colorspace)
	{	if (soap_element_empty(soap, "tt:Colorspace", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:Colorspace", -1, (char*const*)&a->Colorspace, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_in_tt__ColorspaceRange(struct soap *soap, const char *tag, struct tt__ColorspaceRange *a, const char *type)
{
	size_t soap_flag_X = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_Z = 1;
	size_t soap_flag_Colorspace = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorspaceRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorspaceRange(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:X", &a->X, "tt:FloatRange"))
				{	soap_flag_X--;
					continue;
				}
			}
			if (soap_flag_Y && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Y", &a->Y, "tt:FloatRange"))
				{	soap_flag_Y--;
					continue;
				}
			}
			if (soap_flag_Z && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Z", &a->Z, "tt:FloatRange"))
				{	soap_flag_Z--;
					continue;
				}
			}
			if (soap_flag_Colorspace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Colorspace", (char**)&a->Colorspace, "xsd:anyURI"))
				{	soap_flag_Colorspace--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->X || !a->Y || !a->Z || !a->Colorspace))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_new_tt__ColorspaceRange(struct soap *soap, int n)
{
	struct tt__ColorspaceRange *p;
	struct tt__ColorspaceRange *a = (struct tt__ColorspaceRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorspaceRange));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorspaceRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_get_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfigurationExtension, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDImgConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDImgConfigurationExtension *p;
	struct tt__OSDImgConfigurationExtension *a = (struct tt__OSDImgConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->ImgPath);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ImgPath);
	soap_serialize_PointerTott__OSDImgConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfiguration), type))
		return soap->error;
	if (!a->ImgPath)
	{	if (soap_element_empty(soap, "tt:ImgPath", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:ImgPath", -1, (char*const*)&a->ImgPath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_in_tt__OSDImgConfiguration(struct soap *soap, const char *tag, struct tt__OSDImgConfiguration *a, const char *type)
{
	size_t soap_flag_ImgPath = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImgPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ImgPath", (char**)&a->ImgPath, "xsd:anyURI"))
				{	soap_flag_ImgPath--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDImgConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImgPath))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_new_tt__OSDImgConfiguration(struct soap *soap, int n)
{
	struct tt__OSDImgConfiguration *p;
	struct tt__OSDImgConfiguration *a = (struct tt__OSDImgConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_get_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfigurationExtension, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDTextConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDTextConfigurationExtension *p;
	struct tt__OSDTextConfigurationExtension *a = (struct tt__OSDTextConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->DateFormat);
	soap_default_string(soap, &a->TimeFormat);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->BackgroundColor = NULL;
	soap_default_string(soap, &a->PlainText);
	a->Extension = NULL;
	a->IsPersistentText = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_string(soap, (char*const*)&a->DateFormat);
	soap_serialize_string(soap, (char*const*)&a->TimeFormat);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerTott__OSDColor(soap, &a->FontColor);
	soap_serialize_PointerTott__OSDColor(soap, &a->BackgroundColor);
	soap_serialize_string(soap, (char*const*)&a->PlainText);
	soap_serialize_PointerTott__OSDTextConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfiguration *a, const char *type)
{
	if (a->IsPersistentText)
	{	soap_set_attr(soap, "IsPersistentText", soap_xsd__boolean2s(soap, *a->IsPersistentText), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DateFormat", -1, (char*const*)&a->DateFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:TimeFormat", -1, (char*const*)&a->TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:BackgroundColor", -1, &a->BackgroundColor, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:PlainText", -1, (char*const*)&a->PlainText, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_in_tt__OSDTextConfiguration(struct soap *soap, const char *tag, struct tt__OSDTextConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_DateFormat = 1;
	size_t soap_flag_TimeFormat = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_BackgroundColor = 1;
	size_t soap_flag_PlainText = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfiguration(soap, a);
	{
		const char *t = soap_attr_value(soap, "IsPersistentText", 5, 0);
		if (t)
		{
			if (!(a->IsPersistentText = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsPersistentText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_DateFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:DateFormat", (char**)&a->DateFormat, "xsd:string"))
				{	soap_flag_DateFormat--;
					continue;
				}
			}
			if (soap_flag_TimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:TimeFormat", (char**)&a->TimeFormat, "xsd:string"))
				{	soap_flag_TimeFormat--;
					continue;
				}
			}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:FontColor", &a->FontColor, "tt:OSDColor"))
				{	soap_flag_FontColor--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:BackgroundColor", &a->BackgroundColor, "tt:OSDColor"))
				{	soap_flag_BackgroundColor--;
					continue;
				}
			}
			if (soap_flag_PlainText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:PlainText", (char**)&a->PlainText, "xsd:string"))
				{	soap_flag_PlainText--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDTextConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_new_tt__OSDTextConfiguration(struct soap *soap, int n)
{
	struct tt__OSDTextConfiguration *p;
	struct tt__OSDTextConfiguration *a = (struct tt__OSDTextConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_get_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Color(struct soap *soap, struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->X);
	soap_default_float(soap, &a->Y);
	soap_default_float(soap, &a->Z);
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Color(struct soap *soap, const struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const struct tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, a->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, a->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, a->Z), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, a->Colorspace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, struct tt__Color *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Color*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Color(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 5, 1), &a->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 5, 1), &a->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 5, 1), &a->Z))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Colorspace", 4, 0), &a->Colorspace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_new_tt__Color(struct soap *soap, int n)
{
	struct tt__Color *p;
	struct tt__Color *a = (struct tt__Color*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Color));
	for (p = a; p && n--; p++)
		soap_default_tt__Color(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Color(struct soap *soap, const struct tt__Color *a, const char *tag, const char *type)
{
	if (soap_out_tt__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, struct tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColor(struct soap *soap, struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &a->Color);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColor(struct soap *soap, const char *tag, int id, const struct tt__OSDColor *a, const char *type)
{
	if (a->Transparent)
	{	soap_set_attr(soap, "Transparent", soap_int2s(soap, *a->Transparent), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColor), type))
		return soap->error;
	if (!a->Color)
	{	if (soap_element_empty(soap, "tt:Color", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_in_tt__OSDColor(struct soap *soap, const char *tag, struct tt__OSDColor *a, const char *type)
{
	size_t soap_flag_Color = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColor(soap, a);
	{
		const char *t = soap_attr_value(soap, "Transparent", 5, 0);
		if (t)
		{
			if (!(a->Transparent = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Transparent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Color))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_new_tt__OSDColor(struct soap *soap, int n)
{
	struct tt__OSDColor *p;
	struct tt__OSDColor *a = (struct tt__OSDColor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColor));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_get_tt__OSDColor(struct soap *soap, struct tt__OSDColor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDPosConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfigurationExtension, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDPosConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDPosConfigurationExtension *p;
	struct tt__OSDPosConfigurationExtension *a = (struct tt__OSDPosConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	a->Pos = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_PointerTott__Vector(soap, &a->Pos);
	soap_serialize_PointerTott__OSDPosConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Pos", -1, &a->Pos, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_in_tt__OSDPosConfiguration(struct soap *soap, const char *tag, struct tt__OSDPosConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Pos = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDPosConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Pos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Pos", &a->Pos, "tt:Vector"))
				{	soap_flag_Pos--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDPosConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_new_tt__OSDPosConfiguration(struct soap *soap, int n)
{
	struct tt__OSDPosConfiguration *p;
	struct tt__OSDPosConfiguration *a = (struct tt__OSDPosConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_get_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatusExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatusExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatusExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_in_tt__ProfileStatusExtension(struct soap *soap, const char *tag, struct tt__ProfileStatusExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ProfileStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatusExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatusExtension, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_new_tt__ProfileStatusExtension(struct soap *soap, int n)
{
	struct tt__ProfileStatusExtension *p;
	struct tt__ProfileStatusExtension *a = (struct tt__ProfileStatusExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatusExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatusExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_get_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActiveConnections = 0;
	a->ActiveConnections = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
		{
			soap_embedded(soap, a->ActiveConnections + i, SOAP_TYPE_tt__ActiveConnection);
			soap_serialize_tt__ActiveConnection(soap, a->ActiveConnections + i);
		}
	}
	soap_serialize_PointerTott__ProfileStatusExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatus(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatus), type))
		return soap->error;
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
			if (soap_out_tt__ActiveConnection(soap, "tt:ActiveConnections", -1, a->ActiveConnections + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ProfileStatusExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_in_tt__ProfileStatus(struct soap *soap, const char *tag, struct tt__ProfileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_ActiveConnections = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ProfileStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ActiveConnections", 1, NULL))
			{	if (a->ActiveConnections == NULL)
				{	if (soap_blist_ActiveConnections == NULL)
						soap_blist_ActiveConnections = soap_alloc_block(soap);
					a->ActiveConnections = (struct tt__ActiveConnection *)soap_push_block_max(soap, soap_blist_ActiveConnections, sizeof(struct tt__ActiveConnection));
					if (a->ActiveConnections == NULL)
						return NULL;
					soap_default_tt__ActiveConnection(soap, a->ActiveConnections);
				}
				soap_revert(soap);
				if (soap_in_tt__ActiveConnection(soap, "tt:ActiveConnections", a->ActiveConnections, "tt:ActiveConnection"))
				{	a->__sizeActiveConnections++;
					a->ActiveConnections = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileStatusExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileStatusExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActiveConnections)
			soap_pop_block(soap, soap_blist_ActiveConnections);
		if (a->__sizeActiveConnections)
		{	a->ActiveConnections = (struct tt__ActiveConnection *)soap_save_block(soap, soap_blist_ActiveConnections, NULL, 1);
		}
		else
		{	a->ActiveConnections = NULL;
			if (soap_blist_ActiveConnections)
				soap_end_block(soap, soap_blist_ActiveConnections);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatus, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_new_tt__ProfileStatus(struct soap *soap, int n)
{
	struct tt__ProfileStatus *p;
	struct tt__ProfileStatus *a = (struct tt__ProfileStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatus(soap, tag ? tag : "tt:ProfileStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_get_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->CurrentBitrate);
	soap_default_float(soap, &a->CurrentFps);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentBitrate, SOAP_TYPE_float);
	soap_embedded(soap, &a->CurrentFps, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActiveConnection(struct soap *soap, const char *tag, int id, const struct tt__ActiveConnection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActiveConnection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentBitrate", -1, &a->CurrentBitrate, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentFps", -1, &a->CurrentFps, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_in_tt__ActiveConnection(struct soap *soap, const char *tag, struct tt__ActiveConnection *a, const char *type)
{
	size_t soap_flag_CurrentBitrate = 1;
	size_t soap_flag_CurrentFps = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActiveConnection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActiveConnection(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentBitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentBitrate", &a->CurrentBitrate, "xsd:float"))
				{	soap_flag_CurrentBitrate--;
					continue;
				}
			}
			if (soap_flag_CurrentFps && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentFps", &a->CurrentFps, "xsd:float"))
				{	soap_flag_CurrentFps--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentBitrate > 0 || soap_flag_CurrentFps > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ActiveConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_new_tt__ActiveConnection(struct soap *soap, int n)
{
	struct tt__ActiveConnection *p;
	struct tt__ActiveConnection *a = (struct tt__ActiveConnection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActiveConnection));
	for (p = a; p && n--; p++)
		soap_default_tt__ActiveConnection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_get_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassDescriptorExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptorExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptorExtension, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_new_tt__AudioClassDescriptorExtension(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptorExtension *p;
	struct tt__AudioClassDescriptorExtension *a = (struct tt__AudioClassDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE_tt__AudioClassCandidate);
			soap_serialize_tt__AudioClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__AudioClassDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
			if (soap_out_tt__AudioClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_in_tt__AudioClassDescriptor(struct soap *soap, const char *tag, struct tt__AudioClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptor(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_alloc_block(soap);
					a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_push_block_max(soap, soap_blist_ClassCandidate, sizeof(struct tt__AudioClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default_tt__AudioClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, "tt:AudioClassCandidate"))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:AudioClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
		{	a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		}
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptor, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_new_tt__AudioClassDescriptor(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptor *p;
	struct tt__AudioClassDescriptor *a = (struct tt__AudioClassDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptor(soap, tag ? tag : "tt:AudioClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_get_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AudioClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassCandidate(struct soap *soap, const char *tag, int id, const struct tt__AudioClassCandidate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassCandidate), type))
		return soap->error;
	if (soap_out_tt__AudioClassType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_in_tt__AudioClassCandidate(struct soap *soap, const char *tag, struct tt__AudioClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassCandidate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassCandidate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioClassType(soap, "tt:Type", &a->Type, "tt:AudioClassType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_new_tt__AudioClassCandidate(struct soap *soap, int n)
{
	struct tt__AudioClassCandidate *p;
	struct tt__AudioClassCandidate *a = (struct tt__AudioClassCandidate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassCandidate));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassCandidate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_get_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActionEngineEventPayloadExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayloadExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayloadExtension(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayloadExtension *p;
	struct tt__ActionEngineEventPayloadExtension *a = (struct tt__ActionEngineEventPayloadExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayloadExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayloadExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RequestInfo = NULL;
	a->ResponseInfo = NULL;
	a->Fault = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->RequestInfo);
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->ResponseInfo);
	soap_serialize_PointerToSOAP_ENV__Fault(soap, &a->Fault);
	soap_serialize_PointerTott__ActionEngineEventPayloadExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayload), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", -1, &a->RequestInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", -1, &a->ResponseInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Fault(soap, "tt:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayload *a, const char *type)
{
	size_t soap_flag_RequestInfo = 1;
	size_t soap_flag_ResponseInfo = 1;
	size_t soap_flag_Fault = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActionEngineEventPayload*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayload(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", &a->RequestInfo, ""))
				{	soap_flag_RequestInfo--;
					continue;
				}
			}
			if (soap_flag_ResponseInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", &a->ResponseInfo, ""))
				{	soap_flag_ResponseInfo--;
					continue;
				}
			}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Fault(soap, "tt:Fault", &a->Fault, ""))
				{	soap_flag_Fault--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", &a->Extension, "tt:ActionEngineEventPayloadExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayload, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayload(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayload *p;
	struct tt__ActionEngineEventPayload *a = (struct tt__ActionEngineEventPayload*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayload));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayload(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayload(soap, tag ? tag : "tt:ActionEngineEventPayload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Error);
	soap_default_string(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_string(soap, (char*const*)&a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsState(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsState), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_in_tt__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState *a, const char *type)
{
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:State", (char**)&a->State, "xsd:string"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_new_tt__AnalyticsState(struct soap *soap, int n)
{
	struct tt__AnalyticsState *p;
	struct tt__AnalyticsState *a = (struct tt__AnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsState));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_get_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
	soap_serialize_PointerTott__AnalyticsState(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsStateInformation), type))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineControlToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_in_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, struct tt__AnalyticsStateInformation *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsStateInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsState(soap, "tt:State", &a->State, "tt:AnalyticsState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AnalyticsEngineControlToken || !a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_new_tt__AnalyticsStateInformation(struct soap *soap, int n)
{
	struct tt__AnalyticsStateInformation *p;
	struct tt__AnalyticsStateInformation *a = (struct tt__AnalyticsStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsStateInformation(soap, tag ? tag : "tt:AnalyticsStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_get_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInputExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataInputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInputExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_in_tt__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataInputExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInputExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_new_tt__MetadataInputExtension(struct soap *soap, int n)
{
	struct tt__MetadataInputExtension *p;
	struct tt__MetadataInputExtension *a = (struct tt__MetadataInputExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInputExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInputExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_get_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMetadataConfig = 0;
	a->MetadataConfig = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
		{
			soap_embedded(soap, a->MetadataConfig + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->MetadataConfig + i);
		}
	}
	soap_serialize_PointerTott__MetadataInputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInput(struct soap *soap, const char *tag, int id, const struct tt__MetadataInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInput), type))
		return soap->error;
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
			if (soap_out_tt__Config(soap, "tt:MetadataConfig", -1, a->MetadataConfig + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MetadataInputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_in_tt__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput *a, const char *type)
{
	struct soap_blist *soap_blist_MetadataConfig = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInput(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:MetadataConfig", 1, NULL))
			{	if (a->MetadataConfig == NULL)
				{	if (soap_blist_MetadataConfig == NULL)
						soap_blist_MetadataConfig = soap_alloc_block(soap);
					a->MetadataConfig = (struct tt__Config *)soap_push_block_max(soap, soap_blist_MetadataConfig, sizeof(struct tt__Config));
					if (a->MetadataConfig == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->MetadataConfig);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:MetadataConfig", a->MetadataConfig, "tt:Config"))
				{	a->__sizeMetadataConfig++;
					a->MetadataConfig = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInputExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataInputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MetadataConfig)
			soap_pop_block(soap, soap_blist_MetadataConfig);
		if (a->__sizeMetadataConfig)
		{	a->MetadataConfig = (struct tt__Config *)soap_save_block(soap, soap_blist_MetadataConfig, NULL, 1);
		}
		else
		{	a->MetadataConfig = NULL;
			if (soap_blist_MetadataConfig)
				soap_end_block(soap, soap_blist_MetadataConfig);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_new_tt__MetadataInput(struct soap *soap, int n)
{
	struct tt__MetadataInput *p;
	struct tt__MetadataInput *a = (struct tt__MetadataInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInput));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_get_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentificationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentificationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_in_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SourceIdentificationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentificationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_new_tt__SourceIdentificationExtension(struct soap *soap, int n)
{
	struct tt__SourceIdentificationExtension *p;
	struct tt__SourceIdentificationExtension *a = (struct tt__SourceIdentificationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentificationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentificationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_get_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->__sizeToken = 0;
	a->Token = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
	soap_serialize_PointerTott__SourceIdentificationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentification(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentification), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			if (soap_out_string(soap, "tt:Token", -1, (char*const*)(a->Token + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_in_tt__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification *a, const char *type)
{
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Token = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SourceIdentification*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentification(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", &a->Extension, "tt:SourceIdentificationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_new_tt__SourceIdentification(struct soap *soap, int n)
{
	struct tt__SourceIdentification *p;
	struct tt__SourceIdentification *a = (struct tt__SourceIdentification*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentification));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentification(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_get_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInputInfoExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfoExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfoExtension *p;
	struct tt__AnalyticsEngineInputInfoExtension *a = (struct tt__AnalyticsEngineInputInfoExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfoExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfoExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputInfo = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Config(soap, &a->InputInfo);
	soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo), type))
		return soap->error;
	if (soap_out_PointerTott__Config(soap, "tt:InputInfo", -1, &a->InputInfo, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	size_t soap_flag_InputInfo = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInputInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:InputInfo", &a->InputInfo, "tt:Config"))
				{	soap_flag_InputInfo--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineInputInfoExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfo(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfo *p;
	struct tt__AnalyticsEngineInputInfo *a = (struct tt__AnalyticsEngineInputInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceEngineConfigurationExtension *p;
	struct tt__AnalyticsDeviceEngineConfigurationExtension *a = (struct tt__AnalyticsDeviceEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoAnalyticsConfiguration = NULL;
	a->AnalyticsEngineInputInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__AnalyticsEngineInputInfo(soap, &a->AnalyticsEngineInputInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EngineConfiguration), type))
		return soap->error;
	if (!a->VideoAnalyticsConfiguration)
	{	if (soap_element_empty(soap, "tt:VideoAnalyticsConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (!a->AnalyticsEngineInputInfo)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineInputInfo", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", -1, &a->AnalyticsEngineInputInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_in_tt__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration *a, const char *type)
{
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_AnalyticsEngineInputInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EngineConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineInputInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", &a->AnalyticsEngineInputInfo, "tt:AnalyticsEngineInputInfo"))
				{	soap_flag_AnalyticsEngineInputInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoAnalyticsConfiguration || !a->AnalyticsEngineInputInfo))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_new_tt__EngineConfiguration(struct soap *soap, int n)
{
	struct tt__EngineConfiguration *p;
	struct tt__EngineConfiguration *a = (struct tt__EngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__EngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_get_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEngineConfiguration = 0;
	a->EngineConfiguration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeEngineConfiguration; i++)
		{
			soap_embedded(soap, a->EngineConfiguration + i, SOAP_TYPE_tt__EngineConfiguration);
			soap_serialize_tt__EngineConfiguration(soap, a->EngineConfiguration + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration), type))
		return soap->error;
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeEngineConfiguration; i++)
			if (soap_out_tt__EngineConfiguration(soap, "tt:EngineConfiguration", -1, a->EngineConfiguration + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_EngineConfiguration = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsDeviceEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:EngineConfiguration", 1, NULL))
			{	if (a->EngineConfiguration == NULL)
				{	if (soap_blist_EngineConfiguration == NULL)
						soap_blist_EngineConfiguration = soap_alloc_block(soap);
					a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_push_block_max(soap, soap_blist_EngineConfiguration, sizeof(struct tt__EngineConfiguration));
					if (a->EngineConfiguration == NULL)
						return NULL;
					soap_default_tt__EngineConfiguration(soap, a->EngineConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__EngineConfiguration(soap, "tt:EngineConfiguration", a->EngineConfiguration, "tt:EngineConfiguration"))
				{	a->__sizeEngineConfiguration++;
					a->EngineConfiguration = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsDeviceEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EngineConfiguration)
			soap_pop_block(soap, soap_blist_EngineConfiguration);
		if (a->__sizeEngineConfiguration)
		{	a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_save_block(soap, soap_blist_EngineConfiguration, NULL, 1);
		}
		else
		{	a->EngineConfiguration = NULL;
			if (soap_blist_EngineConfiguration)
				soap_end_block(soap, soap_blist_EngineConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEngineConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceEngineConfiguration *p;
	struct tt__AnalyticsDeviceEngineConfiguration *a = (struct tt__AnalyticsDeviceEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->SessionTimeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->SessionTimeout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayConfiguration), type))
		return soap->error;
	if (!a->SessionTimeout)
	{	if (soap_element_empty(soap, "tt:SessionTimeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, (char*const*)&a->SessionTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_in_tt__ReplayConfiguration(struct soap *soap, const char *tag, struct tt__ReplayConfiguration *a, const char *type)
{
	size_t soap_flag_SessionTimeout = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ReplayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReplayConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", (char**)&a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SessionTimeout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayConfiguration, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_new_tt__ReplayConfiguration(struct soap *soap, int n)
{
	struct tt__ReplayConfiguration *p;
	struct tt__ReplayConfiguration *a = (struct tt__ReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__ReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReplayConfiguration(soap, tag ? tag : "tt:ReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_get_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "tt:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "tt:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "tt:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GetRecordingJobsResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingJobsResponseItem(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "tt:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingJobsResponseItem, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_new_tt__GetRecordingJobsResponseItem(struct soap *soap, int n)
{
	struct tt__GetRecordingJobsResponseItem *p;
	struct tt__GetRecordingJobsResponseItem *a = (struct tt__GetRecordingJobsResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetRecordingJobsResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetRecordingJobsResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetRecordingJobsResponseItem(soap, tag ? tag : "tt:GetRecordingJobsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
	soap_default_string(soap, &a->Error);
	soap_default_tt__RecordingJobState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SourceTag);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->Destination);
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTrack), type))
		return soap->error;
	if (!a->SourceTag)
	{	if (soap_element_empty(soap, "tt:SourceTag", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:SourceTag", -1, (char*const*)&a->SourceTag, ""))
		return soap->error;
	if (!a->Destination)
	{	if (soap_element_empty(soap, "tt:Destination", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, (char*const*)&a->Destination, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_in_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobStateTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTrack(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:SourceTag", (char**)&a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:Destination", (char**)&a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceTag || !a->Destination || !a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_new_tt__RecordingJobStateTrack(struct soap *soap, int n)
{
	struct tt__RecordingJobStateTrack *p;
	struct tt__RecordingJobStateTrack *a = (struct tt__RecordingJobStateTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateTrack));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_get_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__RecordingJobStateTrack);
			soap_serialize_tt__RecordingJobStateTrack(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTracks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTracks), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__RecordingJobStateTrack(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_in_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobStateTracks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTracks(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__RecordingJobStateTrack *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__RecordingJobStateTrack));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateTrack(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateTrack(soap, "tt:Track", a->Track, "tt:RecordingJobStateTrack"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__RecordingJobStateTrack *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTracks, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_new_tt__RecordingJobStateTracks(struct soap *soap, int n)
{
	struct tt__RecordingJobStateTracks *p;
	struct tt__RecordingJobStateTracks *a = (struct tt__RecordingJobStateTracks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateTracks));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateTracks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_get_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobStateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformationExtension, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_new_tt__RecordingJobStateInformationExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobStateInformationExtension *p;
	struct tt__RecordingJobStateInformationExtension *a = (struct tt__RecordingJobStateInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->Tracks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
	soap_serialize_PointerTott__RecordingJobStateTracks(soap, &a->Tracks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateSource), type))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_empty(soap, "tt:SourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	if (!a->Tracks)
	{	if (soap_element_empty(soap, "tt:Tracks", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", -1, &a->Tracks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_in_tt__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_State = 1;
	size_t soap_flag_Tracks = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobStateSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateSource(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", &a->Tracks, "tt:RecordingJobStateTracks"))
				{	soap_flag_Tracks--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceToken || !a->State || !a->Tracks))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_new_tt__RecordingJobStateSource(struct soap *soap, int n)
{
	struct tt__RecordingJobStateSource *p;
	struct tt__RecordingJobStateSource *a = (struct tt__RecordingJobStateSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateSource));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_get_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->__sizeSources = 0;
	a->Sources = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
	if (a->Sources)
	{	int i;
		for (i = 0; i < (int)a->__sizeSources; i++)
		{
			soap_embedded(soap, a->Sources + i, SOAP_TYPE_tt__RecordingJobStateSource);
			soap_serialize_tt__RecordingJobStateSource(soap, a->Sources + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobStateInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	if (a->Sources)
	{	int i;
		for (i = 0; i < (int)a->__sizeSources; i++)
			if (soap_out_tt__RecordingJobStateSource(soap, "tt:Sources", -1, a->Sources + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist_Sources = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Sources", 1, NULL))
			{	if (a->Sources == NULL)
				{	if (soap_blist_Sources == NULL)
						soap_blist_Sources = soap_alloc_block(soap);
					a->Sources = (struct tt__RecordingJobStateSource *)soap_push_block_max(soap, soap_blist_Sources, sizeof(struct tt__RecordingJobStateSource));
					if (a->Sources == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateSource(soap, a->Sources);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateSource(soap, "tt:Sources", a->Sources, "tt:RecordingJobStateSource"))
				{	a->__sizeSources++;
					a->Sources = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobStateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Sources)
			soap_pop_block(soap, soap_blist_Sources);
		if (a->__sizeSources)
		{	a->Sources = (struct tt__RecordingJobStateSource *)soap_save_block(soap, soap_blist_Sources, NULL, 1);
		}
		else
		{	a->Sources = NULL;
			if (soap_blist_Sources)
				soap_end_block(soap, soap_blist_Sources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformation, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_new_tt__RecordingJobStateInformation(struct soap *soap, int n)
{
	struct tt__RecordingJobStateInformation *p;
	struct tt__RecordingJobStateInformation *a = (struct tt__RecordingJobStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateInformation(soap, tag ? tag : "tt:RecordingJobStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSourceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_in_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobSourceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSourceExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSourceExtension, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_new_tt__RecordingJobSourceExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobSourceExtension *p;
	struct tt__RecordingJobSourceExtension *a = (struct tt__RecordingJobSourceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobSourceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobSourceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_get_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SourceTag);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->Destination);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobTrack), type))
		return soap->error;
	if (!a->SourceTag)
	{	if (soap_element_empty(soap, "tt:SourceTag", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:SourceTag", -1, (char*const*)&a->SourceTag, ""))
		return soap->error;
	if (!a->Destination)
	{	if (soap_element_empty(soap, "tt:Destination", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, (char*const*)&a->Destination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_in_tt__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobTrack(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:SourceTag", (char**)&a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:Destination", (char**)&a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceTag || !a->Destination))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_new_tt__RecordingJobTrack(struct soap *soap, int n)
{
	struct tt__RecordingJobTrack *p;
	struct tt__RecordingJobTrack *a = (struct tt__RecordingJobTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobTrack));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_get_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfigurationExtension, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_new_tt__RecordingJobConfigurationExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobConfigurationExtension *p;
	struct tt__RecordingJobConfigurationExtension *a = (struct tt__RecordingJobConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	a->AutoCreateReceiver = NULL;
	a->__sizeTracks = 0;
	a->Tracks = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_PointerToxsd__boolean(soap, &a->AutoCreateReceiver);
	if (a->Tracks)
	{	int i;
		for (i = 0; i < (int)a->__sizeTracks; i++)
		{
			soap_embedded(soap, a->Tracks + i, SOAP_TYPE_tt__RecordingJobTrack);
			soap_serialize_tt__RecordingJobTrack(soap, a->Tracks + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobSourceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSource), type))
		return soap->error;
	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:AutoCreateReceiver", -1, &a->AutoCreateReceiver, ""))
		return soap->error;
	if (a->Tracks)
	{	int i;
		for (i = 0; i < (int)a->__sizeTracks; i++)
			if (soap_out_tt__RecordingJobTrack(soap, "tt:Tracks", -1, a->Tracks + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_in_tt__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_AutoCreateReceiver = 1;
	struct soap_blist *soap_blist_Tracks = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSource(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			}
			if (soap_flag_AutoCreateReceiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:AutoCreateReceiver", &a->AutoCreateReceiver, "xsd:boolean"))
				{	soap_flag_AutoCreateReceiver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Tracks", 1, NULL))
			{	if (a->Tracks == NULL)
				{	if (soap_blist_Tracks == NULL)
						soap_blist_Tracks = soap_alloc_block(soap);
					a->Tracks = (struct tt__RecordingJobTrack *)soap_push_block_max(soap, soap_blist_Tracks, sizeof(struct tt__RecordingJobTrack));
					if (a->Tracks == NULL)
						return NULL;
					soap_default_tt__RecordingJobTrack(soap, a->Tracks);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobTrack(soap, "tt:Tracks", a->Tracks, "tt:RecordingJobTrack"))
				{	a->__sizeTracks++;
					a->Tracks = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Tracks)
			soap_pop_block(soap, soap_blist_Tracks);
		if (a->__sizeTracks)
		{	a->Tracks = (struct tt__RecordingJobTrack *)soap_save_block(soap, soap_blist_Tracks, NULL, 1);
		}
		else
		{	a->Tracks = NULL;
			if (soap_blist_Tracks)
				soap_end_block(soap, soap_blist_Tracks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_new_tt__RecordingJobSource(struct soap *soap, int n)
{
	struct tt__RecordingJobSource *p;
	struct tt__RecordingJobSource *a = (struct tt__RecordingJobSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobSource));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_get_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
	soap_default_int(soap, &a->Priority);
	a->__sizeSource = 0;
	a->Source = NULL;
	a->Extension = NULL;
	soap_default_string(soap, &a->ScheduleToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__RecordingJobMode(soap, (char*const*)&a->Mode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_int);
	if (a->Source)
	{	int i;
		for (i = 0; i < (int)a->__sizeSource; i++)
		{
			soap_embedded(soap, a->Source + i, SOAP_TYPE_tt__RecordingJobSource);
			soap_serialize_tt__RecordingJobSource(soap, a->Source + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfiguration *a, const char *type)
{
	if (a->ScheduleToken)
		soap_set_attr(soap, "ScheduleToken", soap_string2s(soap, a->ScheduleToken), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_empty(soap, "tt:Mode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobMode(soap, "tt:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Source)
	{	int i;
		for (i = 0; i < (int)a->__sizeSource; i++)
			if (soap_out_tt__RecordingJobSource(soap, "tt:Source", -1, a->Source + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_in_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	struct soap_blist *soap_blist_Source = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingJobConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "ScheduleToken", 1, 0), &a->ScheduleToken))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobMode(soap, "tt:Mode", (char**)&a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Priority", &a->Priority, "xsd:int"))
				{	soap_flag_Priority--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Source", 1, NULL))
			{	if (a->Source == NULL)
				{	if (soap_blist_Source == NULL)
						soap_blist_Source = soap_alloc_block(soap);
					a->Source = (struct tt__RecordingJobSource *)soap_push_block_max(soap, soap_blist_Source, sizeof(struct tt__RecordingJobSource));
					if (a->Source == NULL)
						return NULL;
					soap_default_tt__RecordingJobSource(soap, a->Source);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobSource(soap, "tt:Source", a->Source, "tt:RecordingJobSource"))
				{	a->__sizeSource++;
					a->Source = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Source)
			soap_pop_block(soap, soap_blist_Source);
		if (a->__sizeSource)
		{	a->Source = (struct tt__RecordingJobSource *)soap_save_block(soap, soap_blist_Source, NULL, 1);
		}
		else
		{	a->Source = NULL;
			if (soap_blist_Source)
				soap_end_block(soap, soap_blist_Source);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Mode || soap_flag_Priority > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfiguration, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_new_tt__RecordingJobConfiguration(struct soap *soap, int n)
{
	struct tt__RecordingJobConfiguration *p;
	struct tt__RecordingJobConfiguration *a = (struct tt__RecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_get_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseItem), type))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "tt:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_in_tt__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GetTracksResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseItem(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:TrackConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken || !a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_new_tt__GetTracksResponseItem(struct soap *soap, int n)
{
	struct tt__GetTracksResponseItem *p;
	struct tt__GetTracksResponseItem *a = (struct tt__GetTracksResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetTracksResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetTracksResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_get_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__GetTracksResponseItem);
			soap_serialize_tt__GetTracksResponseItem(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseList(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseList), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__GetTracksResponseItem(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_in_tt__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GetTracksResponseList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__GetTracksResponseItem *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__GetTracksResponseItem));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__GetTracksResponseItem(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__GetTracksResponseItem(soap, "tt:Track", a->Track, "tt:GetTracksResponseItem"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__GetTracksResponseItem *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseList, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_new_tt__GetTracksResponseList(struct soap *soap, int n)
{
	struct tt__GetTracksResponseList *p;
	struct tt__GetTracksResponseList *a = (struct tt__GetTracksResponseList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetTracksResponseList));
	for (p = a; p && n--; p++)
		soap_default_tt__GetTracksResponseList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_get_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Configuration = NULL;
	a->Tracks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->Configuration);
	soap_serialize_PointerTott__GetTracksResponseList(soap, &a->Tracks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingsResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingsResponseItem), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (!a->Tracks)
	{	if (soap_element_empty(soap, "tt:Tracks", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__GetTracksResponseList(soap, "tt:Tracks", -1, &a->Tracks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingsResponseItem *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_Tracks = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GetRecordingsResponseItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingsResponseItem(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:RecordingConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GetTracksResponseList(soap, "tt:Tracks", &a->Tracks, "tt:GetTracksResponseList"))
				{	soap_flag_Tracks--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Configuration || !a->Tracks))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetRecordingsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingsResponseItem, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_new_tt__GetRecordingsResponseItem(struct soap *soap, int n)
{
	struct tt__GetRecordingsResponseItem *p;
	struct tt__GetRecordingsResponseItem *a = (struct tt__GetRecordingsResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetRecordingsResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetRecordingsResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetRecordingsResponseItem(soap, tag ? tag : "tt:GetRecordingsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackConfiguration), type))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_empty(soap, "tt:Description", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_in_tt__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration *a, const char *type)
{
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TrackConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackType > 0 || !a->Description))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackConfiguration, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_new_tt__TrackConfiguration(struct soap *soap, int n)
{
	struct tt__TrackConfiguration *p;
	struct tt__TrackConfiguration *a = (struct tt__TrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_get_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	soap_default_tt__Description(soap, &a->Content);
	soap_default_xsd__duration(soap, &a->MaximumRetentionTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_tt__Description(soap, (char*const*)&a->Content);
	soap_serialize_xsd__duration(soap, (char*const*)&a->MaximumRetentionTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingConfiguration), type))
		return soap->error;
	if (!a->Source)
	{	if (soap_element_empty(soap, "tt:Source", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (!a->Content)
	{	if (soap_element_empty(soap, "tt:Content", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Content", -1, (char*const*)&a->Content, ""))
		return soap->error;
	if (!a->MaximumRetentionTime)
	{	if (soap_element_empty(soap, "tt:MaximumRetentionTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tt:MaximumRetentionTime", -1, (char*const*)&a->MaximumRetentionTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_in_tt__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Content = 1;
	size_t soap_flag_MaximumRetentionTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Content", (char**)&a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			}
			if (soap_flag_MaximumRetentionTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:MaximumRetentionTime", (char**)&a->MaximumRetentionTime, "xsd:duration"))
				{	soap_flag_MaximumRetentionTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Source || !a->Content || !a->MaximumRetentionTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingConfiguration, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_new_tt__RecordingConfiguration(struct soap *soap, int n)
{
	struct tt__RecordingConfiguration *p;
	struct tt__RecordingConfiguration *a = (struct tt__RecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_get_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributesExtension(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_in_tt__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TrackAttributesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributesExtension, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_new_tt__TrackAttributesExtension(struct soap *soap, int n)
{
	struct tt__TrackAttributesExtension *p;
	struct tt__TrackAttributesExtension *a = (struct tt__TrackAttributesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackAttributesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackAttributesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_get_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->CanContainPTZ);
	soap_default_xsd__boolean(soap, &a->CanContainAnalytics);
	soap_default_xsd__boolean(soap, &a->CanContainNotifications);
	soap_default_tt__StringAttrList(soap, &a->PtzSpaces);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CanContainPTZ, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->CanContainAnalytics, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->CanContainNotifications, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataAttributes(struct soap *soap, const char *tag, int id, const struct tt__MetadataAttributes *a, const char *type)
{
	if (a->PtzSpaces)
		soap_set_attr(soap, "PtzSpaces", soap_tt__StringAttrList2s(soap, a->PtzSpaces), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataAttributes), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainPTZ", -1, &a->CanContainPTZ, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainAnalytics", -1, &a->CanContainAnalytics, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainNotifications", -1, &a->CanContainNotifications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_in_tt__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes *a, const char *type)
{
	size_t soap_flag_CanContainPTZ = 1;
	size_t soap_flag_CanContainAnalytics = 1;
	size_t soap_flag_CanContainNotifications = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataAttributes(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "PtzSpaces", 1, 0), &a->PtzSpaces))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanContainPTZ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:CanContainPTZ", &a->CanContainPTZ, "xsd:boolean"))
				{	soap_flag_CanContainPTZ--;
					continue;
				}
			}
			if (soap_flag_CanContainAnalytics && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:CanContainAnalytics", &a->CanContainAnalytics, "xsd:boolean"))
				{	soap_flag_CanContainAnalytics--;
					continue;
				}
			}
			if (soap_flag_CanContainNotifications && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:CanContainNotifications", &a->CanContainNotifications, "xsd:boolean"))
				{	soap_flag_CanContainNotifications--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanContainPTZ > 0 || soap_flag_CanContainAnalytics > 0 || soap_flag_CanContainNotifications > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataAttributes, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_new_tt__MetadataAttributes(struct soap *soap, int n)
{
	struct tt__MetadataAttributes *p;
	struct tt__MetadataAttributes *a = (struct tt__MetadataAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_get_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_string(soap, &a->Encoding);
	soap_default_int(soap, &a->Samplerate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_embedded(soap, &a->Samplerate, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAttributes(struct soap *soap, const char *tag, int id, const struct tt__AudioAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Samplerate", -1, &a->Samplerate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_in_tt__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Samplerate = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAttributes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Samplerate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Samplerate", &a->Samplerate, "xsd:int"))
				{	soap_flag_Samplerate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Encoding || soap_flag_Samplerate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAttributes, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_new_tt__AudioAttributes(struct soap *soap, int n)
{
	struct tt__AudioAttributes *p;
	struct tt__AudioAttributes *a = (struct tt__AudioAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_get_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
	soap_default_string(soap, &a->Encoding);
	soap_default_float(soap, &a->Framerate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAttributes(struct soap *soap, const char *tag, int id, const struct tt__VideoAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_in_tt__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Framerate = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAttributes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			}
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0 || !a->Encoding || soap_flag_Framerate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAttributes, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_new_tt__VideoAttributes(struct soap *soap, int n)
{
	struct tt__VideoAttributes *p;
	struct tt__VideoAttributes *a = (struct tt__VideoAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_get_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackInformation = NULL;
	a->VideoAttributes = NULL;
	a->AudioAttributes = NULL;
	a->MetadataAttributes = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TrackInformation(soap, &a->TrackInformation);
	soap_serialize_PointerTott__VideoAttributes(soap, &a->VideoAttributes);
	soap_serialize_PointerTott__AudioAttributes(soap, &a->AudioAttributes);
	soap_serialize_PointerTott__MetadataAttributes(soap, &a->MetadataAttributes);
	soap_serialize_PointerTott__TrackAttributesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributes(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributes), type))
		return soap->error;
	if (!a->TrackInformation)
	{	if (soap_element_empty(soap, "tt:TrackInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackInformation(soap, "tt:TrackInformation", -1, &a->TrackInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", -1, &a->VideoAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", -1, &a->AudioAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", -1, &a->MetadataAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__TrackAttributesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_in_tt__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes *a, const char *type)
{
	size_t soap_flag_TrackInformation = 1;
	size_t soap_flag_VideoAttributes = 1;
	size_t soap_flag_AudioAttributes = 1;
	size_t soap_flag_MetadataAttributes = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TrackAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackInformation(soap, "tt:TrackInformation", &a->TrackInformation, "tt:TrackInformation"))
				{	soap_flag_TrackInformation--;
					continue;
				}
			}
			if (soap_flag_VideoAttributes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", &a->VideoAttributes, "tt:VideoAttributes"))
				{	soap_flag_VideoAttributes--;
					continue;
				}
			}
			if (soap_flag_AudioAttributes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", &a->AudioAttributes, "tt:AudioAttributes"))
				{	soap_flag_AudioAttributes--;
					continue;
				}
			}
			if (soap_flag_MetadataAttributes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", &a->MetadataAttributes, "tt:MetadataAttributes"))
				{	soap_flag_MetadataAttributes--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackAttributesExtension(soap, "tt:Extension", &a->Extension, "tt:TrackAttributesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_new_tt__TrackAttributes(struct soap *soap, int n)
{
	struct tt__TrackAttributes *p;
	struct tt__TrackAttributes *a = (struct tt__TrackAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_get_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->__sizeTrackAttributes = 0;
	a->TrackAttributes = NULL;
	soap_default_dateTime(soap, &a->From);
	soap_default_dateTime(soap, &a->Until);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrackAttributes; i++)
		{
			soap_embedded(soap, a->TrackAttributes + i, SOAP_TYPE_tt__TrackAttributes);
			soap_serialize_tt__TrackAttributes(soap, a->TrackAttributes + i);
		}
	}
	soap_embedded(soap, &a->From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->Until, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaAttributes(struct soap *soap, const char *tag, int id, const struct tt__MediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaAttributes), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrackAttributes; i++)
			if (soap_out_tt__TrackAttributes(soap, "tt:TrackAttributes", -1, a->TrackAttributes + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_in_tt__MediaAttributes(struct soap *soap, const char *tag, struct tt__MediaAttributes *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	struct soap_blist *soap_blist_TrackAttributes = NULL;
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MediaAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaAttributes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TrackAttributes", 1, NULL))
			{	if (a->TrackAttributes == NULL)
				{	if (soap_blist_TrackAttributes == NULL)
						soap_blist_TrackAttributes = soap_alloc_block(soap);
					a->TrackAttributes = (struct tt__TrackAttributes *)soap_push_block_max(soap, soap_blist_TrackAttributes, sizeof(struct tt__TrackAttributes));
					if (a->TrackAttributes == NULL)
						return NULL;
					soap_default_tt__TrackAttributes(soap, a->TrackAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackAttributes(soap, "tt:TrackAttributes", a->TrackAttributes, "tt:TrackAttributes"))
				{	a->__sizeTrackAttributes++;
					a->TrackAttributes = NULL;
					continue;
				}
			}
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TrackAttributes)
			soap_pop_block(soap, soap_blist_TrackAttributes);
		if (a->__sizeTrackAttributes)
		{	a->TrackAttributes = (struct tt__TrackAttributes *)soap_save_block(soap, soap_blist_TrackAttributes, NULL, 1);
		}
		else
		{	a->TrackAttributes = NULL;
			if (soap_blist_TrackAttributes)
				soap_end_block(soap, soap_blist_TrackAttributes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || soap_flag_From > 0 || soap_flag_Until > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaAttributes, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_new_tt__MediaAttributes(struct soap *soap, int n)
{
	struct tt__MediaAttributes *p;
	struct tt__MediaAttributes *a = (struct tt__MediaAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaAttributes(soap, tag ? tag : "tt:MediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_get_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_dateTime(soap, &a->DataFrom);
	soap_default_dateTime(soap, &a->DataTo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->DataTo, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackInformation(struct soap *soap, const char *tag, int id, const struct tt__TrackInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackInformation), type))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "tt:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_empty(soap, "tt:Description", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataTo", -1, &a->DataTo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_in_tt__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataTo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TrackInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			}
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			}
			if (soap_flag_DataTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:DataTo", &a->DataTo, "xsd:dateTime"))
				{	soap_flag_DataTo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken || soap_flag_TrackType > 0 || !a->Description || soap_flag_DataFrom > 0 || soap_flag_DataTo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_new_tt__TrackInformation(struct soap *soap, int n)
{
	struct tt__TrackInformation *p;
	struct tt__TrackInformation *a = (struct tt__TrackInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_get_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->SourceId);
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__Description(soap, &a->Location);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SourceId);
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_tt__Description(soap, (char*const*)&a->Location);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSourceInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingSourceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSourceInformation), type))
		return soap->error;
	if (!a->SourceId)
	{	if (soap_element_empty(soap, "tt:SourceId", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:SourceId", -1, (char*const*)&a->SourceId, ""))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Location)
	{	if (soap_element_empty(soap, "tt:Location", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Location", -1, (char*const*)&a->Location, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_empty(soap, "tt:Description", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tt:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_in_tt__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation *a, const char *type)
{
	size_t soap_flag_SourceId = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Location = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingSourceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSourceInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:SourceId", (char**)&a->SourceId, "xsd:anyURI"))
				{	soap_flag_SourceId--;
					continue;
				}
			}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Location", (char**)&a->Location, "tt:Description"))
				{	soap_flag_Location--;
					continue;
				}
			}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			}
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SourceId || !a->Name || !a->Location || !a->Description || !a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSourceInformation, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_new_tt__RecordingSourceInformation(struct soap *soap, int n)
{
	struct tt__RecordingSourceInformation *p;
	struct tt__RecordingSourceInformation *a = (struct tt__RecordingSourceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingSourceInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingSourceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_get_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResult(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "tt:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_in_tt__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindMetadataResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_new_tt__FindMetadataResult(struct soap *soap, int n)
{
	struct tt__FindMetadataResult *p;
	struct tt__FindMetadataResult *a = (struct tt__FindMetadataResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindMetadataResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindMetadataResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_get_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindMetadataResult);
			soap_serialize_tt__FindMetadataResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResultList(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindMetadataResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_in_tt__FindMetadataResultList(struct soap *soap, const char *tag, struct tt__FindMetadataResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindMetadataResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResultList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindMetadataResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindMetadataResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindMetadataResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindMetadataResult(soap, "tt:Result", a->Result, "tt:FindMetadataResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindMetadataResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResultList, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_new_tt__FindMetadataResultList(struct soap *soap, int n)
{
	struct tt__FindMetadataResultList *p;
	struct tt__FindMetadataResultList *a = (struct tt__FindMetadataResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindMetadataResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindMetadataResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindMetadataResultList(soap, tag ? tag : "tt:FindMetadataResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_get_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
	a->Position = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "tt:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_in_tt__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindPTZPositionResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0 || !a->Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_new_tt__FindPTZPositionResult(struct soap *soap, int n)
{
	struct tt__FindPTZPositionResult *p;
	struct tt__FindPTZPositionResult *a = (struct tt__FindPTZPositionResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindPTZPositionResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindPTZPositionResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_get_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindPTZPositionResult);
			soap_serialize_tt__FindPTZPositionResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindPTZPositionResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_in_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, struct tt__FindPTZPositionResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindPTZPositionResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResultList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindPTZPositionResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindPTZPositionResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindPTZPositionResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindPTZPositionResult(soap, "tt:Result", a->Result, "tt:FindPTZPositionResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindPTZPositionResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResultList, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_new_tt__FindPTZPositionResultList(struct soap *soap, int n)
{
	struct tt__FindPTZPositionResultList *p;
	struct tt__FindPTZPositionResultList *a = (struct tt__FindPTZPositionResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindPTZPositionResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindPTZPositionResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindPTZPositionResultList(soap, tag ? tag : "tt:FindPTZPositionResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_get_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotificationMessageHolderType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotificationMessageHolderType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_new_wsnt__NotificationMessageHolderType(struct soap *soap, int n)
{
	struct wsnt__NotificationMessageHolderType *p;
	struct wsnt__NotificationMessageHolderType *a = (struct wsnt__NotificationMessageHolderType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotificationMessageHolderType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotificationMessageHolderType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
	a->Event = NULL;
	soap_default_xsd__boolean(soap, &a->StartStateEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->Event);
	soap_embedded(soap, &a->StartStateEvent, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResult(struct soap *soap, const char *tag, int id, const struct tt__FindEventResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "tt:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Event)
	{	if (soap_element_empty(soap, "tt:Event", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", -1, &a->Event, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:StartStateEvent", -1, &a->StartStateEvent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_in_tt__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Event = 1;
	size_t soap_flag_StartStateEvent = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindEventResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResult(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			}
			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", &a->Event, "wsnt:NotificationMessageHolderType"))
				{	soap_flag_Event--;
					continue;
				}
			}
			if (soap_flag_StartStateEvent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:StartStateEvent", &a->StartStateEvent, "xsd:boolean"))
				{	soap_flag_StartStateEvent--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || soap_flag_Time > 0 || !a->Event || soap_flag_StartStateEvent > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindEventResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_new_tt__FindEventResult(struct soap *soap, int n)
{
	struct tt__FindEventResult *p;
	struct tt__FindEventResult *a = (struct tt__FindEventResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindEventResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindEventResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_get_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindEventResult);
			soap_serialize_tt__FindEventResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResultList(struct soap *soap, const char *tag, int id, const struct tt__FindEventResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindEventResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_in_tt__FindEventResultList(struct soap *soap, const char *tag, struct tt__FindEventResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindEventResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResultList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindEventResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindEventResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindEventResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindEventResult(soap, "tt:Result", a->Result, "tt:FindEventResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindEventResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindEventResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResultList, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_new_tt__FindEventResultList(struct soap *soap, int n)
{
	struct tt__FindEventResultList *p;
	struct tt__FindEventResultList *a = (struct tt__FindEventResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindEventResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindEventResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindEventResultList(soap, tag ? tag : "tt:FindEventResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_get_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Source = NULL;
	a->EarliestRecording = NULL;
	a->LatestRecording = NULL;
	soap_default_tt__Description(soap, &a->Content);
	a->__sizeTrack = 0;
	a->Track = NULL;
	soap_default_tt__RecordingStatus(soap, &a->RecordingStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_PointerTodateTime(soap, &a->EarliestRecording);
	soap_serialize_PointerTodateTime(soap, &a->LatestRecording);
	soap_serialize_tt__Description(soap, (char*const*)&a->Content);
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__TrackInformation);
			soap_serialize_tt__TrackInformation(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tt:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Source)
	{	if (soap_element_empty(soap, "tt:Source", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tt:EarliestRecording", -1, &a->EarliestRecording, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tt:LatestRecording", -1, &a->LatestRecording, ""))
		return soap->error;
	if (!a->Content)
	{	if (soap_element_empty(soap, "tt:Content", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Description(soap, "tt:Content", -1, (char*const*)&a->Content, ""))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__TrackInformation(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	if (soap_out_tt__RecordingStatus(soap, "tt:RecordingStatus", -1, &a->RecordingStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_in_tt__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Source = 1;
	size_t soap_flag_EarliestRecording = 1;
	size_t soap_flag_LatestRecording = 1;
	size_t soap_flag_Content = 1;
	struct soap_blist *soap_blist_Track = NULL;
	size_t soap_flag_RecordingStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_EarliestRecording && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tt:EarliestRecording", &a->EarliestRecording, "xsd:dateTime"))
				{	soap_flag_EarliestRecording--;
					continue;
				}
			}
			if (soap_flag_LatestRecording && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tt:LatestRecording", &a->LatestRecording, "xsd:dateTime"))
				{	soap_flag_LatestRecording--;
					continue;
				}
			}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "tt:Content", (char**)&a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__TrackInformation *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__TrackInformation));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__TrackInformation(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackInformation(soap, "tt:Track", a->Track, "tt:TrackInformation"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RecordingStatus(soap, "tt:RecordingStatus", &a->RecordingStatus, "tt:RecordingStatus"))
				{	soap_flag_RecordingStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__TrackInformation *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->Source || !a->Content || soap_flag_RecordingStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_new_tt__RecordingInformation(struct soap *soap, int n)
{
	struct tt__RecordingInformation *p;
	struct tt__RecordingInformation *a = (struct tt__RecordingInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_get_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeRecordingInformation = 0;
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingInformation; i++)
		{
			soap_embedded(soap, a->RecordingInformation + i, SOAP_TYPE_tt__RecordingInformation);
			soap_serialize_tt__RecordingInformation(soap, a->RecordingInformation + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindRecordingResultList(struct soap *soap, const char *tag, int id, const struct tt__FindRecordingResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindRecordingResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingInformation; i++)
			if (soap_out_tt__RecordingInformation(soap, "tt:RecordingInformation", -1, a->RecordingInformation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_in_tt__FindRecordingResultList(struct soap *soap, const char *tag, struct tt__FindRecordingResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_RecordingInformation = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FindRecordingResultList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindRecordingResultList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RecordingInformation", 1, NULL))
			{	if (a->RecordingInformation == NULL)
				{	if (soap_blist_RecordingInformation == NULL)
						soap_blist_RecordingInformation = soap_alloc_block(soap);
					a->RecordingInformation = (struct tt__RecordingInformation *)soap_push_block_max(soap, soap_blist_RecordingInformation, sizeof(struct tt__RecordingInformation));
					if (a->RecordingInformation == NULL)
						return NULL;
					soap_default_tt__RecordingInformation(soap, a->RecordingInformation);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingInformation(soap, "tt:RecordingInformation", a->RecordingInformation, "tt:RecordingInformation"))
				{	a->__sizeRecordingInformation++;
					a->RecordingInformation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingInformation)
			soap_pop_block(soap, soap_blist_RecordingInformation);
		if (a->__sizeRecordingInformation)
		{	a->RecordingInformation = (struct tt__RecordingInformation *)soap_save_block(soap, soap_blist_RecordingInformation, NULL, 1);
		}
		else
		{	a->RecordingInformation = NULL;
			if (soap_blist_RecordingInformation)
				soap_end_block(soap, soap_blist_RecordingInformation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindRecordingResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindRecordingResultList, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_new_tt__FindRecordingResultList(struct soap *soap, int n)
{
	struct tt__FindRecordingResultList *p;
	struct tt__FindRecordingResultList *a = (struct tt__FindRecordingResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindRecordingResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindRecordingResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindRecordingResultList(soap, tag ? tag : "tt:FindRecordingResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_get_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__XPathExpression(soap, &a->MetadataStreamFilter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__XPathExpression(soap, (char*const*)&a->MetadataStreamFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataFilter(struct soap *soap, const char *tag, int id, const struct tt__MetadataFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataFilter), type))
		return soap->error;
	if (!a->MetadataStreamFilter)
	{	if (soap_element_empty(soap, "tt:MetadataStreamFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__XPathExpression(soap, "tt:MetadataStreamFilter", -1, (char*const*)&a->MetadataStreamFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_in_tt__MetadataFilter(struct soap *soap, const char *tag, struct tt__MetadataFilter *a, const char *type)
{
	size_t soap_flag_MetadataStreamFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MetadataStreamFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__XPathExpression(soap, "tt:MetadataStreamFilter", (char**)&a->MetadataStreamFilter, "tt:XPathExpression"))
				{	soap_flag_MetadataStreamFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MetadataStreamFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataFilter, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_new_tt__MetadataFilter(struct soap *soap, int n)
{
	struct tt__MetadataFilter *p;
	struct tt__MetadataFilter *a = (struct tt__MetadataFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataFilter(soap, tag ? tag : "tt:MetadataFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_get_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MinPosition = NULL;
	a->MaxPosition = NULL;
	soap_default_xsd__boolean(soap, &a->EnterOrExit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &a->MinPosition);
	soap_serialize_PointerTott__PTZVector(soap, &a->MaxPosition);
	soap_embedded(soap, &a->EnterOrExit, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPositionFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZPositionFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPositionFilter), type))
		return soap->error;
	if (!a->MinPosition)
	{	if (soap_element_empty(soap, "tt:MinPosition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:MinPosition", -1, &a->MinPosition, ""))
		return soap->error;
	if (!a->MaxPosition)
	{	if (soap_element_empty(soap, "tt:MaxPosition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tt:MaxPosition", -1, &a->MaxPosition, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:EnterOrExit", -1, &a->EnterOrExit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_in_tt__PTZPositionFilter(struct soap *soap, const char *tag, struct tt__PTZPositionFilter *a, const char *type)
{
	size_t soap_flag_MinPosition = 1;
	size_t soap_flag_MaxPosition = 1;
	size_t soap_flag_EnterOrExit = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZPositionFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPositionFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:MinPosition", &a->MinPosition, "tt:PTZVector"))
				{	soap_flag_MinPosition--;
					continue;
				}
			}
			if (soap_flag_MaxPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:MaxPosition", &a->MaxPosition, "tt:PTZVector"))
				{	soap_flag_MaxPosition--;
					continue;
				}
			}
			if (soap_flag_EnterOrExit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:EnterOrExit", &a->EnterOrExit, "xsd:boolean"))
				{	soap_flag_EnterOrExit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MinPosition || !a->MaxPosition || soap_flag_EnterOrExit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPositionFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPositionFilter, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_new_tt__PTZPositionFilter(struct soap *soap, int n)
{
	struct tt__PTZPositionFilter *p;
	struct tt__PTZPositionFilter *a = (struct tt__PTZPositionFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPositionFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPositionFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPositionFilter(soap, tag ? tag : "tt:PTZPositionFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_get_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScopeExtension(struct soap *soap, const char *tag, int id, const struct tt__SearchScopeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScopeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_in_tt__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SearchScopeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScopeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScopeExtension, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_new_tt__SearchScopeExtension(struct soap *soap, int n)
{
	struct tt__SearchScopeExtension *p;
	struct tt__SearchScopeExtension *a = (struct tt__SearchScopeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SearchScopeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchScopeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_get_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScope(struct soap *soap, struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIncludedSources = 0;
	a->IncludedSources = NULL;
	a->__sizeIncludedRecordings = 0;
	a->IncludedRecordings = NULL;
	soap_default_tt__XPathExpression(soap, &a->RecordingInformationFilter);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedSources; i++)
		{
			soap_embedded(soap, a->IncludedSources + i, SOAP_TYPE_tt__SourceReference);
			soap_serialize_tt__SourceReference(soap, a->IncludedSources + i);
		}
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedRecordings; i++)
		{
			soap_serialize_tt__RecordingReference(soap, (char*const*)(a->IncludedRecordings + i));
		}
	}
	soap_serialize_tt__XPathExpression(soap, (char*const*)&a->RecordingInformationFilter);
	soap_serialize_PointerTott__SearchScopeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScope(struct soap *soap, const char *tag, int id, const struct tt__SearchScope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScope), type))
		return soap->error;
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedSources; i++)
			if (soap_out_tt__SourceReference(soap, "tt:IncludedSources", -1, a->IncludedSources + i, ""))
				return soap->error;
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedRecordings; i++)
			if (soap_out_string(soap, "tt:IncludedRecordings", -1, (char*const*)(a->IncludedRecordings + i), ""))
				return soap->error;
	}
	if (soap_out_tt__XPathExpression(soap, "tt:RecordingInformationFilter", -1, (char*const*)&a->RecordingInformationFilter, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchScopeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_in_tt__SearchScope(struct soap *soap, const char *tag, struct tt__SearchScope *a, const char *type)
{
	struct soap_blist *soap_blist_IncludedSources = NULL;
	struct soap_blist *soap_blist_IncludedRecordings = NULL;
	size_t soap_flag_RecordingInformationFilter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SearchScope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedSources", 1, NULL))
			{	if (a->IncludedSources == NULL)
				{	if (soap_blist_IncludedSources == NULL)
						soap_blist_IncludedSources = soap_alloc_block(soap);
					a->IncludedSources = (struct tt__SourceReference *)soap_push_block_max(soap, soap_blist_IncludedSources, sizeof(struct tt__SourceReference));
					if (a->IncludedSources == NULL)
						return NULL;
					soap_default_tt__SourceReference(soap, a->IncludedSources);
				}
				soap_revert(soap);
				if (soap_in_tt__SourceReference(soap, "tt:IncludedSources", a->IncludedSources, "tt:SourceReference"))
				{	a->__sizeIncludedSources++;
					a->IncludedSources = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedRecordings", 1, NULL))
			{	if (a->IncludedRecordings == NULL)
				{	if (soap_blist_IncludedRecordings == NULL)
						soap_blist_IncludedRecordings = soap_alloc_block(soap);
					a->IncludedRecordings = (char **)soap_push_block_max(soap, soap_blist_IncludedRecordings, sizeof(char *));
					if (a->IncludedRecordings == NULL)
						return NULL;
					*a->IncludedRecordings = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tt:IncludedRecordings", (char**)a->IncludedRecordings, "tt:RecordingReference"))
				{	a->__sizeIncludedRecordings++;
					a->IncludedRecordings = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingInformationFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__XPathExpression(soap, "tt:RecordingInformationFilter", (char**)&a->RecordingInformationFilter, "tt:XPathExpression"))
				{	soap_flag_RecordingInformationFilter--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScopeExtension(soap, "tt:Extension", &a->Extension, "tt:SearchScopeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IncludedSources)
			soap_pop_block(soap, soap_blist_IncludedSources);
		if (a->__sizeIncludedSources)
		{	a->IncludedSources = (struct tt__SourceReference *)soap_save_block(soap, soap_blist_IncludedSources, NULL, 1);
		}
		else
		{	a->IncludedSources = NULL;
			if (soap_blist_IncludedSources)
				soap_end_block(soap, soap_blist_IncludedSources);
		}
		if (a->IncludedRecordings)
			soap_pop_block(soap, soap_blist_IncludedRecordings);
		if (a->__sizeIncludedRecordings)
		{	a->IncludedRecordings = (char **)soap_save_block(soap, soap_blist_IncludedRecordings, NULL, 1);
		}
		else
		{	a->IncludedRecordings = NULL;
			if (soap_blist_IncludedRecordings)
				soap_end_block(soap, soap_blist_IncludedRecordings);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScope, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_new_tt__SearchScope(struct soap *soap, int n)
{
	struct tt__SearchScope *p;
	struct tt__SearchScope *a = (struct tt__SearchScope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SearchScope));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchScope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchScope(soap, tag ? tag : "tt:SearchScope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_get_tt__SearchScope(struct soap *soap, struct tt__SearchScope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->DataFrom);
	soap_default_dateTime(soap, &a->DataUntil);
	soap_default_int(soap, &a->NumberRecordings);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->DataUntil, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->NumberRecordings, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSummary(struct soap *soap, const char *tag, int id, const struct tt__RecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSummary), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataUntil", -1, &a->DataUntil, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:NumberRecordings", -1, &a->NumberRecordings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_in_tt__RecordingSummary(struct soap *soap, const char *tag, struct tt__RecordingSummary *a, const char *type)
{
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataUntil = 1;
	size_t soap_flag_NumberRecordings = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RecordingSummary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSummary(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			}
			if (soap_flag_DataUntil && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:DataUntil", &a->DataUntil, "xsd:dateTime"))
				{	soap_flag_DataUntil--;
					continue;
				}
			}
			if (soap_flag_NumberRecordings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:NumberRecordings", &a->NumberRecordings, "xsd:int"))
				{	soap_flag_NumberRecordings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataFrom > 0 || soap_flag_DataUntil > 0 || soap_flag_NumberRecordings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSummary, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_new_tt__RecordingSummary(struct soap *soap, int n)
{
	struct tt__RecordingSummary *p;
	struct tt__RecordingSummary *a = (struct tt__RecordingSummary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingSummary));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingSummary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingSummary(soap, tag ? tag : "tt:RecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_get_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceReference(struct soap *soap, struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->Type = (char*)"http://www.onvif.org/ver10/schema/Receiver";
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceReference(struct soap *soap, const char *tag, int id, const struct tt__SourceReference *a, const char *type)
{
	if (!a->Type || strcmp(a->Type, (char*)"http://www.onvif.org/ver10/schema/Receiver"))
	{	if (a->Type)
		soap_set_attr(soap, "Type", soap_xsd__anyURI2s(soap, a->Type), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceReference), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_empty(soap, "tt:Token", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_in_tt__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SourceReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceReference(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Type", 4, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SourceReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceReference, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_new_tt__SourceReference(struct soap *soap, int n)
{
	struct tt__SourceReference *p;
	struct tt__SourceReference *a = (struct tt__SourceReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceReference));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_get_tt__SourceReference(struct soap *soap, struct tt__SourceReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverState(soap, &a->State);
	soap_default_xsd__boolean(soap, &a->AutoCreated);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoCreated, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverStateInformation(struct soap *soap, const char *tag, int id, const struct tt__ReceiverStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverStateInformation), type))
		return soap->error;
	if (soap_out_tt__ReceiverState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoCreated", -1, &a->AutoCreated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_in_tt__ReceiverStateInformation(struct soap *soap, const char *tag, struct tt__ReceiverStateInformation *a, const char *type)
{
	size_t soap_flag_State = 1;
	size_t soap_flag_AutoCreated = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ReceiverStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverStateInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReceiverState(soap, "tt:State", &a->State, "tt:ReceiverState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap_flag_AutoCreated && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:AutoCreated", &a->AutoCreated, "xsd:boolean"))
				{	soap_flag_AutoCreated--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0 || soap_flag_AutoCreated > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReceiverStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverStateInformation, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_new_tt__ReceiverStateInformation(struct soap *soap, int n)
{
	struct tt__ReceiverStateInformation *p;
	struct tt__ReceiverStateInformation *a = (struct tt__ReceiverStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReceiverStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverStateInformation(soap, tag ? tag : "tt:ReceiverStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_get_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverMode(soap, &a->Mode);
	soap_default_xsd__anyURI(soap, &a->MediaUri);
	a->StreamSetup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->MediaUri);
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReceiverConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (!a->MediaUri)
	{	if (soap_element_empty(soap, "tt:MediaUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:MediaUri", -1, (char*const*)&a->MediaUri, ""))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_empty(soap, "tt:StreamSetup", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StreamSetup(soap, "tt:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_in_tt__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_MediaUri = 1;
	size_t soap_flag_StreamSetup = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ReceiverConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReceiverMode(soap, "tt:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_MediaUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:MediaUri", (char**)&a->MediaUri, "xsd:anyURI"))
				{	soap_flag_MediaUri--;
					continue;
				}
			}
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StreamSetup(soap, "tt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || !a->MediaUri || !a->StreamSetup))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverConfiguration, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_new_tt__ReceiverConfiguration(struct soap *soap, int n)
{
	struct tt__ReceiverConfiguration *p;
	struct tt__ReceiverConfiguration *a = (struct tt__ReceiverConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReceiverConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_get_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Receiver(struct soap *soap, struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Receiver(struct soap *soap, const struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Receiver(struct soap *soap, const char *tag, int id, const struct tt__Receiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Receiver), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_empty(soap, "tt:Token", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tt:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_in_tt__Receiver(struct soap *soap, const char *tag, struct tt__Receiver *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Receiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Receiver(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token || !a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Receiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Receiver, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_new_tt__Receiver(struct soap *soap, int n)
{
	struct tt__Receiver *p;
	struct tt__Receiver *a = (struct tt__Receiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Receiver));
	for (p = a; p && n--; p++)
		soap_default_tt__Receiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Receiver(struct soap *soap, const struct tt__Receiver *a, const char *tag, const char *type)
{
	if (soap_out_tt__Receiver(soap, tag ? tag : "tt:Receiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_get_tt__Receiver(struct soap *soap, struct tt__Receiver *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneOptionExtension(struct soap *soap, const char *tag, int id, const struct tt__PaneOptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneOptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_in_tt__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PaneOptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneOptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneOptionExtension, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_new_tt__PaneOptionExtension(struct soap *soap, int n)
{
	struct tt__PaneOptionExtension *p;
	struct tt__PaneOptionExtension *a = (struct tt__PaneOptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneOptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneOptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_get_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_in_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LayoutOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptionsExtension, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_new_tt__LayoutOptionsExtension(struct soap *soap, int n)
{
	struct tt__LayoutOptionsExtension *p;
	struct tt__LayoutOptionsExtension *a = (struct tt__LayoutOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_get_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeArea = 0;
	a->Area = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Area)
	{	int i;
		for (i = 0; i < (int)a->__sizeArea; i++)
		{
			soap_embedded(soap, a->Area + i, SOAP_TYPE_tt__Rectangle);
			soap_serialize_tt__Rectangle(soap, a->Area + i);
		}
	}
	soap_serialize_PointerTott__PaneOptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__PaneLayoutOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayoutOptions), type))
		return soap->error;
	if (a->Area)
	{	int i;
		for (i = 0; i < (int)a->__sizeArea; i++)
			if (soap_out_tt__Rectangle(soap, "tt:Area", -1, a->Area + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PaneOptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_in_tt__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Area = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PaneLayoutOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayoutOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Area", 1, NULL))
			{	if (a->Area == NULL)
				{	if (soap_blist_Area == NULL)
						soap_blist_Area = soap_alloc_block(soap);
					a->Area = (struct tt__Rectangle *)soap_push_block_max(soap, soap_blist_Area, sizeof(struct tt__Rectangle));
					if (a->Area == NULL)
						return NULL;
					soap_default_tt__Rectangle(soap, a->Area);
				}
				soap_revert(soap);
				if (soap_in_tt__Rectangle(soap, "tt:Area", a->Area, "tt:Rectangle"))
				{	a->__sizeArea++;
					a->Area = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PaneOptionExtension(soap, "tt:Extension", &a->Extension, "tt:PaneOptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Area)
			soap_pop_block(soap, soap_blist_Area);
		if (a->__sizeArea)
		{	a->Area = (struct tt__Rectangle *)soap_save_block(soap, soap_blist_Area, NULL, 1);
		}
		else
		{	a->Area = NULL;
			if (soap_blist_Area)
				soap_end_block(soap, soap_blist_Area);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeArea < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_new_tt__PaneLayoutOptions(struct soap *soap, int n)
{
	struct tt__PaneLayoutOptions *p;
	struct tt__PaneLayoutOptions *a = (struct tt__PaneLayoutOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneLayoutOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneLayoutOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_get_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayoutOptions = 0;
	a->PaneLayoutOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayoutOptions; i++)
		{
			soap_embedded(soap, a->PaneLayoutOptions + i, SOAP_TYPE_tt__PaneLayoutOptions);
			soap_serialize_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions + i);
		}
	}
	soap_serialize_PointerTott__LayoutOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptions), type))
		return soap->error;
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayoutOptions; i++)
			if (soap_out_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", -1, a->PaneLayoutOptions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_in_tt__LayoutOptions(struct soap *soap, const char *tag, struct tt__LayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayoutOptions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LayoutOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayoutOptions", 1, NULL))
			{	if (a->PaneLayoutOptions == NULL)
				{	if (soap_blist_PaneLayoutOptions == NULL)
						soap_blist_PaneLayoutOptions = soap_alloc_block(soap);
					a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_push_block_max(soap, soap_blist_PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions));
					if (a->PaneLayoutOptions == NULL)
						return NULL;
					soap_default_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", a->PaneLayoutOptions, "tt:PaneLayoutOptions"))
				{	a->__sizePaneLayoutOptions++;
					a->PaneLayoutOptions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayoutOptions)
			soap_pop_block(soap, soap_blist_PaneLayoutOptions);
		if (a->__sizePaneLayoutOptions)
		{	a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_save_block(soap, soap_blist_PaneLayoutOptions, NULL, 1);
		}
		else
		{	a->PaneLayoutOptions = NULL;
			if (soap_blist_PaneLayoutOptions)
				soap_end_block(soap, soap_blist_PaneLayoutOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayoutOptions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__LayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptions, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_new_tt__LayoutOptions(struct soap *soap, int n)
{
	struct tt__LayoutOptions *p;
	struct tt__LayoutOptions *a = (struct tt__LayoutOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutOptions(soap, tag ? tag : "tt:LayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_get_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioEncodingCapabilities = NULL;
	a->AudioDecodingCapabilities = NULL;
	a->VideoDecodingCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &a->AudioEncodingCapabilities);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &a->AudioDecodingCapabilities);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptions(soap, &a->VideoDecodingCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CodingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__CodingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CodingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", -1, &a->AudioEncodingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", -1, &a->AudioDecodingCapabilities, ""))
		return soap->error;
	if (!a->VideoDecodingCapabilities)
	{	if (soap_element_empty(soap, "tt:VideoDecodingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", -1, &a->VideoDecodingCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_in_tt__CodingCapabilities(struct soap *soap, const char *tag, struct tt__CodingCapabilities *a, const char *type)
{
	size_t soap_flag_AudioEncodingCapabilities = 1;
	size_t soap_flag_AudioDecodingCapabilities = 1;
	size_t soap_flag_VideoDecodingCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CodingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CodingCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioEncodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", &a->AudioEncodingCapabilities, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_AudioEncodingCapabilities--;
					continue;
				}
			}
			if (soap_flag_AudioDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", &a->AudioDecodingCapabilities, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_AudioDecodingCapabilities--;
					continue;
				}
			}
			if (soap_flag_VideoDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", &a->VideoDecodingCapabilities, "tt:VideoDecoderConfigurationOptions"))
				{	soap_flag_VideoDecodingCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoDecodingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CodingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CodingCapabilities, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_new_tt__CodingCapabilities(struct soap *soap, int n)
{
	struct tt__CodingCapabilities *p;
	struct tt__CodingCapabilities *a = (struct tt__CodingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CodingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__CodingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__CodingCapabilities(soap, tag ? tag : "tt:CodingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_get_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_in_tt__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LayoutExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutExtension, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_new_tt__LayoutExtension(struct soap *soap, int n)
{
	struct tt__LayoutExtension *p;
	struct tt__LayoutExtension *a = (struct tt__LayoutExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_get_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Layout(struct soap *soap, struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayout = 0;
	a->PaneLayout = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Layout(struct soap *soap, const struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayout; i++)
		{
			soap_embedded(soap, a->PaneLayout + i, SOAP_TYPE_tt__PaneLayout);
			soap_serialize_tt__PaneLayout(soap, a->PaneLayout + i);
		}
	}
	soap_serialize_PointerTott__LayoutExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Layout(struct soap *soap, const char *tag, int id, const struct tt__Layout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Layout), type))
		return soap->error;
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayout; i++)
			if (soap_out_tt__PaneLayout(soap, "tt:PaneLayout", -1, a->PaneLayout + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_in_tt__Layout(struct soap *soap, const char *tag, struct tt__Layout *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayout = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Layout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Layout(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayout", 1, NULL))
			{	if (a->PaneLayout == NULL)
				{	if (soap_blist_PaneLayout == NULL)
						soap_blist_PaneLayout = soap_alloc_block(soap);
					a->PaneLayout = (struct tt__PaneLayout *)soap_push_block_max(soap, soap_blist_PaneLayout, sizeof(struct tt__PaneLayout));
					if (a->PaneLayout == NULL)
						return NULL;
					soap_default_tt__PaneLayout(soap, a->PaneLayout);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayout(soap, "tt:PaneLayout", a->PaneLayout, "tt:PaneLayout"))
				{	a->__sizePaneLayout++;
					a->PaneLayout = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LayoutExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayout)
			soap_pop_block(soap, soap_blist_PaneLayout);
		if (a->__sizePaneLayout)
		{	a->PaneLayout = (struct tt__PaneLayout *)soap_save_block(soap, soap_blist_PaneLayout, NULL, 1);
		}
		else
		{	a->PaneLayout = NULL;
			if (soap_blist_PaneLayout)
				soap_end_block(soap, soap_blist_PaneLayout);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayout < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Layout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Layout, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_new_tt__Layout(struct soap *soap, int n)
{
	struct tt__Layout *p;
	struct tt__Layout *a = (struct tt__Layout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Layout));
	for (p = a; p && n--; p++)
		soap_default_tt__Layout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Layout(struct soap *soap, const struct tt__Layout *a, const char *tag, const char *type)
{
	if (soap_out_tt__Layout(soap, tag ? tag : "tt:Layout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_get_tt__Layout(struct soap *soap, struct tt__Layout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Pane);
	a->Area = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Pane);
	soap_serialize_PointerTott__Rectangle(soap, &a->Area);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayout(struct soap *soap, const char *tag, int id, const struct tt__PaneLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayout), type))
		return soap->error;
	if (!a->Pane)
	{	if (soap_element_empty(soap, "tt:Pane", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:Pane", -1, (char*const*)&a->Pane, ""))
		return soap->error;
	if (!a->Area)
	{	if (soap_element_empty(soap, "tt:Area", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:Area", -1, &a->Area, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_in_tt__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout *a, const char *type)
{
	size_t soap_flag_Pane = 1;
	size_t soap_flag_Area = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PaneLayout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayout(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Pane", (char**)&a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			}
			if (soap_flag_Area && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Area", &a->Area, "tt:Rectangle"))
				{	soap_flag_Area--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Pane || !a->Area))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_new_tt__PaneLayout(struct soap *soap, int n)
{
	struct tt__PaneLayout *p;
	struct tt__PaneLayout *a = (struct tt__PaneLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneLayout));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_get_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PaneName);
	soap_default_tt__ReferenceToken(soap, &a->AudioOutputToken);
	soap_default_tt__ReferenceToken(soap, &a->AudioSourceToken);
	a->AudioEncoderConfiguration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->PaneName);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioOutputToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioSourceToken);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneConfiguration), type))
		return soap->error;
	if (soap_out_string(soap, "tt:PaneName", -1, (char*const*)&a->PaneName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioOutputToken", -1, (char*const*)&a->AudioOutputToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioSourceToken", -1, (char*const*)&a->AudioSourceToken, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_empty(soap, "tt:Token", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_in_tt__PaneConfiguration(struct soap *soap, const char *tag, struct tt__PaneConfiguration *a, const char *type)
{
	size_t soap_flag_PaneName = 1;
	size_t soap_flag_AudioOutputToken = 1;
	size_t soap_flag_AudioSourceToken = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:PaneName", (char**)&a->PaneName, "xsd:string"))
				{	soap_flag_PaneName--;
					continue;
				}
			}
			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:AudioOutputToken", (char**)&a->AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken--;
					continue;
				}
			}
			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:AudioSourceToken", (char**)&a->AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken--;
					continue;
				}
			}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneConfiguration, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
