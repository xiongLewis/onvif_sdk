/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingReference(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingReference(soap, tag ? tag : "tt:RecordingReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__RecordingReference(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceReference))
		soap_serialize_tt__SourceReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceReference(struct soap *soap, const char *tag, int id, struct tt__SourceReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_in_PointerTott__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceReference **)soap_malloc(soap, sizeof(struct tt__SourceReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_get_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
		soap_serialize_tt__StreamSetup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, struct tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StreamSetup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StreamSetup **)soap_malloc(soap, sizeof(struct tt__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StreamSetup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverConfiguration))
		soap_serialize_tt__ReceiverConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, int id, struct tt__ReceiverConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverConfiguration **)soap_malloc(soap, sizeof(struct tt__ReceiverConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneOptionExtension))
		soap_serialize_tt__PaneOptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, int id, struct tt__PaneOptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneOptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneOptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_in_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneOptionExtension **)soap_malloc(soap, sizeof(struct tt__PaneOptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneOptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_get_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptionsExtension))
		soap_serialize_tt__LayoutOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutOptionsExtension **)soap_malloc(soap, sizeof(struct tt__LayoutOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayoutOptions))
		soap_serialize_tt__PaneLayoutOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, struct tt__PaneLayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayoutOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayoutOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayoutOptions **)soap_malloc(soap, sizeof(struct tt__PaneLayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayoutOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions))
		soap_serialize_tt__VideoDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, tag ? tag : "tt:VideoDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions))
		soap_serialize_tt__AudioDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions))
		soap_serialize_tt__AudioEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutExtension))
		soap_serialize_tt__LayoutExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutExtension **)soap_malloc(soap, sizeof(struct tt__LayoutExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayout))
		soap_serialize_tt__PaneLayout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayout(struct soap *soap, const char *tag, int id, struct tt__PaneLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayout, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_in_PointerTott__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayout **)soap_malloc(soap, sizeof(struct tt__PaneLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_get_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		soap_serialize_tt__Transformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, struct tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Transformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, struct tt__Transformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transformation **)soap_malloc(soap, sizeof(struct tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, struct tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionExpression))
		soap_serialize_tt__MotionExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionExpression(struct soap *soap, const char *tag, int id, struct tt__MotionExpression *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_in_PointerTott__MotionExpression(struct soap *soap, const char *tag, struct tt__MotionExpression **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionExpression **)soap_malloc(soap, sizeof(struct tt__MotionExpression *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_get_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArray))
		soap_serialize_tt__PolylineArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArray(struct soap *soap, const char *tag, int id, struct tt__PolylineArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArray, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_in_PointerTott__PolylineArray(struct soap *soap, const char *tag, struct tt__PolylineArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArray **)soap_malloc(soap, sizeof(struct tt__PolylineArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_get_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArrayExtension))
		soap_serialize_tt__PolylineArrayExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, int id, struct tt__PolylineArrayExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArrayExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArrayExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_in_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, struct tt__PolylineArrayExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArrayExtension **)soap_malloc(soap, sizeof(struct tt__PolylineArrayExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArrayExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_get_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polyline))
		soap_serialize_tt__Polyline(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polyline(struct soap *soap, const char *tag, int id, struct tt__Polyline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polyline, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polyline(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_in_PointerTott__Polyline(struct soap *soap, const char *tag, struct tt__Polyline **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polyline **)soap_malloc(soap, sizeof(struct tt__Polyline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polyline(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polyline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polyline(soap, tag ? tag : "tt:Polyline", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_get_PointerTott__Polyline(struct soap *soap, struct tt__Polyline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension))
		soap_serialize_tt__SupportedAnalyticsModulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRulesExtension))
		soap_serialize_tt__SupportedRulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedRulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedRulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedRulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescription))
		soap_serialize_tt__ConfigDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, struct tt__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescription **)soap_malloc(soap, sizeof(struct tt__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescriptionExtension))
		soap_serialize_tt__ConfigDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ConfigDescription_Messages))
		soap_serialize__tt__ConfigDescription_Messages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, struct _tt__ConfigDescription_Messages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ConfigDescription_Messages, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ConfigDescription_Messages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_in_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ConfigDescription_Messages **)soap_malloc(soap, sizeof(struct _tt__ConfigDescription_Messages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ConfigDescription_Messages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ConfigDescription_Messages(soap, tag ? tag : "tt:ConfigDescription-Messages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_get_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		soap_serialize_tt__ItemList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, struct tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, struct tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemList **)soap_malloc(soap, sizeof(struct tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, struct tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		soap_serialize_tt__RuleEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, struct tt__Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		soap_serialize_tt__Config(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, struct tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Config(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, struct tt__Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Config **)soap_malloc(soap, sizeof(struct tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Config(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, struct tt__Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, struct tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		soap_serialize_tt__Vector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, struct tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, struct tt__Vector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector **)soap_malloc(soap, sizeof(struct tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, struct tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		soap_serialize_tt__ItemListDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		soap_serialize_tt__MessageDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescription))
		soap_serialize_tt__ItemListDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescription(struct soap *soap, const char *tag, int id, struct tt__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescription **)soap_malloc(soap, sizeof(struct tt__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		soap_serialize_tt__FocusOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(struct tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		soap_serialize_tt__WhiteBalanceOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		soap_serialize_tt__FocusConfiguration20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		soap_serialize_tt__WhiteBalance20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		soap_serialize_tt__RelativeFocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, int id, enum tt__BacklightCompensationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__BacklightCompensationMode **)soap_malloc(soap, sizeof(enum tt__BacklightCompensationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationMode(soap, tag ? tag : "tt:BacklightCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension))
		soap_serialize_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_malloc(soap, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension))
		soap_serialize_tt__ImageStabilizationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, int id, enum tt__ImageStabilizationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, enum tt__ImageStabilizationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ImageStabilizationMode **)soap_malloc(soap, sizeof(enum tt__ImageStabilizationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ImageStabilizationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationMode(soap, tag ? tag : "tt:ImageStabilizationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension4))
		soap_serialize_tt__ImagingOptions20Extension4(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension4, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension4(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension4 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension4(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReductionOptions))
		soap_serialize_tt__NoiseReductionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, int id, struct tt__NoiseReductionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReductionOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NoiseReductionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions ** SOAP_FMAC4 soap_in_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, struct tt__NoiseReductionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NoiseReductionOptions **)soap_malloc(soap, sizeof(struct tt__NoiseReductionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NoiseReductionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NoiseReductionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions ** SOAP_FMAC4 soap_get_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingOptions))
		soap_serialize_tt__DefoggingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, int id, struct tt__DefoggingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DefoggingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DefoggingOptions ** SOAP_FMAC4 soap_in_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, struct tt__DefoggingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DefoggingOptions **)soap_malloc(soap, sizeof(struct tt__DefoggingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DefoggingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DefoggingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingOptions ** SOAP_FMAC4 soap_get_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationOptions))
		soap_serialize_tt__ToneCompensationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, int id, struct tt__ToneCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ToneCompensationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, struct tt__ToneCompensationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ToneCompensationOptions **)soap_malloc(soap, sizeof(struct tt__ToneCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ToneCompensationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension3))
		soap_serialize_tt__ImagingOptions20Extension3(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension3, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension3(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension3 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension3(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions))
		soap_serialize_tt__IrCutFilterAutoAdjustmentOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, struct tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IrCutFilterAutoAdjustmentOptions **)soap_malloc(soap, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension2))
		soap_serialize_tt__ImagingOptions20Extension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension2 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptions))
		soap_serialize_tt__ImageStabilizationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationOptions **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension))
		soap_serialize_tt__ImagingOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20))
		soap_serialize_tt__WhiteBalanceOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions20))
		soap_serialize_tt__WideDynamicRangeOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(struct tt__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRangeOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20))
		soap_serialize_tt__FocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap *soap, const char *tag, struct tt__FocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20 **)soap_malloc(soap, sizeof(struct tt__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions20))
		soap_serialize_tt__ExposureOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, int id, struct tt__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, struct tt__ExposureOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ExposureOptions20 **)soap_malloc(soap, sizeof(struct tt__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions20))
		soap_serialize_tt__BacklightCompensationOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(struct tt__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingExtension))
		soap_serialize_tt__DefoggingExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, int id, struct tt__DefoggingExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DefoggingExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DefoggingExtension ** SOAP_FMAC4 soap_in_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, struct tt__DefoggingExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DefoggingExtension **)soap_malloc(soap, sizeof(struct tt__DefoggingExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DefoggingExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DefoggingExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingExtension ** SOAP_FMAC4 soap_get_PointerTott__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationExtension))
		soap_serialize_tt__ToneCompensationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, int id, struct tt__ToneCompensationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ToneCompensationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, struct tt__ToneCompensationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ToneCompensationExtension **)soap_malloc(soap, sizeof(struct tt__ToneCompensationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ToneCompensationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension))
		soap_serialize_tt__IrCutFilterAutoAdjustmentExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, struct tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IrCutFilterAutoAdjustmentExtension **)soap_malloc(soap, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationExtension))
		soap_serialize_tt__ImageStabilizationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationExtension **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension204(struct soap *soap, struct tt__ImagingSettingsExtension204 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension204))
		soap_serialize_tt__ImagingSettingsExtension204(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension204 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension204, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension204(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension204 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension204 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension204 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension204(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension204 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension204(struct soap *soap, struct tt__ImagingSettingsExtension204 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension204(struct soap *soap, struct tt__ImagingSettingsExtension204 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReduction(struct soap *soap, struct tt__NoiseReduction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReduction))
		soap_serialize_tt__NoiseReduction(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReduction(struct soap *soap, const char *tag, int id, struct tt__NoiseReduction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReduction, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NoiseReduction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NoiseReduction ** SOAP_FMAC4 soap_in_PointerTott__NoiseReduction(struct soap *soap, const char *tag, struct tt__NoiseReduction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NoiseReduction **)soap_malloc(soap, sizeof(struct tt__NoiseReduction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NoiseReduction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NoiseReduction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReduction(struct soap *soap, struct tt__NoiseReduction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReduction ** SOAP_FMAC4 soap_get_PointerTott__NoiseReduction(struct soap *soap, struct tt__NoiseReduction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Defogging(struct soap *soap, struct tt__Defogging *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Defogging))
		soap_serialize_tt__Defogging(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Defogging(struct soap *soap, const char *tag, int id, struct tt__Defogging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Defogging, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Defogging(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Defogging ** SOAP_FMAC4 soap_in_PointerTott__Defogging(struct soap *soap, const char *tag, struct tt__Defogging **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Defogging **)soap_malloc(soap, sizeof(struct tt__Defogging *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Defogging(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Defogging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Defogging(struct soap *soap, struct tt__Defogging *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Defogging(soap, tag ? tag : "tt:Defogging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Defogging ** SOAP_FMAC4 soap_get_PointerTott__Defogging(struct soap *soap, struct tt__Defogging **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensation(struct soap *soap, struct tt__ToneCompensation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensation))
		soap_serialize_tt__ToneCompensation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensation(struct soap *soap, const char *tag, int id, struct tt__ToneCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ToneCompensation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ToneCompensation ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensation(struct soap *soap, const char *tag, struct tt__ToneCompensation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ToneCompensation **)soap_malloc(soap, sizeof(struct tt__ToneCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ToneCompensation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ToneCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensation(struct soap *soap, struct tt__ToneCompensation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensation ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensation(struct soap *soap, struct tt__ToneCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension203(struct soap *soap, struct tt__ImagingSettingsExtension203 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension203))
		soap_serialize_tt__ImagingSettingsExtension203(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension203 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension203, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension203(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension203 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension203 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension203 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension203(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension203 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension203(struct soap *soap, struct tt__ImagingSettingsExtension203 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension203(struct soap *soap, struct tt__ImagingSettingsExtension203 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, struct tt__IrCutFilterAutoAdjustment *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment))
		soap_serialize_tt__IrCutFilterAutoAdjustment(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, struct tt__IrCutFilterAutoAdjustment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterAutoAdjustment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustment **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IrCutFilterAutoAdjustment **)soap_malloc(soap, sizeof(struct tt__IrCutFilterAutoAdjustment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, struct tt__IrCutFilterAutoAdjustment *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, struct tt__IrCutFilterAutoAdjustment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension202))
		soap_serialize_tt__ImagingSettingsExtension202(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension202 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension202, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension202(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension202 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension202 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension202 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension202(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension202 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilization))
		soap_serialize_tt__ImageStabilization(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilization(struct soap *soap, const char *tag, int id, struct tt__ImageStabilization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilization, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilization(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilization ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilization(struct soap *soap, const char *tag, struct tt__ImageStabilization **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilization **)soap_malloc(soap, sizeof(struct tt__ImageStabilization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilization(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilization ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
		soap_serialize_tt__ImagingSettingsExtension20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
		soap_serialize_tt__WhiteBalance20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20 **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
		soap_serialize_tt__WideDynamicRange20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRange20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(struct tt__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRange20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
		soap_serialize_tt__FocusConfiguration20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
		soap_serialize_tt__Exposure20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, struct tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Exposure20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Exposure20 **)soap_malloc(soap, sizeof(struct tt__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Exposure20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
		soap_serialize_tt__BacklightCompensation20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensation20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(struct tt__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensation20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20Extension))
		soap_serialize_tt__FocusStatus20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, struct tt__FocusStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(struct tt__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20Extension))
		soap_serialize_tt__ImagingStatus20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, struct tt__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, struct tt__ImagingStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(struct tt__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20))
		soap_serialize_tt__FocusStatus20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap *soap, const char *tag, int id, struct tt__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap *soap, const char *tag, struct tt__FocusStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus20 **)soap_malloc(soap, sizeof(struct tt__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocusOptions))
		soap_serialize_tt__ContinuousFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, struct tt__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, struct tt__ContinuousFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(struct tt__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ContinuousFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions))
		soap_serialize_tt__RelativeFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions(soap, tag ? tag : "tt:RelativeFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocusOptions))
		soap_serialize_tt__AbsoluteFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, struct tt__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct tt__AbsoluteFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(struct tt__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AbsoluteFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocus))
		soap_serialize_tt__ContinuousFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, int id, struct tt__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ContinuousFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, struct tt__ContinuousFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ContinuousFocus **)soap_malloc(soap, sizeof(struct tt__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ContinuousFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocus))
		soap_serialize_tt__RelativeFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap *soap, const char *tag, int id, struct tt__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap *soap, const char *tag, struct tt__RelativeFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocus **)soap_malloc(soap, sizeof(struct tt__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocus))
		soap_serialize_tt__AbsoluteFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, int id, struct tt__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AbsoluteFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, struct tt__AbsoluteFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AbsoluteFocus **)soap_malloc(soap, sizeof(struct tt__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AbsoluteFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceMode(struct soap *soap, const char *tag, int id, enum tt__WhiteBalanceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__WhiteBalanceMode **)soap_malloc(soap, sizeof(enum tt__WhiteBalanceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__WhiteBalanceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceMode(soap, tag ? tag : "tt:WhiteBalanceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, enum tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposurePriority **)soap_malloc(soap, sizeof(enum tt__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposurePriority(soap, tag ? tag : "tt:ExposurePriority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ExposureMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureMode(struct soap *soap, const char *tag, int id, enum tt__ExposureMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposureMode ** SOAP_FMAC4 soap_in_PointerTott__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposureMode **)soap_malloc(soap, sizeof(enum tt__ExposureMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposureMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposureMode(soap, tag ? tag : "tt:ExposureMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode ** SOAP_FMAC4 soap_get_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AutoFocusMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AutoFocusMode(struct soap *soap, const char *tag, int id, enum tt__AutoFocusMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AutoFocusMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AutoFocusMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__AutoFocusMode ** SOAP_FMAC4 soap_in_PointerTott__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__AutoFocusMode **)soap_malloc(soap, sizeof(enum tt__AutoFocusMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AutoFocusMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__AutoFocusMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AutoFocusMode(soap, tag ? tag : "tt:AutoFocusMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode ** SOAP_FMAC4 soap_get_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicMode(struct soap *soap, const char *tag, int id, enum tt__WideDynamicMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__WideDynamicMode ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__WideDynamicMode **)soap_malloc(soap, sizeof(enum tt__WideDynamicMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__WideDynamicMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicMode(soap, tag ? tag : "tt:WideDynamicMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions))
		soap_serialize_tt__WhiteBalanceOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions(soap, tag ? tag : "tt:WhiteBalanceOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions))
		soap_serialize_tt__WideDynamicRangeOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRangeOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRangeOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRangeOptions **)soap_malloc(soap, sizeof(struct tt__WideDynamicRangeOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRangeOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRangeOptions(soap, tag ? tag : "tt:WideDynamicRangeOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions))
		soap_serialize_tt__FocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions(struct soap *soap, const char *tag, int id, struct tt__FocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions(struct soap *soap, const char *tag, struct tt__FocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions **)soap_malloc(soap, sizeof(struct tt__FocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions(soap, tag ? tag : "tt:FocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions))
		soap_serialize_tt__ExposureOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions(struct soap *soap, const char *tag, int id, struct tt__ExposureOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ExposureOptions ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions(struct soap *soap, const char *tag, struct tt__ExposureOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ExposureOptions **)soap_malloc(soap, sizeof(struct tt__ExposureOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposureOptions(soap, tag ? tag : "tt:ExposureOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions))
		soap_serialize_tt__BacklightCompensationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensationOptions **)soap_malloc(soap, sizeof(struct tt__BacklightCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationOptions(soap, tag ? tag : "tt:BacklightCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
		soap_serialize_tt__Rectangle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, struct tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rectangle **)soap_malloc(soap, sizeof(struct tt__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension))
		soap_serialize_tt__ImagingSettingsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, tag ? tag : "tt:ImagingSettingsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance))
		soap_serialize_tt__WhiteBalance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance(struct soap *soap, const char *tag, struct tt__WhiteBalance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance **)soap_malloc(soap, sizeof(struct tt__WhiteBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance(soap, tag ? tag : "tt:WhiteBalance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange))
		soap_serialize_tt__WideDynamicRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRange ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, struct tt__WideDynamicRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRange **)soap_malloc(soap, sizeof(struct tt__WideDynamicRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRange(soap, tag ? tag : "tt:WideDynamicRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IrCutFilterMode **)soap_malloc(soap, sizeof(enum tt__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag ? tag : "tt:IrCutFilterMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration))
		soap_serialize_tt__FocusConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, struct tt__FocusConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration(soap, tag ? tag : "tt:FocusConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure(struct soap *soap, struct tt__Exposure *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure))
		soap_serialize_tt__Exposure(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure(struct soap *soap, const char *tag, int id, struct tt__Exposure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Exposure(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Exposure ** SOAP_FMAC4 soap_in_PointerTott__Exposure(struct soap *soap, const char *tag, struct tt__Exposure **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Exposure **)soap_malloc(soap, sizeof(struct tt__Exposure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Exposure(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure(struct soap *soap, struct tt__Exposure *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Exposure(soap, tag ? tag : "tt:Exposure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure ** SOAP_FMAC4 soap_get_PointerTott__Exposure(struct soap *soap, struct tt__Exposure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation))
		soap_serialize_tt__BacklightCompensation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensation ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, struct tt__BacklightCompensation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensation **)soap_malloc(soap, sizeof(struct tt__BacklightCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensation(soap, tag ? tag : "tt:BacklightCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus))
		soap_serialize_tt__FocusStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus(struct soap *soap, const char *tag, int id, struct tt__FocusStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus(struct soap *soap, const char *tag, struct tt__FocusStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus **)soap_malloc(soap, sizeof(struct tt__FocusStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus(soap, tag ? tag : "tt:FocusStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension))
		soap_serialize_tt__PTZPresetTourStartingConditionOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension))
		soap_serialize_tt__PTZPresetTourPresetDetailOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetailOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions))
		soap_serialize_tt__PTZPresetTourPresetDetailOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetailOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetailOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetailOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotOptions))
		soap_serialize_tt__PTZPresetTourSpotOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpotOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpotOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpotOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpotOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpotOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, tag ? tag : "tt:PTZPresetTourSpotOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions))
		soap_serialize_tt__PTZPresetTourStartingConditionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension))
		soap_serialize_tt__PTZPresetTourStartingConditionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourDirection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, enum tt__PTZPresetTourDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourDirection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourDirection(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, enum tt__PTZPresetTourDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PTZPresetTourDirection **)soap_malloc(soap, sizeof(enum tt__PTZPresetTourDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourDirection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, tag ? tag : "tt:PTZPresetTourDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatusExtension))
		soap_serialize_tt__PTZPresetTourStatusExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatusExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStatusExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatusExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStatusExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStatusExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, tag ? tag : "tt:PTZPresetTourStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourTypeExtension))
		soap_serialize_tt__PTZPresetTourTypeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourTypeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourTypeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourTypeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourTypeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourTypeExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourTypeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourTypeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotExtension))
		soap_serialize_tt__PTZPresetTourSpotExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpotExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpotExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpotExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpotExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		soap_serialize_tt__PTZSpeed(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, struct tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpeed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpeed **)soap_malloc(soap, sizeof(struct tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpeed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetail))
		soap_serialize_tt__PTZPresetTourPresetDetail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetail **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourExtension))
		soap_serialize_tt__PTZPresetTourExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpot))
		soap_serialize_tt__PTZPresetTourSpot(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpot, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpot **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingCondition))
		soap_serialize_tt__PTZPresetTourStartingCondition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingCondition, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingCondition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingCondition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingCondition **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatus))
		soap_serialize_tt__PTZPresetTourStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStatus **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZVector))
		soap_serialize_tt__PTZVector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZVector(struct soap *soap, const char *tag, int id, struct tt__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZVector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZVector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_in_PointerTott__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZVector **)soap_malloc(soap, sizeof(struct tt__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZVector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_get_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		soap_serialize_tt__Vector1D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, struct tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector1D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector1D **)soap_malloc(soap, sizeof(struct tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector1D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		soap_serialize_tt__Vector2D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, struct tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector2D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector2D **)soap_malloc(soap, sizeof(struct tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector2D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpacesExtension))
		soap_serialize_tt__PTZSpacesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, int id, struct tt__PTZSpacesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpacesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpacesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, struct tt__PTZSpacesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpacesExtension **)soap_malloc(soap, sizeof(struct tt__PTZSpacesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpacesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		soap_serialize_tt__Space1DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, struct tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space1DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space1DDescription **)soap_malloc(soap, sizeof(struct tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space1DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		soap_serialize_tt__Space2DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, struct tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space2DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space2DDescription **)soap_malloc(soap, sizeof(struct tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space2DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptionsExtension))
		soap_serialize_tt__ReverseOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__ReverseOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, struct tt__ReverseOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReverseOptionsExtension **)soap_malloc(soap, sizeof(struct tt__ReverseOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReverseMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseMode(struct soap *soap, const char *tag, int id, enum tt__ReverseMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ReverseMode ** SOAP_FMAC4 soap_in_PointerTott__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ReverseMode **)soap_malloc(soap, sizeof(enum tt__ReverseMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReverseMode(soap, tag ? tag : "tt:ReverseMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode ** SOAP_FMAC4 soap_get_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptionsExtension))
		soap_serialize_tt__EFlipOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__EFlipOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, struct tt__EFlipOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlipOptionsExtension **)soap_malloc(soap, sizeof(struct tt__EFlipOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__EFlipMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipMode(struct soap *soap, const char *tag, int id, enum tt__EFlipMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__EFlipMode ** SOAP_FMAC4 soap_in_PointerTott__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__EFlipMode **)soap_malloc(soap, sizeof(enum tt__EFlipMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlipMode(soap, tag ? tag : "tt:EFlipMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode ** SOAP_FMAC4 soap_get_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension))
		soap_serialize_tt__PTControlDirectionOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptions))
		soap_serialize_tt__ReverseOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptions(struct soap *soap, const char *tag, int id, struct tt__ReverseOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReverseOptions ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptions(struct soap *soap, const char *tag, struct tt__ReverseOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReverseOptions **)soap_malloc(soap, sizeof(struct tt__ReverseOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptions ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptions))
		soap_serialize_tt__EFlipOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptions(struct soap *soap, const char *tag, int id, struct tt__EFlipOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlipOptions ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptions(struct soap *soap, const char *tag, struct tt__EFlipOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlipOptions **)soap_malloc(soap, sizeof(struct tt__EFlipOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptions ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions2))
		soap_serialize_tt__PTZConfigurationOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationOptions2 **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptions))
		soap_serialize_tt__PTControlDirectionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionOptions **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		soap_serialize_tt__DurationRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, struct tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DurationRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, struct tt__DurationRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DurationRange **)soap_malloc(soap, sizeof(struct tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DurationRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpaces))
		soap_serialize_tt__PTZSpaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpaces(struct soap *soap, const char *tag, int id, struct tt__PTZSpaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpaces, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpaces ** SOAP_FMAC4 soap_in_PointerTott__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpaces **)soap_malloc(soap, sizeof(struct tt__PTZSpaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces ** SOAP_FMAC4 soap_get_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionExtension))
		soap_serialize_tt__PTControlDirectionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap *soap, struct tt__Reverse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Reverse))
		soap_serialize_tt__Reverse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap *soap, const char *tag, int id, struct tt__Reverse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Reverse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Reverse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap *soap, const char *tag, struct tt__Reverse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Reverse **)soap_malloc(soap, sizeof(struct tt__Reverse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Reverse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap *soap, struct tt__Reverse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap *soap, struct tt__Reverse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap *soap, struct tt__EFlip *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlip))
		soap_serialize_tt__EFlip(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap *soap, const char *tag, int id, struct tt__EFlip *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlip, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlip(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap *soap, const char *tag, struct tt__EFlip **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlip **)soap_malloc(soap, sizeof(struct tt__EFlip *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlip(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap *soap, struct tt__EFlip *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap *soap, struct tt__EFlip **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension2))
		soap_serialize_tt__PTZConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirection))
		soap_serialize_tt__PTControlDirection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap *soap, const char *tag, int id, struct tt__PTControlDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap *soap, const char *tag, struct tt__PTControlDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirection **)soap_malloc(soap, sizeof(struct tt__PTControlDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension))
		soap_serialize_tt__PTZPresetTourSupportedExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSupportedExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSupportedExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupportedExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSupportedExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSupportedExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupportedExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, enum tt__PTZPresetTourOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOperation(struct soap *soap, const char *tag, enum tt__PTZPresetTourOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PTZPresetTourOperation **)soap_malloc(soap, sizeof(enum tt__PTZPresetTourOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourOperation(soap, tag ? tag : "tt:PTZPresetTourOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension2))
		soap_serialize_tt__PTZNodeExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, struct tt__PTZNodeExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension2 **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupported))
		soap_serialize_tt__PTZPresetTourSupported(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSupported *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupported, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSupported(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupported **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSupported **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSupported *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSupported(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupported **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EapMethodExtension))
		soap_serialize_tt__EapMethodExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, int id, struct tt__EapMethodExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EapMethodExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EapMethodExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EapMethodExtension ** SOAP_FMAC4 soap_in_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, struct tt__EapMethodExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EapMethodExtension **)soap_malloc(soap, sizeof(struct tt__EapMethodExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EapMethodExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EapMethodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EapMethodExtension ** SOAP_FMAC4 soap_get_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TLSConfiguration))
		soap_serialize_tt__TLSConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, int id, struct tt__TLSConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TLSConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TLSConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TLSConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, struct tt__TLSConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TLSConfiguration **)soap_malloc(soap, sizeof(struct tt__TLSConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TLSConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TLSConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TLSConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfigurationExtension))
		soap_serialize_tt__Dot1XConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__Dot1XConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot1XConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot1XConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot1XConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__Dot1XConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot1XConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EAPMethodConfiguration))
		soap_serialize_tt__EAPMethodConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, struct tt__EAPMethodConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EAPMethodConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EAPMethodConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, struct tt__EAPMethodConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EAPMethodConfiguration **)soap_malloc(soap, sizeof(struct tt__EAPMethodConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EAPMethodConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EAPMethodConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformationExtension))
		soap_serialize_tt__CertificateInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, int id, struct tt__CertificateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, struct tt__CertificateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateInformationExtension **)soap_malloc(soap, sizeof(struct tt__CertificateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTimeRange))
		soap_serialize_tt__DateTimeRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTimeRange(struct soap *soap, const char *tag, int id, struct tt__DateTimeRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTimeRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTimeRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTimeRange ** SOAP_FMAC4 soap_in_PointerTott__DateTimeRange(struct soap *soap, const char *tag, struct tt__DateTimeRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DateTimeRange **)soap_malloc(soap, sizeof(struct tt__DateTimeRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DateTimeRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTimeRange ** SOAP_FMAC4 soap_get_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateUsage))
		soap_serialize_tt__CertificateUsage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateUsage(struct soap *soap, const char *tag, int id, struct tt__CertificateUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateUsage, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateUsage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateUsage ** SOAP_FMAC4 soap_in_PointerTott__CertificateUsage(struct soap *soap, const char *tag, struct tt__CertificateUsage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateUsage **)soap_malloc(soap, sizeof(struct tt__CertificateUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateUsage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateUsage ** SOAP_FMAC4 soap_get_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateGenerationParametersExtension))
		soap_serialize_tt__CertificateGenerationParametersExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, struct tt__CertificateGenerationParametersExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateGenerationParametersExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateGenerationParametersExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct tt__CertificateGenerationParametersExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateGenerationParametersExtension **)soap_malloc(soap, sizeof(struct tt__CertificateGenerationParametersExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParametersExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, tag ? tag : "tt:CertificateGenerationParametersExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		soap_serialize_tt__UserExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, struct tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__UserExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__UserExtension **)soap_malloc(soap, sizeof(struct tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__UserExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, struct tt__Date *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		soap_serialize_tt__Date(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, struct tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Date(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, struct tt__Date **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Date **)soap_malloc(soap, sizeof(struct tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, struct tt__Date *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Date(soap, tag ? tag : "tt:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, struct tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, struct tt__Time *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		soap_serialize_tt__Time(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, struct tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Time(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, struct tt__Time **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Time **)soap_malloc(soap, sizeof(struct tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, struct tt__Time *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Time(soap, tag ? tag : "tt:Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, struct tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		soap_serialize_tt__SystemDateTimeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, struct tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(struct tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTimeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUri))
		soap_serialize_tt__SystemLogUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, struct tt__SystemLogUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUri ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUri(struct soap *soap, const char *tag, struct tt__SystemLogUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUri **)soap_malloc(soap, sizeof(struct tt__SystemLogUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUri ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceExtension))
		soap_serialize_tt__AnalyticsDeviceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension2))
		soap_serialize_tt__SystemCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		soap_serialize_tt__SystemCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2))
		soap_serialize_tt__SecurityCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		soap_serialize_tt__SecurityCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2))
		soap_serialize_tt__NetworkCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		soap_serialize_tt__NetworkCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		soap_serialize_tt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		soap_serialize_tt__MediaCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		soap_serialize_tt__RealTimeStreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension2))
		soap_serialize_tt__IOCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AuxiliaryData(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData))
		soap_serialize_tt__AuxiliaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AuxiliaryData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AuxiliaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AuxiliaryData(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__AuxiliaryData(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		soap_serialize_tt__IOCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		soap_serialize_tt__DeviceCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		soap_serialize_tt__SecurityCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		soap_serialize_tt__IOCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, struct tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilities **)soap_malloc(soap, sizeof(struct tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		soap_serialize_tt__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilities **)soap_malloc(soap, sizeof(struct tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		soap_serialize_tt__NetworkCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension2))
		soap_serialize_tt__CapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities))
		soap_serialize_tt__AnalyticsDeviceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverCapabilities))
		soap_serialize_tt__ReceiverCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReceiverCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(struct tt__ReceiverCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayCapabilities))
		soap_serialize_tt__ReplayCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReplayCapabilities **)soap_malloc(soap, sizeof(struct tt__ReplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReplayCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchCapabilities))
		soap_serialize_tt__SearchCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, int id, struct tt__SearchCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchCapabilities **)soap_malloc(soap, sizeof(struct tt__SearchCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
