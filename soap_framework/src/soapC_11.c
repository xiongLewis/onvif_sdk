/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_new_tt__PaneConfiguration(struct soap *soap, int n)
{
	struct tt__PaneConfiguration *p;
	struct tt__PaneConfiguration *a = (struct tt__PaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneConfiguration(soap, tag ? tag : "tt:PaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_get_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transformation(struct soap *soap, struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Translate = NULL;
	a->Scale = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transformation(struct soap *soap, const struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector(soap, &a->Translate);
	soap_serialize_PointerTott__Vector(soap, &a->Scale);
	soap_serialize_PointerTott__TransformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transformation(struct soap *soap, const char *tag, int id, const struct tt__Transformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transformation), type))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Translate", -1, &a->Translate, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Scale", -1, &a->Scale, ""))
		return soap->error;
	if (soap_out_PointerTott__TransformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_in_tt__Transformation(struct soap *soap, const char *tag, struct tt__Transformation *a, const char *type)
{
	size_t soap_flag_Translate = 1;
	size_t soap_flag_Scale = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Transformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Transformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Translate", &a->Translate, "tt:Vector"))
				{	soap_flag_Translate--;
					continue;
				}
			}
			if (soap_flag_Scale && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Scale", &a->Scale, "tt:Vector"))
				{	soap_flag_Scale--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TransformationExtension(soap, "tt:Extension", &a->Extension, "tt:TransformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_new_tt__Transformation(struct soap *soap, int n)
{
	struct tt__Transformation *p;
	struct tt__Transformation *a = (struct tt__Transformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Transformation));
	for (p = a; p && n--; p++)
		soap_default_tt__Transformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transformation(struct soap *soap, const struct tt__Transformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_get_tt__Transformation(struct soap *soap, struct tt__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CellLayout(struct soap *soap, struct tt__CellLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	soap_default_xsd__integer(soap, &a->Columns);
	soap_default_xsd__integer(soap, &a->Rows);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CellLayout(struct soap *soap, const struct tt__CellLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CellLayout(struct soap *soap, const char *tag, int id, const struct tt__CellLayout *a, const char *type)
{
	soap_set_attr(soap, "Columns", a->Columns ? soap_xsd__integer2s(soap, a->Columns) : "", 1);
	soap_set_attr(soap, "Rows", a->Rows ? soap_xsd__integer2s(soap, a->Rows) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CellLayout), type))
		return soap->error;
	if (!a->Transformation)
	{	if (soap_element_empty(soap, "tt:Transformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_in_tt__CellLayout(struct soap *soap, const char *tag, struct tt__CellLayout *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CellLayout*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CellLayout(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Columns", 5, 1), &a->Columns))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Rows", 5, 1), &a->Rows))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Transformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CellLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CellLayout, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_new_tt__CellLayout(struct soap *soap, int n)
{
	struct tt__CellLayout *p;
	struct tt__CellLayout *a = (struct tt__CellLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CellLayout));
	for (p = a; p && n--; p++)
		soap_default_tt__CellLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CellLayout(struct soap *soap, const struct tt__CellLayout *a, const char *tag, const char *type)
{
	if (soap_out_tt__CellLayout(soap, tag ? tag : "tt:CellLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_get_tt__CellLayout(struct soap *soap, struct tt__CellLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CellLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionExpressionConfiguration(struct soap *soap, struct tt__MotionExpressionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MotionExpression = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionExpressionConfiguration(struct soap *soap, const struct tt__MotionExpressionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MotionExpression(soap, &a->MotionExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MotionExpressionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpressionConfiguration), type))
		return soap->error;
	if (!a->MotionExpression)
	{	if (soap_element_empty(soap, "tt:MotionExpression", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MotionExpression(soap, "tt:MotionExpression", -1, &a->MotionExpression, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_in_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, struct tt__MotionExpressionConfiguration *a, const char *type)
{
	size_t soap_flag_MotionExpression = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MotionExpressionConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionExpressionConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MotionExpression && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MotionExpression(soap, "tt:MotionExpression", &a->MotionExpression, "tt:MotionExpression"))
				{	soap_flag_MotionExpression--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MotionExpression))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MotionExpressionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpressionConfiguration, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_new_tt__MotionExpressionConfiguration(struct soap *soap, int n)
{
	struct tt__MotionExpressionConfiguration *p;
	struct tt__MotionExpressionConfiguration *a = (struct tt__MotionExpressionConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionExpressionConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionExpressionConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionExpressionConfiguration(struct soap *soap, const struct tt__MotionExpressionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionExpressionConfiguration(soap, tag ? tag : "tt:MotionExpressionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_get_tt__MotionExpressionConfiguration(struct soap *soap, struct tt__MotionExpressionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpressionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionExpression(struct soap *soap, struct tt__MotionExpression *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Expression);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionExpression(struct soap *soap, const struct tt__MotionExpression *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Expression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpression(struct soap *soap, const char *tag, int id, const struct tt__MotionExpression *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpression), type))
		return soap->error;
	if (!a->Expression)
	{	if (soap_element_empty(soap, "tt:Expression", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Expression", -1, (char*const*)&a->Expression, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_in_tt__MotionExpression(struct soap *soap, const char *tag, struct tt__MotionExpression *a, const char *type)
{
	size_t soap_flag_Expression = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MotionExpression*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionExpression(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1, 0), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Expression && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Expression", (char**)&a->Expression, "xsd:string"))
				{	soap_flag_Expression--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Expression))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MotionExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpression, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_new_tt__MotionExpression(struct soap *soap, int n)
{
	struct tt__MotionExpression *p;
	struct tt__MotionExpression *a = (struct tt__MotionExpression*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionExpression));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionExpression(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionExpression(struct soap *soap, const struct tt__MotionExpression *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_get_tt__MotionExpression(struct soap *soap, struct tt__MotionExpression *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArrayConfiguration(struct soap *soap, struct tt__PolylineArrayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolylineArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArrayConfiguration(struct soap *soap, const struct tt__PolylineArrayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PolylineArray(soap, &a->PolylineArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PolylineArrayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayConfiguration), type))
		return soap->error;
	if (!a->PolylineArray)
	{	if (soap_element_empty(soap, "tt:PolylineArray", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PolylineArray(soap, "tt:PolylineArray", -1, &a->PolylineArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_in_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, struct tt__PolylineArrayConfiguration *a, const char *type)
{
	size_t soap_flag_PolylineArray = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PolylineArrayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArrayConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolylineArray && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PolylineArray(soap, "tt:PolylineArray", &a->PolylineArray, "tt:PolylineArray"))
				{	soap_flag_PolylineArray--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolylineArray))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayConfiguration, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_new_tt__PolylineArrayConfiguration(struct soap *soap, int n)
{
	struct tt__PolylineArrayConfiguration *p;
	struct tt__PolylineArrayConfiguration *a = (struct tt__PolylineArrayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArrayConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArrayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArrayConfiguration(struct soap *soap, const struct tt__PolylineArrayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArrayConfiguration(soap, tag ? tag : "tt:PolylineArrayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_get_tt__PolylineArrayConfiguration(struct soap *soap, struct tt__PolylineArrayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArrayExtension(struct soap *soap, const struct tt__PolylineArrayExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayExtension(struct soap *soap, const char *tag, int id, const struct tt__PolylineArrayExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_in_tt__PolylineArrayExtension(struct soap *soap, const char *tag, struct tt__PolylineArrayExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PolylineArrayExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArrayExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayExtension, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_new_tt__PolylineArrayExtension(struct soap *soap, int n)
{
	struct tt__PolylineArrayExtension *p;
	struct tt__PolylineArrayExtension *a = (struct tt__PolylineArrayExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArrayExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArrayExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArrayExtension(struct soap *soap, const struct tt__PolylineArrayExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_get_tt__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArray(struct soap *soap, struct tt__PolylineArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSegment = 0;
	a->Segment = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArray(struct soap *soap, const struct tt__PolylineArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Segment)
	{	int i;
		for (i = 0; i < (int)a->__sizeSegment; i++)
		{
			soap_embedded(soap, a->Segment + i, SOAP_TYPE_tt__Polyline);
			soap_serialize_tt__Polyline(soap, a->Segment + i);
		}
	}
	soap_serialize_PointerTott__PolylineArrayExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArray(struct soap *soap, const char *tag, int id, const struct tt__PolylineArray *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArray), type))
		return soap->error;
	if (a->Segment)
	{	int i;
		for (i = 0; i < (int)a->__sizeSegment; i++)
			if (soap_out_tt__Polyline(soap, "tt:Segment", -1, a->Segment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PolylineArrayExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_in_tt__PolylineArray(struct soap *soap, const char *tag, struct tt__PolylineArray *a, const char *type)
{
	struct soap_blist *soap_blist_Segment = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PolylineArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArray(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Segment", 1, NULL))
			{	if (a->Segment == NULL)
				{	if (soap_blist_Segment == NULL)
						soap_blist_Segment = soap_alloc_block(soap);
					a->Segment = (struct tt__Polyline *)soap_push_block_max(soap, soap_blist_Segment, sizeof(struct tt__Polyline));
					if (a->Segment == NULL)
						return NULL;
					soap_default_tt__Polyline(soap, a->Segment);
				}
				soap_revert(soap);
				if (soap_in_tt__Polyline(soap, "tt:Segment", a->Segment, "tt:Polyline"))
				{	a->__sizeSegment++;
					a->Segment = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PolylineArrayExtension(soap, "tt:Extension", &a->Extension, "tt:PolylineArrayExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Segment)
			soap_pop_block(soap, soap_blist_Segment);
		if (a->__sizeSegment)
		{	a->Segment = (struct tt__Polyline *)soap_save_block(soap, soap_blist_Segment, NULL, 1);
		}
		else
		{	a->Segment = NULL;
			if (soap_blist_Segment)
				soap_end_block(soap, soap_blist_Segment);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeSegment < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PolylineArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArray, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_new_tt__PolylineArray(struct soap *soap, int n)
{
	struct tt__PolylineArray *p;
	struct tt__PolylineArray *a = (struct tt__PolylineArray*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArray));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArray(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArray(struct soap *soap, const struct tt__PolylineArray *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_get_tt__PolylineArray(struct soap *soap, struct tt__PolylineArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportedAnalyticsModulesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModulesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_new_tt__SupportedAnalyticsModulesExtension(struct soap *soap, int n)
{
	struct tt__SupportedAnalyticsModulesExtension *p;
	struct tt__SupportedAnalyticsModulesExtension *a = (struct tt__SupportedAnalyticsModulesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedAnalyticsModulesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedAnalyticsModulesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModuleContentSchemaLocation = 0;
	a->AnalyticsModuleContentSchemaLocation = NULL;
	a->__sizeAnalyticsModuleDescription = 0;
	a->AnalyticsModuleDescription = NULL;
	a->Extension = NULL;
	a->Limit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->AnalyticsModuleContentSchemaLocation + i));
		}
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleDescription; i++)
		{
			soap_embedded(soap, a->AnalyticsModuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->AnalyticsModuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModules *a, const char *type)
{
	if (a->Limit)
	{	soap_set_attr(soap, "Limit", soap_int2s(soap, *a->Limit), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModules), type))
		return soap->error;
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleContentSchemaLocation; i++)
			if (soap_out_string(soap, "tt:AnalyticsModuleContentSchemaLocation", -1, (char*const*)(a->AnalyticsModuleContentSchemaLocation + i), ""))
				return soap->error;
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", -1, a->AnalyticsModuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModules *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_AnalyticsModuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportedAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModules(soap, a);
	{
		const char *t = soap_attr_value(soap, "Limit", 5, 0);
		if (t)
		{
			if (!(a->Limit = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Limit))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleContentSchemaLocation", 1, NULL))
			{	if (a->AnalyticsModuleContentSchemaLocation == NULL)
				{	if (soap_blist_AnalyticsModuleContentSchemaLocation == NULL)
						soap_blist_AnalyticsModuleContentSchemaLocation = soap_alloc_block(soap);
					a->AnalyticsModuleContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_AnalyticsModuleContentSchemaLocation, sizeof(char *));
					if (a->AnalyticsModuleContentSchemaLocation == NULL)
						return NULL;
					*a->AnalyticsModuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", (char**)a->AnalyticsModuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeAnalyticsModuleContentSchemaLocation++;
					a->AnalyticsModuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleDescription", 1, NULL))
			{	if (a->AnalyticsModuleDescription == NULL)
				{	if (soap_blist_AnalyticsModuleDescription == NULL)
						soap_blist_AnalyticsModuleDescription = soap_alloc_block(soap);
					a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_push_block_max(soap, soap_blist_AnalyticsModuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->AnalyticsModuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->AnalyticsModuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", a->AnalyticsModuleDescription, "tt:ConfigDescription"))
				{	a->__sizeAnalyticsModuleDescription++;
					a->AnalyticsModuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		if (a->__sizeAnalyticsModuleContentSchemaLocation)
		{	a->AnalyticsModuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, NULL, 1);
		}
		else
		{	a->AnalyticsModuleContentSchemaLocation = NULL;
			if (soap_blist_AnalyticsModuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		}
		if (a->AnalyticsModuleDescription)
			soap_pop_block(soap, soap_blist_AnalyticsModuleDescription);
		if (a->__sizeAnalyticsModuleDescription)
		{	a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_AnalyticsModuleDescription, NULL, 1);
		}
		else
		{	a->AnalyticsModuleDescription = NULL;
			if (soap_blist_AnalyticsModuleDescription)
				soap_end_block(soap, soap_blist_AnalyticsModuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_new_tt__SupportedAnalyticsModules(struct soap *soap, int n)
{
	struct tt__SupportedAnalyticsModules *p;
	struct tt__SupportedAnalyticsModules *a = (struct tt__SupportedAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedAnalyticsModules(soap, tag ? tag : "tt:SupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedRulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRulesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_in_tt__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportedRulesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRulesExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_new_tt__SupportedRulesExtension(struct soap *soap, int n)
{
	struct tt__SupportedRulesExtension *p;
	struct tt__SupportedRulesExtension *a = (struct tt__SupportedRulesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedRulesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedRulesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_get_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRuleContentSchemaLocation = 0;
	a->RuleContentSchemaLocation = NULL;
	a->__sizeRuleDescription = 0;
	a->RuleDescription = NULL;
	a->Extension = NULL;
	a->Limit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->RuleContentSchemaLocation + i));
		}
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleDescription; i++)
		{
			soap_embedded(soap, a->RuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->RuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedRulesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRules(struct soap *soap, const char *tag, int id, const struct tt__SupportedRules *a, const char *type)
{
	if (a->Limit)
	{	soap_set_attr(soap, "Limit", soap_int2s(soap, *a->Limit), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRules), type))
		return soap->error;
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleContentSchemaLocation; i++)
			if (soap_out_string(soap, "tt:RuleContentSchemaLocation", -1, (char*const*)(a->RuleContentSchemaLocation + i), ""))
				return soap->error;
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:RuleDescription", -1, a->RuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedRulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_in_tt__SupportedRules(struct soap *soap, const char *tag, struct tt__SupportedRules *a, const char *type)
{
	struct soap_blist *soap_blist_RuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_RuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportedRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRules(soap, a);
	{
		const char *t = soap_attr_value(soap, "Limit", 5, 0);
		if (t)
		{
			if (!(a->Limit = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Limit))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleContentSchemaLocation", 1, NULL))
			{	if (a->RuleContentSchemaLocation == NULL)
				{	if (soap_blist_RuleContentSchemaLocation == NULL)
						soap_blist_RuleContentSchemaLocation = soap_alloc_block(soap);
					a->RuleContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_RuleContentSchemaLocation, sizeof(char *));
					if (a->RuleContentSchemaLocation == NULL)
						return NULL;
					*a->RuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:RuleContentSchemaLocation", (char**)a->RuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeRuleContentSchemaLocation++;
					a->RuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleDescription", 1, NULL))
			{	if (a->RuleDescription == NULL)
				{	if (soap_blist_RuleDescription == NULL)
						soap_blist_RuleDescription = soap_alloc_block(soap);
					a->RuleDescription = (struct tt__ConfigDescription *)soap_push_block_max(soap, soap_blist_RuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->RuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->RuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:RuleDescription", a->RuleDescription, "tt:ConfigDescription"))
				{	a->__sizeRuleDescription++;
					a->RuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedRulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedRulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_RuleContentSchemaLocation);
		if (a->__sizeRuleContentSchemaLocation)
		{	a->RuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_RuleContentSchemaLocation, NULL, 1);
		}
		else
		{	a->RuleContentSchemaLocation = NULL;
			if (soap_blist_RuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_RuleContentSchemaLocation);
		}
		if (a->RuleDescription)
			soap_pop_block(soap, soap_blist_RuleDescription);
		if (a->__sizeRuleDescription)
		{	a->RuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_RuleDescription, NULL, 1);
		}
		else
		{	a->RuleDescription = NULL;
			if (soap_blist_RuleDescription)
				soap_end_block(soap, soap_blist_RuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_new_tt__SupportedRules(struct soap *soap, int n)
{
	struct tt__SupportedRules *p;
	struct tt__SupportedRules *a = (struct tt__SupportedRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedRules));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedRules(soap, tag ? tag : "tt:SupportedRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_get_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ConfigDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescriptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_new_tt__ConfigDescriptionExtension(struct soap *soap, int n)
{
	struct tt__ConfigDescriptionExtension *p;
	struct tt__ConfigDescriptionExtension *a = (struct tt__ConfigDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	soap_default_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
	soap_serialize_string(soap, (char*const*)&a->ParentTopic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const struct _tt__ConfigDescription_Messages *a, const char *type)
{
	if (a->IsProperty)
	{	soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ConfigDescription_Messages), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (!a->ParentTopic)
	{	if (soap_element_empty(soap, "tt:ParentTopic", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:ParentTopic", -1, (char*const*)&a->ParentTopic, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_in__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_ParentTopic = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ConfigDescription_Messages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ConfigDescription_Messages(soap, a);
	{
		const char *t = soap_attr_value(soap, "IsProperty", 5, 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap_flag_ParentTopic && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:ParentTopic", (char**)&a->ParentTopic, "xsd:string"))
				{	soap_flag_ParentTopic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParentTopic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ConfigDescription_Messages, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_new__tt__ConfigDescription_Messages(struct soap *soap, int n)
{
	struct _tt__ConfigDescription_Messages *p;
	struct _tt__ConfigDescription_Messages *a = (struct _tt__ConfigDescription_Messages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ConfigDescription_Messages));
	for (p = a; p && n--; p++)
		soap_default__tt__ConfigDescription_Messages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a, const char *tag, const char *type)
{
	if (soap_out__tt__ConfigDescription_Messages(soap, tag ? tag : "tt:ConfigDescription-Messages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_get__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	a->__sizeMessages = 0;
	a->Messages = NULL;
	a->Extension = NULL;
	soap_default__QName(soap, &a->Name);
	a->fixed = NULL;
	soap_default_xsd__integer(soap, &a->maxInstances);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Parameters);
	if (a->Messages)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessages; i++)
		{
			soap_embedded(soap, a->Messages + i, SOAP_TYPE__tt__ConfigDescription_Messages);
			soap_serialize__tt__ConfigDescription_Messages(soap, a->Messages + i);
		}
	}
	soap_serialize_PointerTott__ConfigDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescription(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap__QName2s(soap, a->Name) : "", 1);
	if (a->fixed)
	{	soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, *a->fixed), 1);
	}
	if (a->maxInstances)
		soap_set_attr(soap, "maxInstances", soap_xsd__integer2s(soap, a->maxInstances), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescription), type))
		return soap->error;
	if (!a->Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemListDescription(soap, "tt:Parameters", -1, &a->Parameters, ""))
		return soap->error;
	if (a->Messages)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessages; i++)
			if (soap_out__tt__ConfigDescription_Messages(soap, "tt:Messages", -1, a->Messages + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_in_tt__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	struct soap_blist *soap_blist_Messages = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ConfigDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescription(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "Name", 2, 1), &a->Name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "fixed", 5, 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "maxInstances", 5, 0), &a->maxInstances))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Parameters", &a->Parameters, "tt:ItemListDescription"))
				{	soap_flag_Parameters--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Messages", 1, NULL))
			{	if (a->Messages == NULL)
				{	if (soap_blist_Messages == NULL)
						soap_blist_Messages = soap_alloc_block(soap);
					a->Messages = (struct _tt__ConfigDescription_Messages *)soap_push_block_max(soap, soap_blist_Messages, sizeof(struct _tt__ConfigDescription_Messages));
					if (a->Messages == NULL)
						return NULL;
					soap_default__tt__ConfigDescription_Messages(soap, a->Messages);
				}
				soap_revert(soap);
				if (soap_in__tt__ConfigDescription_Messages(soap, "tt:Messages", a->Messages, ""))
				{	a->__sizeMessages++;
					a->Messages = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ConfigDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Messages)
			soap_pop_block(soap, soap_blist_Messages);
		if (a->__sizeMessages)
		{	a->Messages = (struct _tt__ConfigDescription_Messages *)soap_save_block(soap, soap_blist_Messages, NULL, 1);
		}
		else
		{	a->Messages = NULL;
			if (soap_blist_Messages)
				soap_end_block(soap, soap_blist_Messages);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_new_tt__ConfigDescription(struct soap *soap, int n)
{
	struct tt__ConfigDescription *p;
	struct tt__ConfigDescription *a = (struct tt__ConfigDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_get_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RuleEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__RuleEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__RuleEngineConfigurationExtension *p;
	struct tt__RuleEngineConfigurationExtension *a = (struct tt__RuleEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RuleEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RuleEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRule = 0;
	a->Rule = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tt:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Rule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RuleEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_alloc_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
		{	a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		}
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_new_tt__RuleEngineConfiguration(struct soap *soap, int n)
{
	struct tt__RuleEngineConfiguration *p;
	struct tt__RuleEngineConfiguration *a = (struct tt__RuleEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RuleEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RuleEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfigurationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineConfigurationExtension *p;
	struct tt__AnalyticsEngineConfigurationExtension *a = (struct tt__AnalyticsEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Config(struct soap *soap, struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Config(struct soap *soap, const struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &a->Parameters);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const struct tt__Config *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type))
		return soap->error;
	if (!a->Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, struct tt__Config *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Config*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Config(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->Parameters, "tt:ItemList"))
				{	soap_flag_Parameters--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_new_tt__Config(struct soap *soap, int n)
{
	struct tt__Config *p;
	struct tt__Config *a = (struct tt__Config*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Config));
	for (p = a; p && n--; p++)
		soap_default_tt__Config(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Config(struct soap *soap, const struct tt__Config *a, const char *tag, const char *type)
{
	if (soap_out_tt__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, struct tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tt:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_new_tt__AnalyticsEngineConfiguration(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineConfiguration *p;
	struct tt__AnalyticsEngineConfiguration *a = (struct tt__AnalyticsEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector(struct soap *soap, struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->x = NULL;
	a->y = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector(struct soap *soap, const struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const struct tt__Vector *a, const char *type)
{
	if (a->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	}
	if (a->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, struct tt__Vector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Vector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector(soap, a);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_new_tt__Vector(struct soap *soap, int n)
{
	struct tt__Vector *p;
	struct tt__Vector *a = (struct tt__Vector*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector(struct soap *soap, const struct tt__Vector *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, struct tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polyline(struct soap *soap, struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polyline(struct soap *soap, const struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const struct tt__Polyline *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, struct tt__Polyline *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Polyline*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polyline(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_alloc_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block_max(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
		{	a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		}
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_new_tt__Polyline(struct soap *soap, int n)
{
	struct tt__Polyline *p;
	struct tt__Polyline *a = (struct tt__Polyline*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Polyline));
	for (p = a; p && n--; p++)
		soap_default_tt__Polyline(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polyline(struct soap *soap, const struct tt__Polyline *a, const char *tag, const char *type)
{
	if (soap_out_tt__Polyline(soap, tag ? tag : "tt:Polyline", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, struct tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescriptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_new_tt__ItemListDescriptionExtension(struct soap *soap, int n)
{
	struct tt__ItemListDescriptionExtension *p;
	struct tt__ItemListDescriptionExtension *a = (struct tt__ItemListDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemListDescription_ElementItemDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_ElementItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_ElementItemDescription *p;
	struct _tt__ItemListDescription_ElementItemDescription *a = (struct _tt__ItemListDescription_ElementItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_ElementItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_ElementItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemListDescription_SimpleItemDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_SimpleItemDescription *p;
	struct _tt__ItemListDescription_SimpleItemDescription *a = (struct _tt__ItemListDescription_SimpleItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_SimpleItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageDescriptionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescriptionExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_new_tt__MessageDescriptionExtension(struct soap *soap, int n)
{
	struct tt__MessageDescriptionExtension *p;
	struct tt__MessageDescriptionExtension *a = (struct tt__MessageDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItemDescription = 0;
	a->SimpleItemDescription = NULL;
	a->__sizeElementItemDescription = 0;
	a->ElementItemDescription = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, a->SimpleItemDescription + i, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
			soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription + i);
		}
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, a->ElementItemDescription + i, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
			soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription + i);
		}
	}
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
			if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", -1, a->SimpleItemDescription + i, ""))
				return soap->error;
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
			if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", -1, a->ElementItemDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItemDescription = NULL;
	struct soap_blist *soap_blist_ElementItemDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
			{	if (a->SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription == NULL)
						soap_blist_SimpleItemDescription = soap_alloc_block(soap);
					a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_push_block_max(soap, soap_blist_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
					if (a->SimpleItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", a->SimpleItemDescription, ""))
				{	a->__sizeSimpleItemDescription++;
					a->SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
			{	if (a->ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription == NULL)
						soap_blist_ElementItemDescription = soap_alloc_block(soap);
					a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_push_block_max(soap, soap_blist_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription));
					if (a->ElementItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", a->ElementItemDescription, ""))
				{	a->__sizeElementItemDescription++;
					a->ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription);
		if (a->__sizeSimpleItemDescription)
		{	a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription, NULL, 1);
		}
		else
		{	a->SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription)
				soap_end_block(soap, soap_blist_SimpleItemDescription);
		}
		if (a->ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription);
		if (a->__sizeElementItemDescription)
		{	a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription, NULL, 1);
		}
		else
		{	a->ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription)
				soap_end_block(soap, soap_blist_ElementItemDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_new_tt__ItemListDescription(struct soap *soap, int n)
{
	struct tt__ItemListDescription *p;
	struct tt__ItemListDescription *a = (struct tt__ItemListDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const struct tt__MessageDescription *a, const char *type)
{
	if (a->IsProperty)
	{	soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, struct tt__MessageDescription *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescription(soap, a);
	{
		const char *t = soap_attr_value(soap, "IsProperty", 5, 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_new_tt__MessageDescription(struct soap *soap, int n)
{
	struct tt__MessageDescription *p;
	struct tt__MessageDescription *a = (struct tt__MessageDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescription(soap, tag ? tag : "tt:MessageDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemListExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_new_tt__ItemListExtension(struct soap *soap, int n)
{
	struct tt__ItemListExtension *p;
	struct tt__ItemListExtension *a = (struct tt__ItemListExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_ElementItem *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemList_ElementItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_new__tt__ItemList_ElementItem(struct soap *soap, int n)
{
	struct _tt__ItemList_ElementItem *p;
	struct _tt__ItemList_ElementItem *a = (struct _tt__ItemList_ElementItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_ElementItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_ElementItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_SimpleItem *a, const char *type)
{
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	soap_set_attr(soap, "Value", a->Value ? soap_xsd__anySimpleType2s(soap, a->Value) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ItemList_SimpleItem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2xsd__anySimpleType(soap, soap_attr_value(soap, "Value", 1, 1), &a->Value))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_new__tt__ItemList_SimpleItem(struct soap *soap, int n)
{
	struct _tt__ItemList_SimpleItem *p;
	struct _tt__ItemList_SimpleItem *a = (struct _tt__ItemList_SimpleItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_SimpleItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_SimpleItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemList(struct soap *soap, struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemList(struct soap *soap, const struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			soap_serialize__tt__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			soap_serialize__tt__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const struct tt__ItemList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
			if (soap_out__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
			if (soap_out__tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, struct tt__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ItemList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	if (a->SimpleItem == NULL)
				{	if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_alloc_block(soap);
					a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_push_block_max(soap, soap_blist_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__tt__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->SimpleItem, ""))
				{	a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	if (a->ElementItem == NULL)
				{	if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_alloc_block(soap);
					a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_push_block_max(soap, soap_blist_ElementItem, sizeof(struct _tt__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__tt__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->ElementItem, ""))
				{	a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
		{	a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		}
		else
		{	a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
		{	a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		}
		else
		{	a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_new_tt__ItemList(struct soap *soap, int n)
{
	struct tt__ItemList *p;
	struct tt__ItemList *a = (struct tt__ItemList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemList));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemList(struct soap *soap, const struct tt__ItemList *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, struct tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MessageExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_new_tt__MessageExtension(struct soap *soap, int n)
{
	struct tt__MessageExtension *p;
	struct tt__MessageExtension *a = (struct tt__MessageExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StringAttrList(soap, &a->AFModes);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__StringAttrList(soap, (char*const*)&a->AFModes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type))
		return soap->error;
	if (soap_out_tt__StringAttrList(soap, "tt:AFModes", -1, (char*const*)&a->AFModes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension *a, const char *type)
{
	size_t soap_flag_AFModes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AFModes && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__StringAttrList(soap, "tt:AFModes", (char**)&a->AFModes, "tt:StringAttrList"))
				{	soap_flag_AFModes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_new_tt__FocusOptions20Extension(struct soap *soap, int n)
{
	struct tt__FocusOptions20Extension *p;
	struct tt__FocusOptions20Extension *a = (struct tt__FocusOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalanceOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_new_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n)
{
	struct tt__WhiteBalanceOptions20Extension *p;
	struct tt__WhiteBalanceOptions20Extension *a = (struct tt__WhiteBalanceOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalanceOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusConfiguration20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_new_tt__FocusConfiguration20Extension(struct soap *soap, int n)
{
	struct tt__FocusConfiguration20Extension *p;
	struct tt__FocusConfiguration20Extension *a = (struct tt__FocusConfiguration20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusConfiguration20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusConfiguration20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalance20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_new_tt__WhiteBalance20Extension(struct soap *soap, int n)
{
	struct tt__WhiteBalance20Extension *p;
	struct tt__WhiteBalance20Extension *a = (struct tt__WhiteBalance20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalance20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalance20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type))
		return soap->error;
	if (!a->Distance)
	{	if (soap_element_empty(soap, "tt:Distance", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelativeFocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocusOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->Distance, "tt:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Distance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_new_tt__RelativeFocusOptions20(struct soap *soap, int n)
{
	struct tt__RelativeFocusOptions20 *p;
	struct tt__RelativeFocusOptions20 *a = (struct tt__RelativeFocusOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelativeFocusOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__RelativeFocusOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &a->Continuous);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const struct tt__MoveOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, struct tt__MoveOptions20 *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MoveOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MoveOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative--;
					continue;
				}
			}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_new_tt__MoveOptions20(struct soap *soap, int n)
{
	struct tt__MoveOptions20 *p;
	struct tt__MoveOptions20 *a = (struct tt__MoveOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MoveOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentOptionsExtension *p;
	struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationOptionsExtension(struct soap *soap, const struct tt__ImageStabilizationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImageStabilizationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_new_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n)
{
	struct tt__ImageStabilizationOptionsExtension *p;
	struct tt__ImageStabilizationOptionsExtension *a = (struct tt__ImageStabilizationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationOptionsExtension(struct soap *soap, const struct tt__ImageStabilizationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension4(struct soap *soap, const struct tt__ImagingOptions20Extension4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension4), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions20Extension4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension4(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension4, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension4(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension4 *p;
	struct tt__ImagingOptions20Extension4 *a = (struct tt__ImagingOptions20Extension4*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension4));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension4(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension4(struct soap *soap, const struct tt__ImagingOptions20Extension4 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NoiseReductionOptions(struct soap *soap, const struct tt__NoiseReductionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap *soap, const char *tag, int id, const struct tt__NoiseReductionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReductionOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap *soap, const char *tag, struct tt__NoiseReductionOptions *a, const char *type)
{
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NoiseReductionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NoiseReductionOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_new_tt__NoiseReductionOptions(struct soap *soap, int n)
{
	struct tt__NoiseReductionOptions *p;
	struct tt__NoiseReductionOptions *a = (struct tt__NoiseReductionOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NoiseReductionOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__NoiseReductionOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NoiseReductionOptions(struct soap *soap, const struct tt__NoiseReductionOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DefoggingOptions(struct soap *soap, const struct tt__DefoggingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Mode + i));
		}
	}
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap *soap, const char *tag, int id, const struct tt__DefoggingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_string(soap, "tt:Mode", -1, (char*const*)(a->Mode + i), ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap *soap, const char *tag, struct tt__DefoggingOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DefoggingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DefoggingOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (char **)soap_push_block_max(soap, soap_blist_Mode, sizeof(char *));
					if (a->Mode == NULL)
						return NULL;
					*a->Mode = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Mode", (char**)a->Mode, "xsd:string"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (char **)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_new_tt__DefoggingOptions(struct soap *soap, int n)
{
	struct tt__DefoggingOptions *p;
	struct tt__DefoggingOptions *a = (struct tt__DefoggingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DefoggingOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__DefoggingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DefoggingOptions(struct soap *soap, const struct tt__DefoggingOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ToneCompensationOptions(struct soap *soap, const struct tt__ToneCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Mode + i));
		}
	}
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap *soap, const char *tag, int id, const struct tt__ToneCompensationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_string(soap, "tt:Mode", -1, (char*const*)(a->Mode + i), ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap *soap, const char *tag, struct tt__ToneCompensationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ToneCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ToneCompensationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (char **)soap_push_block_max(soap, soap_blist_Mode, sizeof(char *));
					if (a->Mode == NULL)
						return NULL;
					*a->Mode = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Mode", (char**)a->Mode, "xsd:string"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (char **)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_new_tt__ToneCompensationOptions(struct soap *soap, int n)
{
	struct tt__ToneCompensationOptions *p;
	struct tt__ToneCompensationOptions *a = (struct tt__ToneCompensationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ToneCompensationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensationOptions(struct soap *soap, const struct tt__ToneCompensationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ToneCompensationOptions = NULL;
	a->DefoggingOptions = NULL;
	a->NoiseReductionOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension3(struct soap *soap, const struct tt__ImagingOptions20Extension3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensationOptions(soap, &a->ToneCompensationOptions);
	soap_serialize_PointerTott__DefoggingOptions(soap, &a->DefoggingOptions);
	soap_serialize_PointerTott__NoiseReductionOptions(soap, &a->NoiseReductionOptions);
	soap_serialize_PointerTott__ImagingOptions20Extension4(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension3), type))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", -1, &a->ToneCompensationOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", -1, &a->DefoggingOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", -1, &a->NoiseReductionOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension3 *a, const char *type)
{
	size_t soap_flag_ToneCompensationOptions = 1;
	size_t soap_flag_DefoggingOptions = 1;
	size_t soap_flag_NoiseReductionOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions20Extension3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension3(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", &a->ToneCompensationOptions, "tt:ToneCompensationOptions"))
				{	soap_flag_ToneCompensationOptions--;
					continue;
				}
			}
			if (soap_flag_DefoggingOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", &a->DefoggingOptions, "tt:DefoggingOptions"))
				{	soap_flag_DefoggingOptions--;
					continue;
				}
			}
			if (soap_flag_NoiseReductionOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", &a->NoiseReductionOptions, "tt:NoiseReductionOptions"))
				{	soap_flag_NoiseReductionOptions--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension4"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension3(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension3 *p;
	struct tt__ImagingOptions20Extension3 *a = (struct tt__ImagingOptions20Extension3*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension3));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension3(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension3(struct soap *soap, const struct tt__ImagingOptions20Extension3 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBoundaryType = 0;
	a->BoundaryType = NULL;
	a->BoundaryOffset = NULL;
	a->ResponseTimeRange = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BoundaryType)
	{	int i;
		for (i = 0; i < (int)a->__sizeBoundaryType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->BoundaryType + i));
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->BoundaryOffset);
	soap_serialize_PointerTott__DurationRange(soap, &a->ResponseTimeRange);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions), type))
		return soap->error;
	if (a->BoundaryType)
	{	int i;
		for (i = 0; i < (int)a->__sizeBoundaryType; i++)
			if (soap_out_string(soap, "tt:BoundaryType", -1, (char*const*)(a->BoundaryType + i), ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "tt:BoundaryOffset", -1, &a->BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", -1, &a->ResponseTimeRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	struct soap_blist *soap_blist_BoundaryType = NULL;
	size_t soap_flag_BoundaryOffset = 1;
	size_t soap_flag_ResponseTimeRange = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IrCutFilterAutoAdjustmentOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:BoundaryType", 1, NULL))
			{	if (a->BoundaryType == NULL)
				{	if (soap_blist_BoundaryType == NULL)
						soap_blist_BoundaryType = soap_alloc_block(soap);
					a->BoundaryType = (char **)soap_push_block_max(soap, soap_blist_BoundaryType, sizeof(char *));
					if (a->BoundaryType == NULL)
						return NULL;
					*a->BoundaryType = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:BoundaryType", (char**)a->BoundaryType, "xsd:string"))
				{	a->__sizeBoundaryType++;
					a->BoundaryType = NULL;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:BoundaryOffset", &a->BoundaryOffset, "xsd:boolean"))
				{	soap_flag_BoundaryOffset--;
					continue;
				}
			}
			if (soap_flag_ResponseTimeRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", &a->ResponseTimeRange, "tt:DurationRange"))
				{	soap_flag_ResponseTimeRange--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BoundaryType)
			soap_pop_block(soap, soap_blist_BoundaryType);
		if (a->__sizeBoundaryType)
		{	a->BoundaryType = (char **)soap_save_block(soap, soap_blist_BoundaryType, NULL, 1);
		}
		else
		{	a->BoundaryType = NULL;
			if (soap_blist_BoundaryType)
				soap_end_block(soap, soap_blist_BoundaryType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBoundaryType < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentOptions *p;
	struct tt__IrCutFilterAutoAdjustmentOptions *a = (struct tt__IrCutFilterAutoAdjustmentOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IrCutFilterAutoAdjustment = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension2(struct soap *soap, const struct tt__ImagingOptions20Extension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &a->IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingOptions20Extension3(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension2), type))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension2 *a, const char *type)
{
	size_t soap_flag_IrCutFilterAutoAdjustment = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions20Extension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IrCutFilterAutoAdjustment && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", &a->IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustmentOptions"))
				{	soap_flag_IrCutFilterAutoAdjustment--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension3"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension2(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension2 *p;
	struct tt__ImagingOptions20Extension2 *a = (struct tt__ImagingOptions20Extension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension2));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension2(struct soap *soap, const struct tt__ImagingOptions20Extension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationOptions(struct soap *soap, const struct tt__ImageStabilizationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ImageStabilizationMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
	soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImageStabilizationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ImageStabilizationMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ImageStabilizationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ImageStabilizationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", a->Mode, "tt:ImageStabilizationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:ImageStabilizationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ImageStabilizationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_new_tt__ImageStabilizationOptions(struct soap *soap, int n)
{
	struct tt__ImageStabilizationOptions *p;
	struct tt__ImageStabilizationOptions *a = (struct tt__ImageStabilizationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationOptions(struct soap *soap, const struct tt__ImageStabilizationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImageStabilization = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImageStabilizationOptions(soap, &a->ImageStabilization);
	soap_serialize_PointerTott__ImagingOptions20Extension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", -1, &a->ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension *a, const char *type)
{
	size_t soap_flag_ImageStabilization = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", &a->ImageStabilization, "tt:ImageStabilizationOptions"))
				{	soap_flag_ImageStabilization--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension *p;
	struct tt__ImagingOptions20Extension *a = (struct tt__ImagingOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalanceOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WhiteBalanceMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", a->Mode, "tt:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_new_tt__WhiteBalanceOptions20(struct soap *soap, int n)
{
	struct tt__WhiteBalanceOptions20 *p;
	struct tt__WhiteBalanceOptions20 *a = (struct tt__WhiteBalanceOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalanceOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WideDynamicRangeOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRangeOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_new_tt__WideDynamicRangeOptions20(struct soap *soap, int n)
{
	struct tt__WideDynamicRangeOptions20 *p;
	struct tt__WideDynamicRangeOptions20 *a = (struct tt__WideDynamicRangeOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WideDynamicRangeOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicRangeOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_tt__AutoFocusMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
			if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, struct tt__FocusOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_alloc_block(soap);
					a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_push_block_max(soap, soap_blist_AutoFocusModes, sizeof(enum tt__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_tt__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusModes", a->AutoFocusModes, "tt:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
		{	a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		}
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_new_tt__FocusOptions20(struct soap *soap, int n)
{
	struct tt__FocusOptions20 *p;
	struct tt__FocusOptions20 *a = (struct tt__FocusOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_tt__ExposurePriority);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTott__FloatRange(soap, &a->Iris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const struct tt__ExposureOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
			if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, struct tt__ExposureOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ExposureOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ExposureOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ExposureMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", a->Mode, "tt:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_alloc_block(soap);
					a->Priority = (enum tt__ExposurePriority *)soap_push_block_max(soap, soap_blist_Priority, sizeof(enum tt__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_tt__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", a->Priority, "tt:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->Gain, "tt:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->Iris, "tt:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
		{	a->Priority = (enum tt__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		}
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_new_tt__ExposureOptions20(struct soap *soap, int n)
{
	struct tt__ExposureOptions20 *p;
	struct tt__ExposureOptions20 *a = (struct tt__ExposureOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ExposureOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__ExposureOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__BacklightCompensationMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BacklightCompensationOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensationOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__BacklightCompensationMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__BacklightCompensationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__BacklightCompensationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", a->Mode, "tt:BacklightCompensationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__BacklightCompensationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_new_tt__BacklightCompensationOptions20(struct soap *soap, int n)
{
	struct tt__BacklightCompensationOptions20 *p;
	struct tt__BacklightCompensationOptions20 *a = (struct tt__BacklightCompensationOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BacklightCompensationOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensationOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_tt__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
			if (soap_out_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, struct tt__ImagingOptions20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure--;
					continue;
				}
			}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_alloc_block(soap);
					a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_push_block_max(soap, soap_blist_IrCutFilterModes, sizeof(enum tt__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_tt__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", a->IrCutFilterModes, "tt:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
		{	a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		}
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_new_tt__ImagingOptions20(struct soap *soap, int n)
{
	struct tt__ImagingOptions20 *p;
	struct tt__ImagingOptions20 *a = (struct tt__ImagingOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DefoggingExtension(struct soap *soap, const struct tt__DefoggingExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap *soap, const char *tag, int id, const struct tt__DefoggingExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap *soap, const char *tag, struct tt__DefoggingExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DefoggingExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DefoggingExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DefoggingExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingExtension, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_new_tt__DefoggingExtension(struct soap *soap, int n)
{
	struct tt__DefoggingExtension *p;
	struct tt__DefoggingExtension *a = (struct tt__DefoggingExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DefoggingExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__DefoggingExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DefoggingExtension(struct soap *soap, const struct tt__DefoggingExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ToneCompensationExtension(struct soap *soap, const struct tt__ToneCompensationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap *soap, const char *tag, int id, const struct tt__ToneCompensationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap *soap, const char *tag, struct tt__ToneCompensationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ToneCompensationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ToneCompensationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationExtension, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_new_tt__ToneCompensationExtension(struct soap *soap, int n)
{
	struct tt__ToneCompensationExtension *p;
	struct tt__ToneCompensationExtension *a = (struct tt__ToneCompensationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ToneCompensationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensationExtension(struct soap *soap, const struct tt__ToneCompensationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IrCutFilterAutoAdjustmentExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentExtension *p;
	struct tt__IrCutFilterAutoAdjustmentExtension *a = (struct tt__IrCutFilterAutoAdjustmentExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationExtension(struct soap *soap, const struct tt__ImageStabilizationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImageStabilizationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationExtension, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_new_tt__ImageStabilizationExtension(struct soap *soap, int n)
{
	struct tt__ImageStabilizationExtension *p;
	struct tt__ImageStabilizationExtension *a = (struct tt__ImageStabilizationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationExtension(struct soap *soap, const struct tt__ImageStabilizationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension204(struct soap *soap, struct tt__ImagingSettingsExtension204 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension204(struct soap *soap, const struct tt__ImagingSettingsExtension204 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension204), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension204 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettingsExtension204*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension204(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension204 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension204, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(struct tt__ImagingSettingsExtension204), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_new_tt__ImagingSettingsExtension204(struct soap *soap, int n)
{
	struct tt__ImagingSettingsExtension204 *p;
	struct tt__ImagingSettingsExtension204 *a = (struct tt__ImagingSettingsExtension204*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettingsExtension204));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettingsExtension204(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension204(struct soap *soap, const struct tt__ImagingSettingsExtension204 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension204(struct soap *soap, struct tt__ImagingSettingsExtension204 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NoiseReduction(struct soap *soap, struct tt__NoiseReduction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NoiseReduction(struct soap *soap, const struct tt__NoiseReduction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReduction(struct soap *soap, const char *tag, int id, const struct tt__NoiseReduction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReduction), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NoiseReduction * SOAP_FMAC4 soap_in_tt__NoiseReduction(struct soap *soap, const char *tag, struct tt__NoiseReduction *a, const char *type)
{
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NoiseReduction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NoiseReduction(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NoiseReduction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReduction, SOAP_TYPE_tt__NoiseReduction, sizeof(struct tt__NoiseReduction), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NoiseReduction * SOAP_FMAC4 soap_new_tt__NoiseReduction(struct soap *soap, int n)
{
	struct tt__NoiseReduction *p;
	struct tt__NoiseReduction *a = (struct tt__NoiseReduction*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NoiseReduction));
	for (p = a; p && n--; p++)
		soap_default_tt__NoiseReduction(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NoiseReduction(struct soap *soap, const struct tt__NoiseReduction *a, const char *tag, const char *type)
{
	if (soap_out_tt__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReduction * SOAP_FMAC4 soap_get_tt__NoiseReduction(struct soap *soap, struct tt__NoiseReduction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Defogging(struct soap *soap, struct tt__Defogging *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Mode);
	a->Level = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Defogging(struct soap *soap, const struct tt__Defogging *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Mode);
	soap_serialize_PointerTofloat(soap, &a->Level);
	soap_serialize_PointerTott__DefoggingExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Defogging(struct soap *soap, const char *tag, int id, const struct tt__Defogging *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Defogging), type))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_empty(soap, "tt:Mode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Defogging * SOAP_FMAC4 soap_in_tt__Defogging(struct soap *soap, const char *tag, struct tt__Defogging *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Defogging*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Defogging(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Mode", (char**)&a->Mode, "xsd:string"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingExtension(soap, "tt:Extension", &a->Extension, "tt:DefoggingExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Mode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Defogging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Defogging, SOAP_TYPE_tt__Defogging, sizeof(struct tt__Defogging), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Defogging * SOAP_FMAC4 soap_new_tt__Defogging(struct soap *soap, int n)
{
	struct tt__Defogging *p;
	struct tt__Defogging *a = (struct tt__Defogging*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Defogging));
	for (p = a; p && n--; p++)
		soap_default_tt__Defogging(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Defogging(struct soap *soap, const struct tt__Defogging *a, const char *tag, const char *type)
{
	if (soap_out_tt__Defogging(soap, tag ? tag : "tt:Defogging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Defogging * SOAP_FMAC4 soap_get_tt__Defogging(struct soap *soap, struct tt__Defogging *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ToneCompensation(struct soap *soap, struct tt__ToneCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Mode);
	a->Level = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ToneCompensation(struct soap *soap, const struct tt__ToneCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Mode);
	soap_serialize_PointerTofloat(soap, &a->Level);
	soap_serialize_PointerTott__ToneCompensationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensation(struct soap *soap, const char *tag, int id, const struct tt__ToneCompensation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensation), type))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_empty(soap, "tt:Mode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ToneCompensation * SOAP_FMAC4 soap_in_tt__ToneCompensation(struct soap *soap, const char *tag, struct tt__ToneCompensation *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ToneCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ToneCompensation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Mode", (char**)&a->Mode, "xsd:string"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationExtension(soap, "tt:Extension", &a->Extension, "tt:ToneCompensationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Mode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ToneCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensation, SOAP_TYPE_tt__ToneCompensation, sizeof(struct tt__ToneCompensation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ToneCompensation * SOAP_FMAC4 soap_new_tt__ToneCompensation(struct soap *soap, int n)
{
	struct tt__ToneCompensation *p;
	struct tt__ToneCompensation *a = (struct tt__ToneCompensation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ToneCompensation));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensation(struct soap *soap, const struct tt__ToneCompensation *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensation * SOAP_FMAC4 soap_get_tt__ToneCompensation(struct soap *soap, struct tt__ToneCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension203(struct soap *soap, struct tt__ImagingSettingsExtension203 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ToneCompensation = NULL;
	a->Defogging = NULL;
	a->NoiseReduction = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension203(struct soap *soap, const struct tt__ImagingSettingsExtension203 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensation(soap, &a->ToneCompensation);
	soap_serialize_PointerTott__Defogging(soap, &a->Defogging);
	soap_serialize_PointerTott__NoiseReduction(soap, &a->NoiseReduction);
	soap_serialize_PointerTott__ImagingSettingsExtension204(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension203), type))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", -1, &a->ToneCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__Defogging(soap, "tt:Defogging", -1, &a->Defogging, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", -1, &a->NoiseReduction, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension203 *a, const char *type)
{
	size_t soap_flag_ToneCompensation = 1;
	size_t soap_flag_Defogging = 1;
	size_t soap_flag_NoiseReduction = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettingsExtension203*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension203(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", &a->ToneCompensation, "tt:ToneCompensation"))
				{	soap_flag_ToneCompensation--;
					continue;
				}
			}
			if (soap_flag_Defogging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Defogging(soap, "tt:Defogging", &a->Defogging, "tt:Defogging"))
				{	soap_flag_Defogging--;
					continue;
				}
			}
			if (soap_flag_NoiseReduction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", &a->NoiseReduction, "tt:NoiseReduction"))
				{	soap_flag_NoiseReduction--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension204"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension203 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension203, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(struct tt__ImagingSettingsExtension203), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_new_tt__ImagingSettingsExtension203(struct soap *soap, int n)
{
	struct tt__ImagingSettingsExtension203 *p;
	struct tt__ImagingSettingsExtension203 *a = (struct tt__ImagingSettingsExtension203*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettingsExtension203));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettingsExtension203(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension203(struct soap *soap, const struct tt__ImagingSettingsExtension203 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension203(struct soap *soap, struct tt__ImagingSettingsExtension203 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustment(struct soap *soap, struct tt__IrCutFilterAutoAdjustment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->BoundaryType);
	a->BoundaryOffset = NULL;
	soap_default_xsd__duration(soap, &a->ResponseTime);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustment(struct soap *soap, const struct tt__IrCutFilterAutoAdjustment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->BoundaryType);
	soap_serialize_PointerTofloat(soap, &a->BoundaryOffset);
	soap_serialize_xsd__duration(soap, (char*const*)&a->ResponseTime);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment), type))
		return soap->error;
	if (!a->BoundaryType)
	{	if (soap_element_empty(soap, "tt:BoundaryType", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:BoundaryType", -1, (char*const*)&a->BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:BoundaryOffset", -1, &a->BoundaryOffset, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:ResponseTime", -1, (char*const*)&a->ResponseTime, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	size_t soap_flag_BoundaryType = 1;
	size_t soap_flag_BoundaryOffset = 1;
	size_t soap_flag_ResponseTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IrCutFilterAutoAdjustment*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustment(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundaryType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:BoundaryType", (char**)&a->BoundaryType, "xsd:string"))
				{	soap_flag_BoundaryType--;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:BoundaryOffset", &a->BoundaryOffset, "xsd:float"))
				{	soap_flag_BoundaryOffset--;
					continue;
				}
			}
			if (soap_flag_ResponseTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:ResponseTime", (char**)&a->ResponseTime, "xsd:duration"))
				{	soap_flag_ResponseTime--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", &a->Extension, "tt:IrCutFilterAutoAdjustmentExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->BoundaryType))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustment(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustment *p;
	struct tt__IrCutFilterAutoAdjustment *a = (struct tt__IrCutFilterAutoAdjustment*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustment));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustment(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustment(struct soap *soap, const struct tt__IrCutFilterAutoAdjustment *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustment(struct soap *soap, struct tt__IrCutFilterAutoAdjustment *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIrCutFilterAutoAdjustment = 0;
	a->IrCutFilterAutoAdjustment = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension202(struct soap *soap, const struct tt__ImagingSettingsExtension202 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IrCutFilterAutoAdjustment)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterAutoAdjustment; i++)
		{
			soap_embedded(soap, a->IrCutFilterAutoAdjustment + i, SOAP_TYPE_tt__IrCutFilterAutoAdjustment);
			soap_serialize_tt__IrCutFilterAutoAdjustment(soap, a->IrCutFilterAutoAdjustment + i);
		}
	}
	soap_serialize_PointerTott__ImagingSettingsExtension203(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension202), type))
		return soap->error;
	if (a->IrCutFilterAutoAdjustment)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterAutoAdjustment; i++)
			if (soap_out_tt__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", -1, a->IrCutFilterAutoAdjustment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension202 *a, const char *type)
{
	struct soap_blist *soap_blist_IrCutFilterAutoAdjustment = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettingsExtension202*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension202(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterAutoAdjustment", 1, NULL))
			{	if (a->IrCutFilterAutoAdjustment == NULL)
				{	if (soap_blist_IrCutFilterAutoAdjustment == NULL)
						soap_blist_IrCutFilterAutoAdjustment = soap_alloc_block(soap);
					a->IrCutFilterAutoAdjustment = (struct tt__IrCutFilterAutoAdjustment *)soap_push_block_max(soap, soap_blist_IrCutFilterAutoAdjustment, sizeof(struct tt__IrCutFilterAutoAdjustment));
					if (a->IrCutFilterAutoAdjustment == NULL)
						return NULL;
					soap_default_tt__IrCutFilterAutoAdjustment(soap, a->IrCutFilterAutoAdjustment);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", a->IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustment"))
				{	a->__sizeIrCutFilterAutoAdjustment++;
					a->IrCutFilterAutoAdjustment = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension203"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterAutoAdjustment)
			soap_pop_block(soap, soap_blist_IrCutFilterAutoAdjustment);
		if (a->__sizeIrCutFilterAutoAdjustment)
		{	a->IrCutFilterAutoAdjustment = (struct tt__IrCutFilterAutoAdjustment *)soap_save_block(soap, soap_blist_IrCutFilterAutoAdjustment, NULL, 1);
		}
		else
		{	a->IrCutFilterAutoAdjustment = NULL;
			if (soap_blist_IrCutFilterAutoAdjustment)
				soap_end_block(soap, soap_blist_IrCutFilterAutoAdjustment);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension202 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension202, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_new_tt__ImagingSettingsExtension202(struct soap *soap, int n)
{
	struct tt__ImagingSettingsExtension202 *p;
	struct tt__ImagingSettingsExtension202 *a = (struct tt__ImagingSettingsExtension202*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettingsExtension202));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettingsExtension202(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension202(struct soap *soap, const struct tt__ImagingSettingsExtension202 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ImageStabilizationMode(soap, &a->Mode);
	a->Level = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilization(struct soap *soap, const struct tt__ImageStabilization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ImageStabilizationMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
	soap_serialize_PointerTott__ImageStabilizationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilization(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilization), type))
		return soap->error;
	if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilization * SOAP_FMAC4 soap_in_tt__ImageStabilization(struct soap *soap, const char *tag, struct tt__ImageStabilization *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImageStabilization*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilization(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", &a->Mode, "tt:ImageStabilizationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", &a->Extension, "tt:ImageStabilizationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImageStabilization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilization, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilization * SOAP_FMAC4 soap_new_tt__ImageStabilization(struct soap *soap, int n)
{
	struct tt__ImageStabilization *p;
	struct tt__ImageStabilization *a = (struct tt__ImageStabilization*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilization));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilization(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilization(struct soap *soap, const struct tt__ImageStabilization *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilization * SOAP_FMAC4 soap_get_tt__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImageStabilization = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImageStabilization(soap, &a->ImageStabilization);
	soap_serialize_PointerTott__ImagingSettingsExtension202(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", -1, &a->ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	size_t soap_flag_ImageStabilization = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingSettingsExtension20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", &a->ImageStabilization, "tt:ImageStabilization"))
				{	soap_flag_ImageStabilization--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension202"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_new_tt__ImagingSettingsExtension20(struct soap *soap, int n)
{
	struct tt__ImagingSettingsExtension20 *p;
	struct tt__ImagingSettingsExtension20 *a = (struct tt__ImagingSettingsExtension20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettingsExtension20));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettingsExtension20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &a->Mode);
	a->CrGain = NULL;
	a->CbGain = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WhiteBalanceMode);
	soap_serialize_PointerTofloat(soap, &a->CrGain);
	soap_serialize_PointerTofloat(soap, &a->CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalance20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_new_tt__WhiteBalance20(struct soap *soap, int n)
{
	struct tt__WhiteBalance20 *p;
	struct tt__WhiteBalance20 *a = (struct tt__WhiteBalance20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalance20));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalance20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WideDynamicMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRange20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WideDynamicRange20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRange20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_new_tt__WideDynamicRange20(struct soap *soap, int n)
{
	struct tt__WideDynamicRange20 *p;
	struct tt__WideDynamicRange20 *a = (struct tt__WideDynamicRange20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WideDynamicRange20));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicRange20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &a->AutoFocusMode);
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
	soap_default_tt__StringAttrList(soap, &a->AFMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode);
	soap_serialize_PointerTofloat(soap, &a->DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &a->NearLimit);
	soap_serialize_PointerTofloat(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20 *a, const char *type)
{
	if (a->AFMode)
		soap_set_attr(soap, "AFMode", soap_tt__StringAttrList2s(soap, a->AFMode), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusConfiguration20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration20(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "AFMode", 1, 0), &a->AFMode))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_new_tt__FocusConfiguration20(struct soap *soap, int n)
{
	struct tt__FocusConfiguration20 *p;
	struct tt__FocusConfiguration20 *a = (struct tt__FocusConfiguration20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusConfiguration20));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusConfiguration20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &a->Mode);
	a->Priority = NULL;
	a->Window = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ExposureMode);
	soap_serialize_PointerTott__ExposurePriority(soap, &a->Priority);
	soap_serialize_PointerTott__Rectangle(soap, &a->Window);
	soap_serialize_PointerTofloat(soap, &a->MinExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MinGain);
	soap_serialize_PointerTofloat(soap, &a->MaxGain);
	soap_serialize_PointerTofloat(soap, &a->MinIris);
	soap_serialize_PointerTofloat(soap, &a->MaxIris);
	soap_serialize_PointerTofloat(soap, &a->ExposureTime);
	soap_serialize_PointerTofloat(soap, &a->Gain);
	soap_serialize_PointerTofloat(soap, &a->Iris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const struct tt__Exposure20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Exposure20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Exposure20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->Mode, "tt:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->Window, "tt:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_new_tt__Exposure20(struct soap *soap, int n)
{
	struct tt__Exposure20 *p;
	struct tt__Exposure20 *a = (struct tt__Exposure20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Exposure20));
	for (p = a; p && n--; p++)
		soap_default_tt__Exposure20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__BacklightCompensationMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensation20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BacklightCompensation20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensation20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_new_tt__BacklightCompensation20(struct soap *soap, int n)
{
	struct tt__BacklightCompensation20 *p;
	struct tt__BacklightCompensation20 *a = (struct tt__BacklightCompensation20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BacklightCompensation20));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensation20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus20Extension(struct soap *soap, const struct tt__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, struct tt__FocusStatus20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusStatus20Extension * SOAP_FMAC4 soap_new_tt__FocusStatus20Extension(struct soap *soap, int n)
{
	struct tt__FocusStatus20Extension *p;
	struct tt__FocusStatus20Extension *a = (struct tt__FocusStatus20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusStatus20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusStatus20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus20Extension(struct soap *soap, const struct tt__FocusStatus20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus20Extension(struct soap *soap, const struct tt__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, struct tt__ImagingStatus20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus20Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension * SOAP_FMAC4 soap_new_tt__ImagingStatus20Extension(struct soap *soap, int n)
{
	struct tt__ImagingStatus20Extension *p;
	struct tt__ImagingStatus20Extension *a = (struct tt__ImagingStatus20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingStatus20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingStatus20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus20Extension(struct soap *soap, const struct tt__ImagingStatus20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_tt__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus20(struct soap *soap, const struct tt__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, struct tt__FocusStatus20 *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusStatus20 * SOAP_FMAC4 soap_new_tt__FocusStatus20(struct soap *soap, int n)
{
	struct tt__FocusStatus20 *p;
	struct tt__FocusStatus20 *a = (struct tt__FocusStatus20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusStatus20));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusStatus20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus20(struct soap *soap, const struct tt__FocusStatus20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus20 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus20(struct soap *soap, const struct tt__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus20(soap, &a->FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &a->FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, struct tt__ImagingStatus20 *a, const char *type)
{
	size_t soap_flag_FocusStatus20 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ImagingStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus20(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus20 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &a->FocusStatus20, "tt:FocusStatus20"))
				{	soap_flag_FocusStatus20--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &a->Extension, "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingStatus20 * SOAP_FMAC4 soap_new_tt__ImagingStatus20(struct soap *soap, int n)
{
	struct tt__ImagingStatus20 *p;
	struct tt__ImagingStatus20 *a = (struct tt__ImagingStatus20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingStatus20));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingStatus20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus20(struct soap *soap, const struct tt__ImagingStatus20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ContinuousFocusOptions(struct soap *soap, const struct tt__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__ContinuousFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type))
		return soap->error;
	if (!a->Speed)
	{	if (soap_element_empty(soap, "tt:Speed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, struct tt__ContinuousFocusOptions *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ContinuousFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ContinuousFocusOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions * SOAP_FMAC4 soap_new_tt__ContinuousFocusOptions(struct soap *soap, int n)
{
	struct tt__ContinuousFocusOptions *p;
	struct tt__ContinuousFocusOptions *a = (struct tt__ContinuousFocusOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ContinuousFocusOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ContinuousFocusOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ContinuousFocusOptions(struct soap *soap, const struct tt__ContinuousFocusOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocusOptions(struct soap *soap, const struct tt__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions), type))
		return soap->error;
	if (!a->Distance)
	{	if (soap_element_empty(soap, "tt:Distance", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (!a->Speed)
	{	if (soap_element_empty(soap, "tt:Speed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelativeFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocusOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->Distance, "tt:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Distance || !a->Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelativeFocusOptions * SOAP_FMAC4 soap_new_tt__RelativeFocusOptions(struct soap *soap, int n)
{
	struct tt__RelativeFocusOptions *p;
	struct tt__RelativeFocusOptions *a = (struct tt__RelativeFocusOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelativeFocusOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__RelativeFocusOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocusOptions(struct soap *soap, const struct tt__RelativeFocusOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelativeFocusOptions(soap, tag ? tag : "tt:RelativeFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AbsoluteFocusOptions(struct soap *soap, const struct tt__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->Position);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct tt__AbsoluteFocusOptions *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AbsoluteFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AbsoluteFocusOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &a->Position, "tt:FloatRange"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_new_tt__AbsoluteFocusOptions(struct soap *soap, int n)
{
	struct tt__AbsoluteFocusOptions *p;
	struct tt__AbsoluteFocusOptions *a = (struct tt__AbsoluteFocusOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AbsoluteFocusOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AbsoluteFocusOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AbsoluteFocusOptions(struct soap *soap, const struct tt__AbsoluteFocusOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveOptions(struct soap *soap, struct tt__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MoveOptions(struct soap *soap, const struct tt__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &a->Continuous);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions(struct soap *soap, const char *tag, int id, const struct tt__MoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MoveOptions * SOAP_FMAC4 soap_in_tt__MoveOptions(struct soap *soap, const char *tag, struct tt__MoveOptions *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MoveOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions, sizeof(struct tt__MoveOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MoveOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions(soap, "tt:Relative", &a->Relative, "tt:RelativeFocusOptions"))
				{	soap_flag_Relative--;
					continue;
				}
			}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions, SOAP_TYPE_tt__MoveOptions, sizeof(struct tt__MoveOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MoveOptions * SOAP_FMAC4 soap_new_tt__MoveOptions(struct soap *soap, int n)
{
	struct tt__MoveOptions *p;
	struct tt__MoveOptions *a = (struct tt__MoveOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MoveOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveOptions(struct soap *soap, const struct tt__MoveOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveOptions(soap, tag ? tag : "tt:MoveOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions * SOAP_FMAC4 soap_get_tt__MoveOptions(struct soap *soap, struct tt__MoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Speed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ContinuousFocus(struct soap *soap, const struct tt__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Speed, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const struct tt__ContinuousFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, struct tt__ContinuousFocus *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ContinuousFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ContinuousFocus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ContinuousFocus * SOAP_FMAC4 soap_new_tt__ContinuousFocus(struct soap *soap, int n)
{
	struct tt__ContinuousFocus *p;
	struct tt__ContinuousFocus *a = (struct tt__ContinuousFocus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ContinuousFocus));
	for (p = a; p && n--; p++)
		soap_default_tt__ContinuousFocus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ContinuousFocus(struct soap *soap, const struct tt__ContinuousFocus *a, const char *tag, const char *type)
{
	if (soap_out_tt__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Distance);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocus(struct soap *soap, const struct tt__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, struct tt__RelativeFocus *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelativeFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Distance", &a->Distance, "xsd:float"))
				{	soap_flag_Distance--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelativeFocus * SOAP_FMAC4 soap_new_tt__RelativeFocus(struct soap *soap, int n)
{
	struct tt__RelativeFocus *p;
	struct tt__RelativeFocus *a = (struct tt__RelativeFocus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelativeFocus));
	for (p = a; p && n--; p++)
		soap_default_tt__RelativeFocus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocus(struct soap *soap, const struct tt__RelativeFocus *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AbsoluteFocus(struct soap *soap, const struct tt__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const struct tt__AbsoluteFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, struct tt__AbsoluteFocus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AbsoluteFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AbsoluteFocus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AbsoluteFocus * SOAP_FMAC4 soap_new_tt__AbsoluteFocus(struct soap *soap, int n)
{
	struct tt__AbsoluteFocus *p;
	struct tt__AbsoluteFocus *a = (struct tt__AbsoluteFocus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AbsoluteFocus));
	for (p = a; p && n--; p++)
		soap_default_tt__AbsoluteFocus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AbsoluteFocus(struct soap *soap, const struct tt__AbsoluteFocus *a, const char *tag, const char *type)
{
	if (soap_out_tt__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusMove(struct soap *soap, struct tt__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusMove(struct soap *soap, const struct tt__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocus(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &a->Continuous);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const struct tt__FocusMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, struct tt__FocusMove *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FocusMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusMove(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocus"))
				{	soap_flag_Absolute--;
					continue;
				}
			}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &a->Relative, "tt:RelativeFocus"))
				{	soap_flag_Relative--;
					continue;
				}
			}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocus"))
				{	soap_flag_Continuous--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusMove * SOAP_FMAC4 soap_new_tt__FocusMove(struct soap *soap, int n)
{
	struct tt__FocusMove *p;
	struct tt__FocusMove *a = (struct tt__FocusMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusMove));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusMove(struct soap *soap, const struct tt__FocusMove *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, struct tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions(struct soap *soap, const struct tt__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->YbGain);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (!a->YrGain)
	{	if (soap_element_empty(soap, "tt:YrGain", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->YrGain, ""))
		return soap->error;
	if (!a->YbGain)
	{	if (soap_element_empty(soap, "tt:YbGain", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->YbGain, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__WhiteBalanceOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WhiteBalanceMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", a->Mode, "tt:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || !a->YrGain || !a->YbGain))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions * SOAP_FMAC4 soap_new_tt__WhiteBalanceOptions(struct soap *soap, int n)
{
	struct tt__WhiteBalanceOptions *p;
	struct tt__WhiteBalanceOptions *a = (struct tt__WhiteBalanceOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalanceOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions(struct soap *soap, const struct tt__WhiteBalanceOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceOptions(soap, tag ? tag : "tt:WhiteBalanceOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRangeOptions(struct soap *soap, const struct tt__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRangeOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (!a->Level)
	{	if (soap_element_empty(soap, "tt:Level", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
