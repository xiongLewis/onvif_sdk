/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingCapabilities))
		soap_serialize_tt__RecordingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RecordingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingCapabilities **)soap_malloc(soap, sizeof(struct tt__RecordingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DisplayCapabilities))
		soap_serialize_tt__DisplayCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__DisplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DisplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DisplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DisplayCapabilities **)soap_malloc(soap, sizeof(struct tt__DisplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DisplayCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceIOCapabilities))
		soap_serialize_tt__DeviceIOCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceIOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceIOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceIOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceIOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		soap_serialize_tt__CapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		soap_serialize_tt__PTZCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, struct tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZCapabilities **)soap_malloc(soap, sizeof(struct tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		soap_serialize_tt__MediaCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilities **)soap_malloc(soap, sizeof(struct tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		soap_serialize_tt__ImagingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, struct tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingCapabilities **)soap_malloc(soap, sizeof(struct tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		soap_serialize_tt__EventCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, struct tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventCapabilities **)soap_malloc(soap, sizeof(struct tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		soap_serialize_tt__DeviceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		soap_serialize_tt__AnalyticsCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, struct tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(struct tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension))
		soap_serialize_tt__Dot11AvailableNetworksExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworksExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworksExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworksExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworksExtension **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworksExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworksExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, enum tt__Dot11AuthAndMangementSuite *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite ** SOAP_FMAC4 soap_in_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, enum tt__Dot11AuthAndMangementSuite **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11AuthAndMangementSuite **)soap_malloc(soap, sizeof(enum tt__Dot11AuthAndMangementSuite *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11AuthAndMangementSuite **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AuthAndMangementSuite(soap, tag ? tag : "tt:Dot11AuthAndMangementSuite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite ** SOAP_FMAC4 soap_get_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AuthAndMangementSuite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SignalStrength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, int id, enum tt__Dot11SignalStrength *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SignalStrength, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SignalStrength(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_in_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11SignalStrength **)soap_malloc(soap, sizeof(enum tt__Dot11SignalStrength *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SignalStrength(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_get_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSetExtension))
		soap_serialize_tt__Dot11PSKSetExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSetExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSetExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSetExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKSetExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension))
		soap_serialize_tt__Dot11SecurityConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSet))
		soap_serialize_tt__Dot11PSKSet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSet, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSet(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11PSKSet **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKSet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Cipher);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, int id, enum tt__Dot11Cipher *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Cipher, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Cipher(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_in_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11Cipher **)soap_malloc(soap, sizeof(enum tt__Dot11Cipher *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Cipher(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_get_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfiguration))
		soap_serialize_tt__Dot11SecurityConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SecurityConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		soap_serialize_tt__IPAddressFilterExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(struct tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilterExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2))
		soap_serialize_tt__NetworkZeroConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension))
		soap_serialize_tt__NetworkZeroConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		soap_serialize_tt__DynamicDNSInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		soap_serialize_tt__NTPInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, struct tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NTPInformationExtension **)soap_malloc(soap, sizeof(struct tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		soap_serialize_tt__DNSInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		soap_serialize_tt__HostnameInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, struct tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(struct tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
		soap_serialize_tt__NetworkHostExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkHostExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkHostExtension **)soap_malloc(soap, sizeof(struct tt__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkHostExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		soap_serialize_tt__NetworkProtocolExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(struct tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocolExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		soap_serialize_tt__IPv6ConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6ConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		soap_serialize_tt__PrefixedIPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		soap_serialize_tt__PrefixedIPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		soap_serialize_tt__IPv4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4Configuration **)soap_malloc(soap, sizeof(struct tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		soap_serialize_tt__IPv6Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6Configuration **)soap_malloc(soap, sizeof(struct tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		soap_serialize_tt__NetworkInterfaceConnectionSetting(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension2))
		soap_serialize_tt__NetworkInterfaceExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Configuration))
		soap_serialize_tt__Dot11Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot11Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Configuration **)soap_malloc(soap, sizeof(struct tt__Dot11Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot3Configuration))
		soap_serialize_tt__Dot3Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot3Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot3Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot3Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot3Configuration **)soap_malloc(soap, sizeof(struct tt__Dot3Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot3Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transport))
		soap_serialize_tt__Transport(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transport(struct soap *soap, const char *tag, int id, struct tt__Transport *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transport, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_tt__Transport(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_in_PointerTott__Transport(struct soap *soap, const char *tag, struct tt__Transport **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transport **)soap_malloc(soap, sizeof(struct tt__Transport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transport(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transport(soap, tag ? tag : "tt:Transport", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_get_PointerTott__Transport(struct soap *soap, struct tt__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension))
		soap_serialize_tt__AudioDecoderConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:AudioDecoderConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G726DecOptions))
		soap_serialize_tt__G726DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G726DecOptions(struct soap *soap, const char *tag, int id, struct tt__G726DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G726DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__G726DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__G726DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G726DecOptions(struct soap *soap, const char *tag, struct tt__G726DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__G726DecOptions **)soap_malloc(soap, sizeof(struct tt__G726DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__G726DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__G726DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__G726DecOptions(soap, tag ? tag : "tt:G726DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G726DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G711DecOptions))
		soap_serialize_tt__G711DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G711DecOptions(struct soap *soap, const char *tag, int id, struct tt__G711DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G711DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__G711DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__G711DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G711DecOptions(struct soap *soap, const char *tag, struct tt__G711DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__G711DecOptions **)soap_malloc(soap, sizeof(struct tt__G711DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__G711DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__G711DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__G711DecOptions(soap, tag ? tag : "tt:G711DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G711DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AACDecOptions))
		soap_serialize_tt__AACDecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AACDecOptions(struct soap *soap, const char *tag, int id, struct tt__AACDecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AACDecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AACDecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AACDecOptions ** SOAP_FMAC4 soap_in_PointerTott__AACDecOptions(struct soap *soap, const char *tag, struct tt__AACDecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AACDecOptions **)soap_malloc(soap, sizeof(struct tt__AACDecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AACDecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AACDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AACDecOptions(soap, tag ? tag : "tt:AACDecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AACDecOptions ** SOAP_FMAC4 soap_get_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension))
		soap_serialize_tt__VideoDecoderConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoDecoderConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoDecoderConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4DecOptions))
		soap_serialize_tt__Mpeg4DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4DecOptions(struct soap *soap, const char *tag, int id, struct tt__Mpeg4DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4DecOptions(struct soap *soap, const char *tag, struct tt__Mpeg4DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4DecOptions **)soap_malloc(soap, sizeof(struct tt__Mpeg4DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4DecOptions(soap, tag ? tag : "tt:Mpeg4DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264DecOptions))
		soap_serialize_tt__H264DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264DecOptions(struct soap *soap, const char *tag, int id, struct tt__H264DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264DecOptions ** SOAP_FMAC4 soap_in_PointerTott__H264DecOptions(struct soap *soap, const char *tag, struct tt__H264DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264DecOptions **)soap_malloc(soap, sizeof(struct tt__H264DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264DecOptions(soap, tag ? tag : "tt:H264DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264DecOptions ** SOAP_FMAC4 soap_get_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegDecOptions))
		soap_serialize_tt__JpegDecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegDecOptions(struct soap *soap, const char *tag, int id, struct tt__JpegDecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegDecOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegDecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegDecOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegDecOptions(struct soap *soap, const char *tag, struct tt__JpegDecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegDecOptions **)soap_malloc(soap, sizeof(struct tt__JpegDecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegDecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegDecOptions(soap, tag ? tag : "tt:JpegDecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegDecOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension))
		soap_serialize_tt__PTZStatusFilterOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZStatusFilterOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatusFilterOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZStatusFilterOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, tag ? tag : "tt:PTZStatusFilterOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2))
		soap_serialize_tt__MetadataConfigurationOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension2(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension))
		soap_serialize_tt__MetadataConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptions))
		soap_serialize_tt__PTZStatusFilterOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, struct tt__PTZStatusFilterOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatusFilterOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(struct tt__PTZStatusFilterOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatusFilterOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, tag ? tag : "tt:PTZStatusFilterOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy))
		soap_serialize__tt__EventSubscription_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _tt__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tt__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _tt__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag ? tag : "tt:EventSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		soap_serialize_wsnt__FilterType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, struct wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__FilterType **)soap_malloc(soap, sizeof(struct wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOption))
		soap_serialize_tt__AudioEncoderConfigurationOption(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfigurationOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOption, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOption **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfigurationOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag ? tag : "tt:AudioEncoderConfigurationOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceOptionsExtension))
		soap_serialize_tt__AudioSourceOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__AudioSourceOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioSourceOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(struct tt__AudioSourceOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, tag ? tag : "tt:AudioSourceOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution2))
		soap_serialize_tt__VideoResolution2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution2(struct soap *soap, const char *tag, int id, struct tt__VideoResolution2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution2 ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution2(struct soap *soap, const char *tag, struct tt__VideoResolution2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution2 **)soap_malloc(soap, sizeof(struct tt__VideoResolution2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution2(soap, tag ? tag : "tt:VideoResolution2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution2 ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		soap_serialize_tt__FloatRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, struct tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatRange **)soap_malloc(soap, sizeof(struct tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Profile(struct soap *soap, const char *tag, int id, enum tt__H264Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_in_PointerTott__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__H264Profile **)soap_malloc(soap, sizeof(enum tt__H264Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_get_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, int id, enum tt__Mpeg4Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Mpeg4Profile **)soap_malloc(soap, sizeof(enum tt__Mpeg4Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		soap_serialize_tt__VideoResolution(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, struct tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution **)soap_malloc(soap, sizeof(struct tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
		soap_serialize_tt__H264Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, struct tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options2 **)soap_malloc(soap, sizeof(struct tt__H264Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
		soap_serialize_tt__Mpeg4Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
		soap_serialize_tt__JpegOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, struct tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions2 **)soap_malloc(soap, sizeof(struct tt__JpegOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		soap_serialize_tt__H264Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, struct tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, struct tt__H264Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options **)soap_malloc(soap, sizeof(struct tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, struct tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		soap_serialize_tt__Mpeg4Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		soap_serialize_tt__JpegOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, struct tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions **)soap_malloc(soap, sizeof(struct tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptionsExtension))
		soap_serialize_tt__RotateOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__RotateOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, struct tt__RotateOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptionsExtension **)soap_malloc(soap, sizeof(struct tt__RotateOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntItems(struct soap *soap, struct tt__IntItems *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntItems))
		soap_serialize_tt__IntItems(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntItems(struct soap *soap, const char *tag, int id, struct tt__IntItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntItems, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntItems(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntItems ** SOAP_FMAC4 soap_in_PointerTott__IntItems(struct soap *soap, const char *tag, struct tt__IntItems **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntItems **)soap_malloc(soap, sizeof(struct tt__IntItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntItems(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntItems, sizeof(struct tt__IntItems), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntItems(struct soap *soap, struct tt__IntItems *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntItems(soap, tag ? tag : "tt:IntItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntItems ** SOAP_FMAC4 soap_get_PointerTott__IntItems(struct soap *soap, struct tt__IntItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RotateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateMode(struct soap *soap, const char *tag, int id, enum tt__RotateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_in_PointerTott__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__RotateMode **)soap_malloc(soap, sizeof(enum tt__RotateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_get_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientationMode(struct soap *soap, const char *tag, int id, enum tt__SceneOrientationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SceneOrientationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__SceneOrientationMode ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientationMode(struct soap *soap, const char *tag, enum tt__SceneOrientationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__SceneOrientationMode **)soap_malloc(soap, sizeof(enum tt__SceneOrientationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SceneOrientationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientationMode(soap, tag ? tag : "tt:SceneOrientationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationMode ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptions))
		soap_serialize_tt__RotateOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptions(struct soap *soap, const char *tag, int id, struct tt__RotateOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_in_PointerTott__RotateOptions(struct soap *soap, const char *tag, struct tt__RotateOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptions **)soap_malloc(soap, sizeof(struct tt__RotateOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_get_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangleRange))
		soap_serialize_tt__IntRectangleRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, int id, struct tt__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangleRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangleRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangleRange **)soap_malloc(soap, sizeof(struct tt__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangleRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensProjection))
		soap_serialize_tt__LensProjection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensProjection(struct soap *soap, const char *tag, int id, struct tt__LensProjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensProjection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensProjection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensProjection ** SOAP_FMAC4 soap_in_PointerTott__LensProjection(struct soap *soap, const char *tag, struct tt__LensProjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensProjection **)soap_malloc(soap, sizeof(struct tt__LensProjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensProjection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensProjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensProjection ** SOAP_FMAC4 soap_get_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensOffset))
		soap_serialize_tt__LensOffset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensOffset(struct soap *soap, const char *tag, int id, struct tt__LensOffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensOffset, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensOffset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensOffset ** SOAP_FMAC4 soap_in_PointerTott__LensOffset(struct soap *soap, const char *tag, struct tt__LensOffset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensOffset **)soap_malloc(soap, sizeof(struct tt__LensOffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensOffset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensOffset ** SOAP_FMAC4 soap_get_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateExtension))
		soap_serialize_tt__RotateExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap *soap, const char *tag, int id, struct tt__RotateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap *soap, const char *tag, struct tt__RotateExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateExtension **)soap_malloc(soap, sizeof(struct tt__RotateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientation))
		soap_serialize_tt__SceneOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientation(struct soap *soap, const char *tag, int id, struct tt__SceneOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SceneOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SceneOrientation ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientation(struct soap *soap, const char *tag, struct tt__SceneOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SceneOrientation **)soap_malloc(soap, sizeof(struct tt__SceneOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SceneOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SceneOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientation, sizeof(struct tt__SceneOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SceneOrientation ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensDescription))
		soap_serialize_tt__LensDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensDescription(struct soap *soap, const char *tag, int id, struct tt__LensDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensDescription ** SOAP_FMAC4 soap_in_PointerTott__LensDescription(struct soap *soap, const char *tag, struct tt__LensDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensDescription **)soap_malloc(soap, sizeof(struct tt__LensDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensDescription ** SOAP_FMAC4 soap_get_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2))
		soap_serialize_tt__VideoSourceConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rotate))
		soap_serialize_tt__Rotate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap *soap, const char *tag, int id, struct tt__Rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rotate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rotate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap *soap, const char *tag, struct tt__Rotate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rotate **)soap_malloc(soap, sizeof(struct tt__Rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rotate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rotate(soap, tag ? tag : "tt:Rotate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap *soap, struct tt__Rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension2))
		soap_serialize_tt__ProfileExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension2 **)soap_malloc(soap, sizeof(struct tt__ProfileExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfiguration))
		soap_serialize_tt__AudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfiguration))
		soap_serialize_tt__AudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
		soap_serialize_tt__ProfileExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension **)soap_malloc(soap, sizeof(struct tt__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
		soap_serialize_tt__MetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, struct tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfiguration **)soap_malloc(soap, sizeof(struct tt__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		soap_serialize_tt__PTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, struct tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfiguration **)soap_malloc(soap, sizeof(struct tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
		soap_serialize_tt__VideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
		soap_serialize_tt__AudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		soap_serialize_tt__VideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
		soap_serialize_tt__AudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
		soap_serialize_tt__VideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension2))
		soap_serialize_tt__VideoSourceExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
		soap_serialize_tt__ImagingSettings20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettings20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		soap_serialize_tt__IntRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, struct tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, struct tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRange **)soap_malloc(soap, sizeof(struct tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, struct tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocationEntity))
		soap_serialize_tt__LocationEntity(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocationEntity(struct soap *soap, const char *tag, int id, struct tt__LocationEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocationEntity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocationEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocationEntity ** SOAP_FMAC4 soap_in_PointerTott__LocationEntity(struct soap *soap, const char *tag, struct tt__LocationEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocationEntity **)soap_malloc(soap, sizeof(struct tt__LocationEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocationEntity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocationEntity, sizeof(struct tt__LocationEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocationEntity ** SOAP_FMAC4 soap_get_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfigurationData))
		soap_serialize_tds__StorageConfigurationData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, int id, struct tds__StorageConfigurationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfigurationData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfigurationData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, struct tds__StorageConfigurationData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfigurationData **)soap_malloc(soap, sizeof(struct tds__StorageConfigurationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfigurationData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfiguration))
		soap_serialize_tds__StorageConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, struct tds__StorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, struct tds__StorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfiguration **)soap_malloc(soap, sizeof(struct tds__StorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		soap_serialize__tds__GetSystemUrisResponse_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		soap_serialize_tt__SystemLogUriList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, struct tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUriList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUriList **)soap_malloc(soap, sizeof(struct tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUriList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		soap_serialize_tt__Dot11AvailableNetworks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		soap_serialize_tt__Dot11Status(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, struct tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Status **)soap_malloc(soap, sizeof(struct tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		soap_serialize_tt__Dot11Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, struct tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Capabilities **)soap_malloc(soap, sizeof(struct tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		soap_serialize_tt__RelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutputSettings **)soap_malloc(soap, sizeof(struct tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
		soap_serialize_tt__RelayOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, struct tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutput **)soap_malloc(soap, sizeof(struct tt__RelayOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfiguration))
		soap_serialize_tt__Dot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformation))
		soap_serialize_tt__CertificateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformation(struct soap *soap, const char *tag, int id, struct tt__CertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateInformation **)soap_malloc(soap, sizeof(struct tt__CertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateWithPrivateKey))
		soap_serialize_tt__CertificateWithPrivateKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, struct tt__CertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(struct tt__CertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateWithPrivateKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateStatus))
		soap_serialize_tt__CertificateStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, struct tt__CertificateStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_in_PointerTott__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateStatus **)soap_malloc(soap, sizeof(struct tt__CertificateStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_get_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Certificate))
		soap_serialize_tt__Certificate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Certificate(struct soap *soap, const char *tag, int id, struct tt__Certificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Certificate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Certificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_in_PointerTott__Certificate(struct soap *soap, const char *tag, struct tt__Certificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Certificate **)soap_malloc(soap, sizeof(struct tt__Certificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Certificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_get_PointerTott__Certificate(struct soap *soap, struct tt__Certificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		soap_serialize_tt__BinaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, struct tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BinaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BinaryData **)soap_malloc(soap, sizeof(struct tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BinaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		soap_serialize_tt__IPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddressFilter **)soap_malloc(soap, sizeof(struct tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfiguration))
		soap_serialize_tt__NetworkZeroConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Address(soap, tag ? tag : "tt:IPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Address(soap, tag ? tag : "tt:IPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		soap_serialize_tt__NetworkGateway(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, struct tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkGateway **)soap_malloc(soap, sizeof(struct tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocol))
		soap_serialize_tt__NetworkProtocol(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocol, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkProtocol **)soap_malloc(soap, sizeof(struct tt__NetworkProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		soap_serialize_tt__NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterface))
		soap_serialize_tt__NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterface **)soap_malloc(soap, sizeof(struct tt__NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		soap_serialize_tt__DynamicDNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		soap_serialize_tt__NTPInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, struct tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NTPInformation **)soap_malloc(soap, sizeof(struct tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		soap_serialize_tt__IPAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, struct tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddress **)soap_malloc(soap, sizeof(struct tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		soap_serialize_tt__DNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, struct tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DNSInformation **)soap_malloc(soap, sizeof(struct tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		soap_serialize_tt__HostnameInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, struct tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__HostnameInformation **)soap_malloc(soap, sizeof(struct tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		soap_serialize_tt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, struct tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Capabilities **)soap_malloc(soap, sizeof(struct tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__CapabilityCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, int id, enum tt__CapabilityCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilityCategory, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilityCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_in_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__CapabilityCategory **)soap_malloc(soap, sizeof(enum tt__CapabilityCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilityCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_get_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, struct tt__User *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		soap_serialize_tt__User(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, struct tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, struct tt__User **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__User **)soap_malloc(soap, sizeof(struct tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__User(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, struct tt__User *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, struct tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RemoteUser))
		soap_serialize_tt__RemoteUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RemoteUser(struct soap *soap, const char *tag, int id, struct tt__RemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_in_PointerTott__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RemoteUser **)soap_malloc(soap, sizeof(struct tt__RemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_get_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		soap_serialize_tt__NetworkHost(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, struct tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkHost(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkHost **)soap_malloc(soap, sizeof(struct tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkHost(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Scope))
		soap_serialize_tt__Scope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Scope(struct soap *soap, const char *tag, int id, struct tt__Scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Scope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Scope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_in_PointerTott__Scope(struct soap *soap, const char *tag, struct tt__Scope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Scope **)soap_malloc(soap, sizeof(struct tt__Scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Scope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_get_PointerTott__Scope(struct soap *soap, struct tt__Scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLog))
		soap_serialize_tt__SystemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLog(struct soap *soap, const char *tag, int id, struct tt__SystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLog, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_in_PointerTott__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLog **)soap_malloc(soap, sizeof(struct tt__SystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_get_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportInformation))
		soap_serialize_tt__SupportInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportInformation(struct soap *soap, const char *tag, int id, struct tt__SupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_in_PointerTott__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportInformation **)soap_malloc(soap, sizeof(struct tt__SupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_get_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BackupFile))
		soap_serialize_tt__BackupFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BackupFile(struct soap *soap, const char *tag, int id, struct tt__BackupFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BackupFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BackupFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_in_PointerTott__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BackupFile **)soap_malloc(soap, sizeof(struct tt__BackupFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BackupFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_get_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		soap_serialize_tt__AttachmentData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, struct tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AttachmentData **)soap_malloc(soap, sizeof(struct tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		soap_serialize_tt__SystemDateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, struct tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemDateTime **)soap_malloc(soap, sizeof(struct tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		soap_serialize_tt__DateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, struct tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, struct tt__DateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DateTime **)soap_malloc(soap, sizeof(struct tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, struct tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		soap_serialize_tt__TimeZone(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, struct tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TimeZone(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TimeZone **)soap_malloc(soap, sizeof(struct tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TimeZone(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		soap_serialize_tds__DeviceServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, struct tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(struct tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__DeviceServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		soap_serialize_tds__Service(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, struct tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__Service(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, struct tds__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__Service **)soap_malloc(soap, sizeof(struct tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__Service(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, struct tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StorageConfigurationData_Extension))
		soap_serialize__tds__StorageConfigurationData_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, struct _tds__StorageConfigurationData_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StorageConfigurationData_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StorageConfigurationData_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, struct _tds__StorageConfigurationData_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StorageConfigurationData_Extension **)soap_malloc(soap, sizeof(struct _tds__StorageConfigurationData_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StorageConfigurationData_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StorageConfigurationData_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__UserCredential))
		soap_serialize_tds__UserCredential(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__UserCredential(struct soap *soap, const char *tag, int id, struct tds__UserCredential *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__UserCredential, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__UserCredential(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__UserCredential ** SOAP_FMAC4 soap_in_PointerTotds__UserCredential(struct soap *soap, const char *tag, struct tds__UserCredential **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__UserCredential **)soap_malloc(soap, sizeof(struct tds__UserCredential *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__UserCredential(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__UserCredential **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__UserCredential ** SOAP_FMAC4 soap_get_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UserCredential_Extension))
		soap_serialize__tds__UserCredential_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, struct _tds__UserCredential_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UserCredential_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UserCredential_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, struct _tds__UserCredential_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UserCredential_Extension **)soap_malloc(soap, sizeof(struct _tds__UserCredential_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UserCredential_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UserCredential_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__MiscCapabilities))
		soap_serialize_tds__MiscCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, int id, struct tds__MiscCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__MiscCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__MiscCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, struct tds__MiscCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__MiscCapabilities **)soap_malloc(soap, sizeof(struct tds__MiscCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__MiscCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SystemCapabilities))
		soap_serialize_tds__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tds__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SystemCapabilities **)soap_malloc(soap, sizeof(struct tds__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SecurityCapabilities))
		soap_serialize_tds__SecurityCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tds__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tds__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__NetworkCapabilities))
		soap_serialize_tds__NetworkCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tds__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tds__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		soap_serialize_tt__OnvifVersion(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, struct tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OnvifVersion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OnvifVersion **)soap_malloc(soap, sizeof(struct tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OnvifVersion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		soap_serialize__tds__Service_Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, struct _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__Service_Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__Service_Capabilities **)soap_malloc(soap, sizeof(struct _tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__Service_Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobState(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobState);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobState(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobState, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobState(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobState(soap, tag ? tag : "tt:RecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobState(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobMode(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobMode);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobMode(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobMode, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobMode(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobMode(soap, tag ? tag : "tt:RecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobMode(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__XPathExpression(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__XPathExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__XPathExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__XPathExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__XPathExpression, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__XPathExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__XPathExpression(soap, tag ? tag : "tt:XPathExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__XPathExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Description(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Description);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Description, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Description(soap, tag ? tag : "tt:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AuxiliaryData, 1, 0, 128, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase, 1, 0, -1, "[ -~]{8,63}");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceTokenList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceTokenList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceTokenList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceTokenList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceTokenList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceTokenList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceTokenList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceTokenList(soap, tag ? tag : "tt:ReferenceTokenList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceTokenList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceTokenList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__FloatList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__FloatList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__FloatList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatList(soap, tag ? tag : "tt:FloatList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IntList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IntList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IntList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 5, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 5, 0, -1, "\\+?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 5, 0, -1, "[-+]?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 4, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
