/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_in__tds__GetStorageConfiguration(struct soap *soap, const char *tag, struct _tds__GetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_new__tds__GetStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__GetStorageConfiguration *p;
	struct _tds__GetStorageConfiguration *a = (struct _tds__GetStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfiguration(struct soap *soap, const struct _tds__GetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_get__tds__GetStorageConfiguration(struct soap *soap, struct _tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateStorageConfigurationResponse(struct soap *soap, struct _tds__CreateStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateStorageConfigurationResponse(struct soap *soap, const struct _tds__CreateStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "tds:Token");
	if (!a->Token)
	{	if (soap_element_empty(soap, "tds:Token", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateStorageConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Token))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_new__tds__CreateStorageConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__CreateStorageConfigurationResponse *p;
	struct _tds__CreateStorageConfigurationResponse *a = (struct _tds__CreateStorageConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateStorageConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateStorageConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateStorageConfigurationResponse(struct soap *soap, const struct _tds__CreateStorageConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateStorageConfigurationResponse(soap, tag ? tag : "tds:CreateStorageConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateStorageConfigurationResponse(struct soap *soap, struct _tds__CreateStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateStorageConfiguration(struct soap *soap, struct _tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateStorageConfiguration(struct soap *soap, const struct _tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &a->StorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfiguration), type))
		return soap->error;
	if (!a->StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", -1, &a->StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, struct _tds__CreateStorageConfiguration *a, const char *type)
{
	size_t soap_flag_StorageConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateStorageConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", &a->StorageConfiguration, "tds:StorageConfigurationData"))
				{	soap_flag_StorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_new__tds__CreateStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__CreateStorageConfiguration *p;
	struct _tds__CreateStorageConfiguration *a = (struct _tds__CreateStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateStorageConfiguration(struct soap *soap, const struct _tds__CreateStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get__tds__CreateStorageConfiguration(struct soap *soap, struct _tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__StorageConfiguration(struct soap *soap, const struct tds__StorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfiguration(struct soap *soap, const char *tag, int id, const struct tds__StorageConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfiguration), type))
		return soap->error;
	if (!a->Data)
	{	if (soap_element_empty(soap, "tds:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_in_tds__StorageConfiguration(struct soap *soap, const char *tag, struct tds__StorageConfiguration *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__StorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__StorageConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:Data", &a->Data, "tds:StorageConfigurationData"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__StorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_new_tds__StorageConfiguration(struct soap *soap, int n)
{
	struct tds__StorageConfiguration *p;
	struct tds__StorageConfiguration *a = (struct tds__StorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__StorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageConfiguration(struct soap *soap, const struct tds__StorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_get_tds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfigurationsResponse(struct soap *soap, struct _tds__GetStorageConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeStorageConfigurations = 0;
	a->StorageConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfigurationsResponse(struct soap *soap, const struct _tds__GetStorageConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->StorageConfigurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeStorageConfigurations; i++)
		{
			soap_embedded(soap, a->StorageConfigurations + i, SOAP_TYPE_tds__StorageConfiguration);
			soap_serialize_tds__StorageConfiguration(soap, a->StorageConfigurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeStorageConfigurations");
	if (a->StorageConfigurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeStorageConfigurations; i++)
			if (soap_out_tds__StorageConfiguration(soap, "tds:StorageConfigurations", -1, a->StorageConfigurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_StorageConfigurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetStorageConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:StorageConfigurations", 1, NULL))
			{	if (a->StorageConfigurations == NULL)
				{	if (soap_blist_StorageConfigurations == NULL)
						soap_blist_StorageConfigurations = soap_alloc_block(soap);
					a->StorageConfigurations = (struct tds__StorageConfiguration *)soap_push_block_max(soap, soap_blist_StorageConfigurations, sizeof(struct tds__StorageConfiguration));
					if (a->StorageConfigurations == NULL)
						return NULL;
					soap_default_tds__StorageConfiguration(soap, a->StorageConfigurations);
				}
				soap_revert(soap);
				if (soap_in_tds__StorageConfiguration(soap, "tds:StorageConfigurations", a->StorageConfigurations, "tds:StorageConfiguration"))
				{	a->__sizeStorageConfigurations++;
					a->StorageConfigurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeStorageConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->StorageConfigurations)
			soap_pop_block(soap, soap_blist_StorageConfigurations);
		if (a->__sizeStorageConfigurations)
		{	a->StorageConfigurations = (struct tds__StorageConfiguration *)soap_save_block(soap, soap_blist_StorageConfigurations, NULL, 1);
		}
		else
		{	a->StorageConfigurations = NULL;
			if (soap_blist_StorageConfigurations)
				soap_end_block(soap, soap_blist_StorageConfigurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_new__tds__GetStorageConfigurationsResponse(struct soap *soap, int n)
{
	struct _tds__GetStorageConfigurationsResponse *p;
	struct _tds__GetStorageConfigurationsResponse *a = (struct _tds__GetStorageConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfigurationsResponse(struct soap *soap, const struct _tds__GetStorageConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfigurationsResponse(soap, tag ? tag : "tds:GetStorageConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationsResponse(struct soap *soap, struct _tds__GetStorageConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfigurations(struct soap *soap, struct _tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfigurations(struct soap *soap, const struct _tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_in__tds__GetStorageConfigurations(struct soap *soap, const char *tag, struct _tds__GetStorageConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetStorageConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_new__tds__GetStorageConfigurations(struct soap *soap, int n)
{
	struct _tds__GetStorageConfigurations *p;
	struct _tds__GetStorageConfigurations *a = (struct _tds__GetStorageConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfigurations(struct soap *soap, const struct _tds__GetStorageConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_get__tds__GetStorageConfigurations(struct soap *soap, struct _tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->UploadUri);
	soap_serialize_xsd__duration(soap, (char*const*)&a->ExpectedDownTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (!a->UploadUri)
	{	if (soap_element_empty(soap, "tds:UploadUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, (char*const*)&a->UploadUri, ""))
		return soap->error;
	if (!a->ExpectedDownTime)
	{	if (soap_element_empty(soap, "tds:ExpectedDownTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, (char*const*)&a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__StartSystemRestoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestoreResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", (char**)&a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", (char**)&a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->UploadUri || !a->ExpectedDownTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_new__tds__StartSystemRestoreResponse(struct soap *soap, int n)
{
	struct _tds__StartSystemRestoreResponse *p;
	struct _tds__StartSystemRestoreResponse *a = (struct _tds__StartSystemRestoreResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartSystemRestoreResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__StartSystemRestoreResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag ? tag : "tds:StartSystemRestoreResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__StartSystemRestore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestore(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_new__tds__StartSystemRestore(struct soap *soap, int n)
{
	struct _tds__StartSystemRestore *p;
	struct _tds__StartSystemRestore *a = (struct _tds__StartSystemRestore*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartSystemRestore));
	for (p = a; p && n--; p++)
		soap_default__tds__StartSystemRestore(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->UploadDelay);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->UploadUri);
	soap_serialize_xsd__duration(soap, (char*const*)&a->UploadDelay);
	soap_serialize_xsd__duration(soap, (char*const*)&a->ExpectedDownTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (!a->UploadUri)
	{	if (soap_element_empty(soap, "tds:UploadUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, (char*const*)&a->UploadUri, ""))
		return soap->error;
	if (!a->UploadDelay)
	{	if (soap_element_empty(soap, "tds:UploadDelay", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, (char*const*)&a->UploadDelay, ""))
		return soap->error;
	if (!a->ExpectedDownTime)
	{	if (soap_element_empty(soap, "tds:ExpectedDownTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, (char*const*)&a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_UploadDelay = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__StartFirmwareUpgradeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgradeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", (char**)&a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			}
			if (soap_flag_UploadDelay && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:UploadDelay", (char**)&a->UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", (char**)&a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->UploadUri || !a->UploadDelay || !a->ExpectedDownTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_new__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n)
{
	struct _tds__StartFirmwareUpgradeResponse *p;
	struct _tds__StartFirmwareUpgradeResponse *a = (struct _tds__StartFirmwareUpgradeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartFirmwareUpgradeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__StartFirmwareUpgradeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag ? tag : "tds:StartFirmwareUpgradeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__StartFirmwareUpgrade*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgrade(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_new__tds__StartFirmwareUpgrade(struct soap *soap, int n)
{
	struct _tds__StartFirmwareUpgrade *p;
	struct _tds__StartFirmwareUpgrade *a = (struct _tds__StartFirmwareUpgrade*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartFirmwareUpgrade));
	for (p = a; p && n--; p++)
		soap_default__tds__StartFirmwareUpgrade(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemUrisResponse_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse_Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_new__tds__GetSystemUrisResponse_Extension(struct soap *soap, int n)
{
	struct _tds__GetSystemUrisResponse_Extension *p;
	struct _tds__GetSystemUrisResponse_Extension *a = (struct _tds__GetSystemUrisResponse_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUrisResponse_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUrisResponse_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSystemLog = 0;
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < (int)a->__sizeSystemLog; i++)
		{
			soap_embedded(soap, a->SystemLog + i, SOAP_TYPE_tt__SystemLogUri);
			soap_serialize_tt__SystemLogUri(soap, a->SystemLog + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUriList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type))
		return soap->error;
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < (int)a->__sizeSystemLog; i++)
			if (soap_out_tt__SystemLogUri(soap, "tt:SystemLog", -1, a->SystemLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList *a, const char *type)
{
	struct soap_blist *soap_blist_SystemLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemLogUriList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUriList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SystemLog", 1, NULL))
			{	if (a->SystemLog == NULL)
				{	if (soap_blist_SystemLog == NULL)
						soap_blist_SystemLog = soap_alloc_block(soap);
					a->SystemLog = (struct tt__SystemLogUri *)soap_push_block_max(soap, soap_blist_SystemLog, sizeof(struct tt__SystemLogUri));
					if (a->SystemLog == NULL)
						return NULL;
					soap_default_tt__SystemLogUri(soap, a->SystemLog);
				}
				soap_revert(soap);
				if (soap_in_tt__SystemLogUri(soap, "tt:SystemLog", a->SystemLog, "tt:SystemLogUri"))
				{	a->__sizeSystemLog++;
					a->SystemLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SystemLog)
			soap_pop_block(soap, soap_blist_SystemLog);
		if (a->__sizeSystemLog)
		{	a->SystemLog = (struct tt__SystemLogUri *)soap_save_block(soap, soap_blist_SystemLog, NULL, 1);
		}
		else
		{	a->SystemLog = NULL;
			if (soap_blist_SystemLog)
				soap_end_block(soap, soap_blist_SystemLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_new_tt__SystemLogUriList(struct soap *soap, int n)
{
	struct tt__SystemLogUriList *p;
	struct tt__SystemLogUriList *a = (struct tt__SystemLogUriList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLogUriList));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogUriList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLogUris = NULL;
	soap_default_xsd__anyURI(soap, &a->SupportInfoUri);
	soap_default_xsd__anyURI(soap, &a->SystemBackupUri);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLogUriList(soap, &a->SystemLogUris);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SupportInfoUri);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->SystemLogUris, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SupportInfoUri", -1, (char*const*)&a->SupportInfoUri, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SystemBackupUri", -1, (char*const*)&a->SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse *a, const char *type)
{
	size_t soap_flag_SystemLogUris = 1;
	size_t soap_flag_SupportInfoUri = 1;
	size_t soap_flag_SystemBackupUri = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemUrisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris--;
					continue;
				}
			}
			if (soap_flag_SupportInfoUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:SupportInfoUri", (char**)&a->SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri--;
					continue;
				}
			}
			if (soap_flag_SystemBackupUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:SystemBackupUri", (char**)&a->SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_new__tds__GetSystemUrisResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemUrisResponse *p;
	struct _tds__GetSystemUrisResponse *a = (struct _tds__GetSystemUrisResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUrisResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUrisResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUrisResponse(soap, tag ? tag : "tds:GetSystemUrisResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemUris*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUris(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_new__tds__GetSystemUris(struct soap *soap, int n)
{
	struct _tds__GetSystemUris *p;
	struct _tds__GetSystemUris *a = (struct _tds__GetSystemUris*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUris));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUris(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->__sizeAuthAndMangementSuite = 0;
	a->AuthAndMangementSuite = NULL;
	a->__sizePairCipher = 0;
	a->PairCipher = NULL;
	a->__sizeGroupCipher = 0;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, (char*const*)&a->BSSID);
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthAndMangementSuite; i++)
		{
			soap_embedded(soap, a->AuthAndMangementSuite + i, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
		}
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizePairCipher; i++)
		{
			soap_embedded(soap, a->PairCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizeGroupCipher; i++)
		{
			soap_embedded(soap, a->GroupCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const struct tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, (char*const*)&a->BSSID, ""))
		return soap->error;
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthAndMangementSuite; i++)
			if (soap_out_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, a->AuthAndMangementSuite + i, ""))
				return soap->error;
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizePairCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:PairCipher", -1, a->PairCipher + i, ""))
				return soap->error;
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizeGroupCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:GroupCipher", -1, a->GroupCipher + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	struct soap_blist *soap_blist_AuthAndMangementSuite = NULL;
	struct soap_blist *soap_blist_PairCipher = NULL;
	struct soap_blist *soap_blist_GroupCipher = NULL;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Dot11AvailableNetworks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11AvailableNetworks(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:BSSID", (char**)&a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuthAndMangementSuite", 1, NULL))
			{	if (a->AuthAndMangementSuite == NULL)
				{	if (soap_blist_AuthAndMangementSuite == NULL)
						soap_blist_AuthAndMangementSuite = soap_alloc_block(soap);
					a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_push_block_max(soap, soap_blist_AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite));
					if (a->AuthAndMangementSuite == NULL)
						return NULL;
					soap_default_tt__Dot11AuthAndMangementSuite(soap, a->AuthAndMangementSuite);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", a->AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
				{	a->__sizeAuthAndMangementSuite++;
					a->AuthAndMangementSuite = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PairCipher", 1, NULL))
			{	if (a->PairCipher == NULL)
				{	if (soap_blist_PairCipher == NULL)
						soap_blist_PairCipher = soap_alloc_block(soap);
					a->PairCipher = (enum tt__Dot11Cipher *)soap_push_block_max(soap, soap_blist_PairCipher, sizeof(enum tt__Dot11Cipher));
					if (a->PairCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->PairCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:PairCipher", a->PairCipher, "tt:Dot11Cipher"))
				{	a->__sizePairCipher++;
					a->PairCipher = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:GroupCipher", 1, NULL))
			{	if (a->GroupCipher == NULL)
				{	if (soap_blist_GroupCipher == NULL)
						soap_blist_GroupCipher = soap_alloc_block(soap);
					a->GroupCipher = (enum tt__Dot11Cipher *)soap_push_block_max(soap, soap_blist_GroupCipher, sizeof(enum tt__Dot11Cipher));
					if (a->GroupCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->GroupCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:GroupCipher", a->GroupCipher, "tt:Dot11Cipher"))
				{	a->__sizeGroupCipher++;
					a->GroupCipher = NULL;
					continue;
				}
			}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuthAndMangementSuite)
			soap_pop_block(soap, soap_blist_AuthAndMangementSuite);
		if (a->__sizeAuthAndMangementSuite)
		{	a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_save_block(soap, soap_blist_AuthAndMangementSuite, NULL, 1);
		}
		else
		{	a->AuthAndMangementSuite = NULL;
			if (soap_blist_AuthAndMangementSuite)
				soap_end_block(soap, soap_blist_AuthAndMangementSuite);
		}
		if (a->PairCipher)
			soap_pop_block(soap, soap_blist_PairCipher);
		if (a->__sizePairCipher)
		{	a->PairCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_PairCipher, NULL, 1);
		}
		else
		{	a->PairCipher = NULL;
			if (soap_blist_PairCipher)
				soap_end_block(soap, soap_blist_PairCipher);
		}
		if (a->GroupCipher)
			soap_pop_block(soap, soap_blist_GroupCipher);
		if (a->__sizeGroupCipher)
		{	a->GroupCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_GroupCipher, NULL, 1);
		}
		else
		{	a->GroupCipher = NULL;
			if (soap_blist_GroupCipher)
				soap_end_block(soap, soap_blist_GroupCipher);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_new_tt__Dot11AvailableNetworks(struct soap *soap, int n)
{
	struct tt__Dot11AvailableNetworks *p;
	struct tt__Dot11AvailableNetworks *a = (struct tt__Dot11AvailableNetworks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11AvailableNetworks));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11AvailableNetworks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworks = 0;
	a->Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Networks)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworks; i++)
		{
			soap_embedded(soap, a->Networks + i, SOAP_TYPE_tt__Dot11AvailableNetworks);
			soap_serialize_tt__Dot11AvailableNetworks(soap, a->Networks + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworks");
	if (a->Networks)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworks; i++)
			if (soap_out_tt__Dot11AvailableNetworks(soap, "tds:Networks", -1, a->Networks + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Networks = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__ScanAvailableDot11NetworksResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11NetworksResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
			{	if (a->Networks == NULL)
				{	if (soap_blist_Networks == NULL)
						soap_blist_Networks = soap_alloc_block(soap);
					a->Networks = (struct tt__Dot11AvailableNetworks *)soap_push_block_max(soap, soap_blist_Networks, sizeof(struct tt__Dot11AvailableNetworks));
					if (a->Networks == NULL)
						return NULL;
					soap_default_tt__Dot11AvailableNetworks(soap, a->Networks);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AvailableNetworks(soap, "tds:Networks", a->Networks, "tt:Dot11AvailableNetworks"))
				{	a->__sizeNetworks++;
					a->Networks = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Networks)
			soap_pop_block(soap, soap_blist_Networks);
		if (a->__sizeNetworks)
		{	a->Networks = (struct tt__Dot11AvailableNetworks *)soap_save_block(soap, soap_blist_Networks, NULL, 1);
		}
		else
		{	a->Networks = NULL;
			if (soap_blist_Networks)
				soap_end_block(soap, soap_blist_Networks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_new__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n)
{
	struct _tds__ScanAvailableDot11NetworksResponse *p;
	struct _tds__ScanAvailableDot11NetworksResponse *a = (struct _tds__ScanAvailableDot11NetworksResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__ScanAvailableDot11NetworksResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__ScanAvailableDot11NetworksResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag ? tag : "tds:ScanAvailableDot11NetworksResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_empty(soap, "tds:InterfaceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__ScanAvailableDot11Networks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11Networks(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_new__tds__ScanAvailableDot11Networks(struct soap *soap, int n)
{
	struct _tds__ScanAvailableDot11Networks *p;
	struct _tds__ScanAvailableDot11Networks *a = (struct _tds__ScanAvailableDot11Networks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__ScanAvailableDot11Networks));
	for (p = a; p && n--; p++)
		soap_default__tds__ScanAvailableDot11Networks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->PairCipher = NULL;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ActiveConfigAlias);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, (char*const*)&a->BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ActiveConfigAlias);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const struct tt__Dot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, (char*const*)&a->BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (!a->ActiveConfigAlias)
	{	if (soap_element_empty(soap, "tt:ActiveConfigAlias", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, (char*const*)&a->ActiveConfigAlias, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	size_t soap_flag_PairCipher = 1;
	size_t soap_flag_GroupCipher = 1;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_ActiveConfigAlias = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Dot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Status(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:BSSID", (char**)&a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			}
			if (soap_flag_PairCipher && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher--;
					continue;
				}
			}
			if (soap_flag_GroupCipher && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher--;
					continue;
				}
			}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			}
			if (soap_flag_ActiveConfigAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", (char**)&a->ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || !a->ActiveConfigAlias))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_new_tt__Dot11Status(struct soap *soap, int n)
{
	struct tt__Dot11Status *p;
	struct tt__Dot11Status *a = (struct tt__Dot11Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11Status));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Status(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (!a->Status)
	{	if (soap_element_empty(soap, "tds:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot11StatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11StatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->Status, "tt:Dot11Status"))
				{	soap_flag_Status--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_new__tds__GetDot11StatusResponse(struct soap *soap, int n)
{
	struct _tds__GetDot11StatusResponse *p;
	struct _tds__GetDot11StatusResponse *a = (struct _tds__GetDot11StatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11StatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11StatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11StatusResponse(soap, tag ? tag : "tds:GetDot11StatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_empty(soap, "tds:InterfaceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Status(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_new__tds__GetDot11Status(struct soap *soap, int n)
{
	struct _tds__GetDot11Status *p;
	struct _tds__GetDot11Status *a = (struct _tds__GetDot11Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11Status));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TKIP);
	soap_default_xsd__boolean(soap, &a->ScanAvailableNetworks);
	soap_default_xsd__boolean(soap, &a->MultipleConfiguration);
	soap_default_xsd__boolean(soap, &a->AdHocStationMode);
	soap_default_xsd__boolean(soap, &a->WEP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TKIP, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->ScanAvailableNetworks, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->MultipleConfiguration, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AdHocStationMode, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WEP, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Dot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TKIP", -1, &a->TKIP, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:ScanAvailableNetworks", -1, &a->ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:MultipleConfiguration", -1, &a->MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AdHocStationMode", -1, &a->AdHocStationMode, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WEP", -1, &a->WEP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities *a, const char *type)
{
	size_t soap_flag_TKIP = 1;
	size_t soap_flag_ScanAvailableNetworks = 1;
	size_t soap_flag_MultipleConfiguration = 1;
	size_t soap_flag_AdHocStationMode = 1;
	size_t soap_flag_WEP = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Dot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Capabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:TKIP", &a->TKIP, "xsd:boolean"))
				{	soap_flag_TKIP--;
					continue;
				}
			}
			if (soap_flag_ScanAvailableNetworks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:ScanAvailableNetworks", &a->ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks--;
					continue;
				}
			}
			if (soap_flag_MultipleConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:MultipleConfiguration", &a->MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration--;
					continue;
				}
			}
			if (soap_flag_AdHocStationMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:AdHocStationMode", &a->AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode--;
					continue;
				}
			}
			if (soap_flag_WEP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:WEP", &a->WEP, "xsd:boolean"))
				{	soap_flag_WEP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP > 0 || soap_flag_ScanAvailableNetworks > 0 || soap_flag_MultipleConfiguration > 0 || soap_flag_AdHocStationMode > 0 || soap_flag_WEP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_new_tt__Dot11Capabilities(struct soap *soap, int n)
{
	struct tt__Dot11Capabilities *p;
	struct tt__Dot11Capabilities *a = (struct tt__Dot11Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot11CapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11CapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetDot11CapabilitiesResponse *p;
	struct _tds__GetDot11CapabilitiesResponse *a = (struct _tds__GetDot11CapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11CapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11CapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag ? tag : "tds:GetDot11CapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Capabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_new__tds__GetDot11Capabilities(struct soap *soap, int n)
{
	struct _tds__GetDot11Capabilities *p;
	struct _tds__GetDot11Capabilities *a = (struct _tds__GetDot11Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11Capabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryCommandResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, (char*const*)&a->AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommandResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", (char**)&a->AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse--;
					continue;
				}
			}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_new__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n)
{
	struct _tds__SendAuxiliaryCommandResponse *p;
	struct _tds__SendAuxiliaryCommandResponse *a = (struct _tds__SendAuxiliaryCommandResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SendAuxiliaryCommandResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SendAuxiliaryCommandResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag ? tag : "tds:SendAuxiliaryCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (!a->AuxiliaryCommand)
	{	if (soap_element_empty(soap, "tds:AuxiliaryCommand", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, (char*const*)&a->AuxiliaryCommand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommand = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommand(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", (char**)&a->AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AuxiliaryCommand))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_new__tds__SendAuxiliaryCommand(struct soap *soap, int n)
{
	struct _tds__SendAuxiliaryCommand *p;
	struct _tds__SendAuxiliaryCommand *a = (struct _tds__SendAuxiliaryCommand*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SendAuxiliaryCommand));
	for (p = a; p && n--; p++)
		soap_default__tds__SendAuxiliaryCommand(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRelayOutputStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_new__tds__SetRelayOutputStateResponse(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputStateResponse *p;
	struct _tds__SetRelayOutputStateResponse *a = (struct _tds__SetRelayOutputStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag ? tag : "tds:SetRelayOutputStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &a->LogicalState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RelayOutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (!a->RelayOutputToken)
	{	if (soap_element_empty(soap, "tds:RelayOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, (char*const*)&a->RelayOutputToken, ""))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_LogicalState = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRelayOutputState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", (char**)&a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			}
			if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutputToken || soap_flag_LogicalState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_new__tds__SetRelayOutputState(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputState *p;
	struct _tds__SetRelayOutputState *a = (struct _tds__SetRelayOutputState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputState));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRelayOutputSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_new__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputSettingsResponse *p;
	struct _tds__SetRelayOutputSettingsResponse *a = (struct _tds__SetRelayOutputSettingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputSettingsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputSettingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag ? tag : "tds:SetRelayOutputSettingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &a->Mode);
	soap_default_xsd__duration(soap, &a->DelayTime);
	soap_default_tt__RelayIdleState(soap, &a->IdleState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->DelayTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const struct tt__RelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (!a->DelayTime)
	{	if (soap_element_empty(soap, "tt:DelayTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, (char*const*)&a->DelayTime, ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->IdleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_DelayTime = 1;
	size_t soap_flag_IdleState = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutputSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->Mode, "tt:RelayMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap_flag_DelayTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:DelayTime", (char**)&a->DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime--;
					continue;
				}
			}
			if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || !a->DelayTime || soap_flag_IdleState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_new_tt__RelayOutputSettings(struct soap *soap, int n)
{
	struct tt__RelayOutputSettings *p;
	struct tt__RelayOutputSettings *a = (struct tt__RelayOutputSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelayOutputSettings));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayOutputSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (!a->RelayOutputToken)
	{	if (soap_element_empty(soap, "tds:RelayOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, (char*const*)&a->RelayOutputToken, ""))
		return soap->error;
	if (!a->Properties)
	{	if (soap_element_empty(soap, "tds:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", (char**)&a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutputToken || !a->Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_new__tds__SetRelayOutputSettings(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputSettings *p;
	struct _tds__SetRelayOutputSettings *a = (struct _tds__SetRelayOutputSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputSettings));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const struct tt__RelayOutput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type))
		return soap->error;
	if (!a->Properties)
	{	if (soap_element_empty(soap, "tt:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelayOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_new_tt__RelayOutput(struct soap *soap, int n)
{
	struct tt__RelayOutput *p;
	struct tt__RelayOutput *a = (struct tt__RelayOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelayOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputs = 0;
	a->RelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputs; i++)
		{
			soap_embedded(soap, a->RelayOutputs + i, SOAP_TYPE_tt__RelayOutput);
			soap_serialize_tt__RelayOutput(soap, a->RelayOutputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputs; i++)
			if (soap_out_tt__RelayOutput(soap, "tds:RelayOutputs", -1, a->RelayOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRelayOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	if (a->RelayOutputs == NULL)
				{	if (soap_blist_RelayOutputs == NULL)
						soap_blist_RelayOutputs = soap_alloc_block(soap);
					a->RelayOutputs = (struct tt__RelayOutput *)soap_push_block_max(soap, soap_blist_RelayOutputs, sizeof(struct tt__RelayOutput));
					if (a->RelayOutputs == NULL)
						return NULL;
					soap_default_tt__RelayOutput(soap, a->RelayOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayOutput(soap, "tds:RelayOutputs", a->RelayOutputs, "tt:RelayOutput"))
				{	a->__sizeRelayOutputs++;
					a->RelayOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RelayOutputs)
			soap_pop_block(soap, soap_blist_RelayOutputs);
		if (a->__sizeRelayOutputs)
		{	a->RelayOutputs = (struct tt__RelayOutput *)soap_save_block(soap, soap_blist_RelayOutputs, NULL, 1);
		}
		else
		{	a->RelayOutputs = NULL;
			if (soap_blist_RelayOutputs)
				soap_end_block(soap, soap_blist_RelayOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_new__tds__GetRelayOutputsResponse(struct soap *soap, int n)
{
	struct _tds__GetRelayOutputsResponse *p;
	struct _tds__GetRelayOutputsResponse *a = (struct _tds__GetRelayOutputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRelayOutputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRelayOutputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag ? tag : "tds:GetRelayOutputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRelayOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_new__tds__GetRelayOutputs(struct soap *soap, int n)
{
	struct _tds__GetRelayOutputs *p;
	struct _tds__GetRelayOutputs *a = (struct _tds__GetRelayOutputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRelayOutputs));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRelayOutputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_new__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__DeleteDot1XConfigurationResponse *p;
	struct _tds__DeleteDot1XConfigurationResponse *a = (struct _tds__DeleteDot1XConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteDot1XConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteDot1XConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag ? tag : "tds:DeleteDot1XConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfigurationToken = 0;
	a->Dot1XConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Dot1XConfigurationToken + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfigurationToken; i++)
			if (soap_out_string(soap, "tds:Dot1XConfigurationToken", -1, (char*const*)(a->Dot1XConfigurationToken + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
			{	if (a->Dot1XConfigurationToken == NULL)
				{	if (soap_blist_Dot1XConfigurationToken == NULL)
						soap_blist_Dot1XConfigurationToken = soap_alloc_block(soap);
					a->Dot1XConfigurationToken = (char **)soap_push_block_max(soap, soap_blist_Dot1XConfigurationToken, sizeof(char *));
					if (a->Dot1XConfigurationToken == NULL)
						return NULL;
					*a->Dot1XConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", (char**)a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeDot1XConfigurationToken++;
					a->Dot1XConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfigurationToken)
			soap_pop_block(soap, soap_blist_Dot1XConfigurationToken);
		if (a->__sizeDot1XConfigurationToken)
		{	a->Dot1XConfigurationToken = (char **)soap_save_block(soap, soap_blist_Dot1XConfigurationToken, NULL, 1);
		}
		else
		{	a->Dot1XConfigurationToken = NULL;
			if (soap_blist_Dot1XConfigurationToken)
				soap_end_block(soap, soap_blist_Dot1XConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_new__tds__DeleteDot1XConfiguration(struct soap *soap, int n)
{
	struct _tds__DeleteDot1XConfiguration *p;
	struct _tds__DeleteDot1XConfiguration *a = (struct _tds__DeleteDot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteDot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteDot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfiguration = 0;
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfiguration; i++)
		{
			soap_embedded(soap, a->Dot1XConfiguration + i, SOAP_TYPE_tt__Dot1XConfiguration);
			soap_serialize_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDot1XConfiguration");
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfiguration; i++)
			if (soap_out_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, a->Dot1XConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot1XConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfiguration", 1, NULL))
			{	if (a->Dot1XConfiguration == NULL)
				{	if (soap_blist_Dot1XConfiguration == NULL)
						soap_blist_Dot1XConfiguration = soap_alloc_block(soap);
					a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_push_block_max(soap, soap_blist_Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration));
					if (a->Dot1XConfiguration == NULL)
						return NULL;
					soap_default_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	a->__sizeDot1XConfiguration++;
					a->Dot1XConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfiguration)
			soap_pop_block(soap, soap_blist_Dot1XConfiguration);
		if (a->__sizeDot1XConfiguration)
		{	a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_save_block(soap, soap_blist_Dot1XConfiguration, NULL, 1);
		}
		else
		{	a->Dot1XConfiguration = NULL;
			if (soap_blist_Dot1XConfiguration)
				soap_end_block(soap, soap_blist_Dot1XConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_new__tds__GetDot1XConfigurationsResponse(struct soap *soap, int n)
{
	struct _tds__GetDot1XConfigurationsResponse *p;
	struct _tds__GetDot1XConfigurationsResponse *a = (struct _tds__GetDot1XConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot1XConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot1XConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag ? tag : "tds:GetDot1XConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot1XConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_new__tds__GetDot1XConfigurations(struct soap *soap, int n)
{
	struct _tds__GetDot1XConfigurations *p;
	struct _tds__GetDot1XConfigurations *a = (struct _tds__GetDot1XConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot1XConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot1XConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (!a->Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_new__tds__GetDot1XConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__GetDot1XConfigurationResponse *p;
	struct _tds__GetDot1XConfigurationResponse *a = (struct _tds__GetDot1XConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot1XConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot1XConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag ? tag : "tds:GetDot1XConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Dot1XConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (!a->Dot1XConfigurationToken)
	{	if (soap_element_empty(soap, "tds:Dot1XConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, (char*const*)&a->Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", (char**)&a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_new__tds__GetDot1XConfiguration(struct soap *soap, int n)
{
	struct _tds__GetDot1XConfiguration *p;
	struct _tds__GetDot1XConfiguration *a = (struct _tds__GetDot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_new__tds__SetDot1XConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__SetDot1XConfigurationResponse *p;
	struct _tds__SetDot1XConfigurationResponse *a = (struct _tds__SetDot1XConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDot1XConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDot1XConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag ? tag : "tds:SetDot1XConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (!a->Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_new__tds__SetDot1XConfiguration(struct soap *soap, int n)
{
	struct _tds__SetDot1XConfiguration *p;
	struct _tds__SetDot1XConfiguration *a = (struct _tds__SetDot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_new__tds__CreateDot1XConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__CreateDot1XConfigurationResponse *p;
	struct _tds__CreateDot1XConfigurationResponse *a = (struct _tds__CreateDot1XConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateDot1XConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateDot1XConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag ? tag : "tds:CreateDot1XConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
	soap_default_string(soap, &a->Identity);
	soap_default_string(soap, &a->AnonymousID);
	soap_default_int(soap, &a->EAPMethod);
	a->__sizeCACertificateID = 0;
	a->CACertificateID = NULL;
	a->EAPMethodConfiguration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Dot1XConfigurationToken);
	soap_serialize_string(soap, (char*const*)&a->Identity);
	soap_serialize_string(soap, (char*const*)&a->AnonymousID);
	soap_embedded(soap, &a->EAPMethod, SOAP_TYPE_int);
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificateID; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->CACertificateID + i));
		}
	}
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &a->EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type))
		return soap->error;
	if (!a->Dot1XConfigurationToken)
	{	if (soap_element_empty(soap, "tt:Dot1XConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, (char*const*)&a->Dot1XConfigurationToken, ""))
		return soap->error;
	if (!a->Identity)
	{	if (soap_element_empty(soap, "tt:Identity", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Identity", -1, (char*const*)&a->Identity, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:AnonymousID", -1, (char*const*)&a->AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->EAPMethod, ""))
		return soap->error;
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificateID; i++)
			if (soap_out_string(soap, "tt:CACertificateID", -1, (char*const*)(a->CACertificateID + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	size_t soap_flag_Identity = 1;
	size_t soap_flag_AnonymousID = 1;
	size_t soap_flag_EAPMethod = 1;
	struct soap_blist *soap_blist_CACertificateID = NULL;
	size_t soap_flag_EAPMethodConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Dot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", (char**)&a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_Identity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Identity", (char**)&a->Identity, "xsd:string"))
				{	soap_flag_Identity--;
					continue;
				}
			}
			if (soap_flag_AnonymousID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:AnonymousID", (char**)&a->AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID--;
					continue;
				}
			}
			if (soap_flag_EAPMethod && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EAPMethod", &a->EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CACertificateID", 1, NULL))
			{	if (a->CACertificateID == NULL)
				{	if (soap_blist_CACertificateID == NULL)
						soap_blist_CACertificateID = soap_alloc_block(soap);
					a->CACertificateID = (char **)soap_push_block_max(soap, soap_blist_CACertificateID, sizeof(char *));
					if (a->CACertificateID == NULL)
						return NULL;
					*a->CACertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:CACertificateID", (char**)a->CACertificateID, "xsd:token"))
				{	a->__sizeCACertificateID++;
					a->CACertificateID = NULL;
					continue;
				}
			}
			if (soap_flag_EAPMethodConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificateID)
			soap_pop_block(soap, soap_blist_CACertificateID);
		if (a->__sizeCACertificateID)
		{	a->CACertificateID = (char **)soap_save_block(soap, soap_blist_CACertificateID, NULL, 1);
		}
		else
		{	a->CACertificateID = NULL;
			if (soap_blist_CACertificateID)
				soap_end_block(soap, soap_blist_CACertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfigurationToken || !a->Identity || soap_flag_EAPMethod > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_new_tt__Dot1XConfiguration(struct soap *soap, int n)
{
	struct tt__Dot1XConfiguration *p;
	struct tt__Dot1XConfiguration *a = (struct tt__Dot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (!a->Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_new__tds__CreateDot1XConfiguration(struct soap *soap, int n)
{
	struct _tds__CreateDot1XConfiguration *p;
	struct _tds__CreateDot1XConfiguration *a = (struct _tds__CreateDot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateDot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateDot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificatesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_new__tds__LoadCACertificatesResponse(struct soap *soap, int n)
{
	struct _tds__LoadCACertificatesResponse *p;
	struct _tds__LoadCACertificatesResponse *a = (struct _tds__LoadCACertificatesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCACertificatesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCACertificatesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag ? tag : "tds:LoadCACertificatesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, struct _tds__LoadCACertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificates(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_alloc_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block_max(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
		{	a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		}
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCACertificate < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_new__tds__LoadCACertificates(struct soap *soap, int n)
{
	struct _tds__LoadCACertificates *p;
	struct _tds__LoadCACertificates *a = (struct _tds__LoadCACertificates*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCACertificates));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCACertificates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->IssuerDN);
	soap_default_string(soap, &a->SubjectDN);
	a->KeyUsage = NULL;
	a->ExtendedKeyUsage = NULL;
	a->KeyLength = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->SerialNum);
	soap_default_string(soap, &a->SignatureAlgorithm);
	a->Validity = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->IssuerDN);
	soap_serialize_string(soap, (char*const*)&a->SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &a->KeyLength);
	soap_serialize_string(soap, (char*const*)&a->Version);
	soap_serialize_string(soap, (char*const*)&a->SerialNum);
	soap_serialize_string(soap, (char*const*)&a->SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &a->Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tt:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:IssuerDN", -1, (char*const*)&a->IssuerDN, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SubjectDN", -1, (char*const*)&a->SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->KeyLength, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Version", -1, (char*const*)&a->Version, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SerialNum", -1, (char*const*)&a->SerialNum, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SignatureAlgorithm", -1, (char*const*)&a->SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_IssuerDN = 1;
	size_t soap_flag_SubjectDN = 1;
	size_t soap_flag_KeyUsage = 1;
	size_t soap_flag_ExtendedKeyUsage = 1;
	size_t soap_flag_KeyLength = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_SerialNum = 1;
	size_t soap_flag_SignatureAlgorithm = 1;
	size_t soap_flag_Validity = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_IssuerDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:IssuerDN", (char**)&a->IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN--;
					continue;
				}
			}
			if (soap_flag_SubjectDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:SubjectDN", (char**)&a->SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN--;
					continue;
				}
			}
			if (soap_flag_KeyUsage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage--;
					continue;
				}
			}
			if (soap_flag_ExtendedKeyUsage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage--;
					continue;
				}
			}
			if (soap_flag_KeyLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:KeyLength", &a->KeyLength, "xsd:int"))
				{	soap_flag_KeyLength--;
					continue;
				}
			}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Version", (char**)&a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			}
			if (soap_flag_SerialNum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:SerialNum", (char**)&a->SerialNum, "xsd:string"))
				{	soap_flag_SerialNum--;
					continue;
				}
			}
			if (soap_flag_SignatureAlgorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:SignatureAlgorithm", (char**)&a->SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm--;
					continue;
				}
			}
			if (soap_flag_Validity && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_new_tt__CertificateInformation(struct soap *soap, int n)
{
	struct tt__CertificateInformation *p;
	struct tt__CertificateInformation *a = (struct tt__CertificateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__CertificateInformation(soap, &a->CertificateInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (!a->CertificateInformation)
	{	if (soap_element_empty(soap, "tds:CertificateInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->CertificateInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	size_t soap_flag_CertificateInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificateInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_new__tds__GetCertificateInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetCertificateInformationResponse *p;
	struct _tds__GetCertificateInformationResponse *a = (struct _tds__GetCertificateInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificateInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificateInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag ? tag : "tds:GetCertificateInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tds:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tds:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, struct _tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_new__tds__GetCertificateInformation(struct soap *soap, int n)
{
	struct _tds__GetCertificateInformation *p;
	struct _tds__GetCertificateInformation *a = (struct _tds__GetCertificateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificateInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCertificateWithPrivateKeyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKeyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_new__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int n)
{
	struct _tds__LoadCertificateWithPrivateKeyResponse *p;
	struct _tds__LoadCertificateWithPrivateKeyResponse *a = (struct _tds__LoadCertificateWithPrivateKeyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCertificateWithPrivateKeyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag ? tag : "tds:LoadCertificateWithPrivateKeyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
	a->PrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &a->PrivateKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (!a->Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
		return soap->error;
	if (!a->PrivateKey)
	{	if (soap_element_empty(soap, "tt:PrivateKey", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->PrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	size_t soap_flag_PrivateKey = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateWithPrivateKey(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			}
			if (soap_flag_PrivateKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Certificate || !a->PrivateKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_new_tt__CertificateWithPrivateKey(struct soap *soap, int n)
{
	struct tt__CertificateWithPrivateKey *p;
	struct tt__CertificateWithPrivateKey *a = (struct tt__CertificateWithPrivateKey*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateWithPrivateKey));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateWithPrivateKey(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateWithPrivateKey = 0;
	a->CertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateWithPrivateKey; i++)
		{
			soap_embedded(soap, a->CertificateWithPrivateKey + i, SOAP_TYPE_tt__CertificateWithPrivateKey);
			soap_serialize_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateWithPrivateKey; i++)
			if (soap_out_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, a->CertificateWithPrivateKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateWithPrivateKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKey(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateWithPrivateKey", 1, NULL))
			{	if (a->CertificateWithPrivateKey == NULL)
				{	if (soap_blist_CertificateWithPrivateKey == NULL)
						soap_blist_CertificateWithPrivateKey = soap_alloc_block(soap);
					a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_push_block_max(soap, soap_blist_CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey));
					if (a->CertificateWithPrivateKey == NULL)
						return NULL;
					soap_default_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", a->CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
				{	a->__sizeCertificateWithPrivateKey++;
					a->CertificateWithPrivateKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateWithPrivateKey)
			soap_pop_block(soap, soap_blist_CertificateWithPrivateKey);
		if (a->__sizeCertificateWithPrivateKey)
		{	a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_save_block(soap, soap_blist_CertificateWithPrivateKey, NULL, 1);
		}
		else
		{	a->CertificateWithPrivateKey = NULL;
			if (soap_blist_CertificateWithPrivateKey)
				soap_end_block(soap, soap_blist_CertificateWithPrivateKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateWithPrivateKey < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_new__tds__LoadCertificateWithPrivateKey(struct soap *soap, int n)
{
	struct _tds__LoadCertificateWithPrivateKey *p;
	struct _tds__LoadCertificateWithPrivateKey *a = (struct _tds__LoadCertificateWithPrivateKey*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCertificateWithPrivateKey));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCertificateWithPrivateKey(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCACertificate");
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCACertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificatesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_alloc_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block_max(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
		{	a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		}
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_new__tds__GetCACertificatesResponse(struct soap *soap, int n)
{
	struct _tds__GetCACertificatesResponse *p;
	struct _tds__GetCACertificatesResponse *a = (struct _tds__GetCACertificatesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCACertificatesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCACertificatesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCACertificatesResponse(soap, tag ? tag : "tds:GetCACertificatesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, struct _tds__GetCACertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificates(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_new__tds__GetCACertificates(struct soap *soap, int n)
{
	struct _tds__GetCACertificates *p;
	struct _tds__GetCACertificates *a = (struct _tds__GetCACertificates*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCACertificates));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCACertificates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_new__tds__SetClientCertificateModeResponse(struct soap *soap, int n)
{
	struct _tds__SetClientCertificateModeResponse *p;
	struct _tds__SetClientCertificateModeResponse *a = (struct _tds__SetClientCertificateModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetClientCertificateModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetClientCertificateModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag ? tag : "tds:SetClientCertificateModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_new__tds__SetClientCertificateMode(struct soap *soap, int n)
{
	struct _tds__SetClientCertificateMode *p;
	struct _tds__SetClientCertificateMode *a = (struct _tds__SetClientCertificateMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetClientCertificateMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetClientCertificateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_xsd__boolean(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_new__tds__GetClientCertificateModeResponse(struct soap *soap, int n)
{
	struct _tds__GetClientCertificateModeResponse *p;
	struct _tds__GetClientCertificateModeResponse *a = (struct _tds__GetClientCertificateModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetClientCertificateModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetClientCertificateModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag ? tag : "tds:GetClientCertificateModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__GetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_new__tds__GetClientCertificateMode(struct soap *soap, int n)
{
	struct _tds__GetClientCertificateMode *p;
	struct _tds__GetClientCertificateMode *a = (struct _tds__GetClientCertificateMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetClientCertificateMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetClientCertificateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificatesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_new__tds__LoadCertificatesResponse(struct soap *soap, int n)
{
	struct _tds__LoadCertificatesResponse *p;
	struct _tds__LoadCertificatesResponse *a = (struct _tds__LoadCertificatesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCertificatesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCertificatesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCertificatesResponse(soap, tag ? tag : "tds:LoadCertificatesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNVTCertificate = 0;
	a->NVTCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeNVTCertificate; i++)
		{
			soap_embedded(soap, a->NVTCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NVTCertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeNVTCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NVTCertificate", -1, a->NVTCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, struct _tds__LoadCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_NVTCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__LoadCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificates(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NVTCertificate", 1, NULL))
			{	if (a->NVTCertificate == NULL)
				{	if (soap_blist_NVTCertificate == NULL)
						soap_blist_NVTCertificate = soap_alloc_block(soap);
					a->NVTCertificate = (struct tt__Certificate *)soap_push_block_max(soap, soap_blist_NVTCertificate, sizeof(struct tt__Certificate));
					if (a->NVTCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NVTCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NVTCertificate", a->NVTCertificate, "tt:Certificate"))
				{	a->__sizeNVTCertificate++;
					a->NVTCertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NVTCertificate)
			soap_pop_block(soap, soap_blist_NVTCertificate);
		if (a->__sizeNVTCertificate)
		{	a->NVTCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NVTCertificate, NULL, 1);
		}
		else
		{	a->NVTCertificate = NULL;
			if (soap_blist_NVTCertificate)
				soap_end_block(soap, soap_blist_NVTCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNVTCertificate < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_new__tds__LoadCertificates(struct soap *soap, int n)
{
	struct _tds__LoadCertificates *p;
	struct _tds__LoadCertificates *a = (struct _tds__LoadCertificates*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__LoadCertificates));
	for (p = a; p && n--; p++)
		soap_default__tds__LoadCertificates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a, const char *tag, const char *type)
{
	if (soap_out__tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Pkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &a->Pkcs10Request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (!a->Pkcs10Request)
	{	if (soap_element_empty(soap, "tds:Pkcs10Request", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->Pkcs10Request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	size_t soap_flag_Pkcs10Request = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetPkcs10RequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10RequestResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Pkcs10Request))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_new__tds__GetPkcs10RequestResponse(struct soap *soap, int n)
{
	struct _tds__GetPkcs10RequestResponse *p;
	struct _tds__GetPkcs10RequestResponse *a = (struct _tds__GetPkcs10RequestResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetPkcs10RequestResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetPkcs10RequestResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag ? tag : "tds:GetPkcs10RequestResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->Attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->Subject);
	soap_serialize_PointerTott__BinaryData(soap, &a->Attributes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tds:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tds:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, (char*const*)&a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, struct _tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_Attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetPkcs10Request*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10Request(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Subject", (char**)&a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			}
			if (soap_flag_Attributes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_new__tds__GetPkcs10Request(struct soap *soap, int n)
{
	struct _tds__GetPkcs10Request *p;
	struct _tds__GetPkcs10Request *a = (struct _tds__GetPkcs10Request*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetPkcs10Request));
	for (p = a; p && n--; p++)
		soap_default__tds__GetPkcs10Request(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificatesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_new__tds__DeleteCertificatesResponse(struct soap *soap, int n)
{
	struct _tds__DeleteCertificatesResponse *p;
	struct _tds__DeleteCertificatesResponse *a = (struct _tds__DeleteCertificatesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteCertificatesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteCertificatesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag ? tag : "tds:DeleteCertificatesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateID = 0;
	a->CertificateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateID; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->CertificateID + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateID; i++)
			if (soap_out_string(soap, "tds:CertificateID", -1, (char*const*)(a->CertificateID + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, struct _tds__DeleteCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateID = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificates(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateID", 1, NULL))
			{	if (a->CertificateID == NULL)
				{	if (soap_blist_CertificateID == NULL)
						soap_blist_CertificateID = soap_alloc_block(soap);
					a->CertificateID = (char **)soap_push_block_max(soap, soap_blist_CertificateID, sizeof(char *));
					if (a->CertificateID == NULL)
						return NULL;
					*a->CertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:CertificateID", (char**)a->CertificateID, "xsd:token"))
				{	a->__sizeCertificateID++;
					a->CertificateID = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateID)
			soap_pop_block(soap, soap_blist_CertificateID);
		if (a->__sizeCertificateID)
		{	a->CertificateID = (char **)soap_save_block(soap, soap_blist_CertificateID, NULL, 1);
		}
		else
		{	a->CertificateID = NULL;
			if (soap_blist_CertificateID)
				soap_end_block(soap, soap_blist_CertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_new__tds__DeleteCertificates(struct soap *soap, int n)
{
	struct _tds__DeleteCertificates *p;
	struct _tds__DeleteCertificates *a = (struct _tds__DeleteCertificates*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteCertificates));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteCertificates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_new__tds__SetCertificatesStatusResponse(struct soap *soap, int n)
{
	struct _tds__SetCertificatesStatusResponse *p;
	struct _tds__SetCertificatesStatusResponse *a = (struct _tds__SetCertificatesStatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetCertificatesStatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetCertificatesStatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag ? tag : "tds:SetCertificatesStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatus *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_alloc_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block_max(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
		{	a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		}
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_new__tds__SetCertificatesStatus(struct soap *soap, int n)
{
	struct _tds__SetCertificatesStatus *p;
	struct _tds__SetCertificatesStatus *a = (struct _tds__SetCertificatesStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetCertificatesStatus));
	for (p = a; p && n--; p++)
		soap_default__tds__SetCertificatesStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_xsd__boolean(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const struct tt__CertificateStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tt:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__CertificateStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_new_tt__CertificateStatus(struct soap *soap, int n)
{
	struct tt__CertificateStatus *p;
	struct tt__CertificateStatus *a = (struct tt__CertificateStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCertificateStatus");
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < (int)a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_alloc_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block_max(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
		{	a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		}
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_new__tds__GetCertificatesStatusResponse(struct soap *soap, int n)
{
	struct _tds__GetCertificatesStatusResponse *p;
	struct _tds__GetCertificatesStatusResponse *a = (struct _tds__GetCertificatesStatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificatesStatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificatesStatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag ? tag : "tds:GetCertificatesStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_new__tds__GetCertificatesStatus(struct soap *soap, int n)
{
	struct _tds__GetCertificatesStatus *p;
	struct _tds__GetCertificatesStatus *a = (struct _tds__GetCertificatesStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificatesStatus));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificatesStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNvtCertificate = 0;
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeNvtCertificate; i++)
		{
			soap_embedded(soap, a->NvtCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NvtCertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNvtCertificate");
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < (int)a->__sizeNvtCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NvtCertificate", -1, a->NvtCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NvtCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NvtCertificate", 1, NULL))
			{	if (a->NvtCertificate == NULL)
				{	if (soap_blist_NvtCertificate == NULL)
						soap_blist_NvtCertificate = soap_alloc_block(soap);
					a->NvtCertificate = (struct tt__Certificate *)soap_push_block_max(soap, soap_blist_NvtCertificate, sizeof(struct tt__Certificate));
					if (a->NvtCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NvtCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NvtCertificate", a->NvtCertificate, "tt:Certificate"))
				{	a->__sizeNvtCertificate++;
					a->NvtCertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NvtCertificate)
			soap_pop_block(soap, soap_blist_NvtCertificate);
		if (a->__sizeNvtCertificate)
		{	a->NvtCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NvtCertificate, NULL, 1);
		}
		else
		{	a->NvtCertificate = NULL;
			if (soap_blist_NvtCertificate)
				soap_end_block(soap, soap_blist_NvtCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_new__tds__GetCertificatesResponse(struct soap *soap, int n)
{
	struct _tds__GetCertificatesResponse *p;
	struct _tds__GetCertificatesResponse *a = (struct _tds__GetCertificatesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificatesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificatesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificatesResponse(soap, tag ? tag : "tds:GetCertificatesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, struct _tds__GetCertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificates(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_new__tds__GetCertificates(struct soap *soap, int n)
{
	struct _tds__GetCertificates *p;
	struct _tds__GetCertificates *a = (struct _tds__GetCertificates*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCertificates));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCertificates(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Certificate(struct soap *soap, struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Certificate(struct soap *soap, const struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const struct tt__Certificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_empty(soap, "tt:CertificateID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (!a->Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, struct tt__Certificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Certificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Certificate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CertificateID || !a->Certificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_new_tt__Certificate(struct soap *soap, int n)
{
	struct tt__Certificate *p;
	struct tt__Certificate *a = (struct tt__Certificate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Certificate));
	for (p = a; p && n--; p++)
		soap_default_tt__Certificate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Certificate(struct soap *soap, const struct tt__Certificate *a, const char *tag, const char *type)
{
	if (soap_out_tt__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, struct tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Certificate(soap, &a->NvtCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (!a->NvtCertificate)
	{	if (soap_element_empty(soap, "tds:NvtCertificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, struct _tds__CreateCertificateResponse *a, const char *type)
{
	size_t soap_flag_NvtCertificate = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateCertificateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->NvtCertificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_new__tds__CreateCertificateResponse(struct soap *soap, int n)
{
	struct _tds__CreateCertificateResponse *p;
	struct _tds__CreateCertificateResponse *a = (struct _tds__CreateCertificateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateCertificateResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateCertificateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateCertificateResponse(soap, tag ? tag : "tds:CreateCertificateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->ValidNotBefore = NULL;
	a->ValidNotAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->Subject);
	soap_serialize_PointerTodateTime(soap, &a->ValidNotBefore);
	soap_serialize_PointerTodateTime(soap, &a->ValidNotAfter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, (char*const*)&a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotBefore", -1, &a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotAfter", -1, &a->ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, struct _tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateCertificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Subject", (char**)&a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotBefore", &a->ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotAfter", &a->ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_new__tds__CreateCertificate(struct soap *soap, int n)
{
	struct _tds__CreateCertificate *p;
	struct _tds__CreateCertificate *a = (struct _tds__CreateCertificate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateCertificate));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateCertificate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_new__tds__SetAccessPolicyResponse(struct soap *soap, int n)
{
	struct _tds__SetAccessPolicyResponse *p;
	struct _tds__SetAccessPolicyResponse *a = (struct _tds__SetAccessPolicyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetAccessPolicyResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetAccessPolicyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag ? tag : "tds:SetAccessPolicyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolicyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicy(struct soap *soap, const struct _tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &a->PolicyFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (!a->PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, struct _tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_PolicyFile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_new__tds__SetAccessPolicy(struct soap *soap, int n)
{
	struct _tds__SetAccessPolicy *p;
	struct _tds__SetAccessPolicy *a = (struct _tds__SetAccessPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetAccessPolicy));
	for (p = a; p && n--; p++)
		soap_default__tds__SetAccessPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetAccessPolicy(struct soap *soap, const struct _tds__SetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BinaryData(struct soap *soap, struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__base64Binary(soap, &a->Data);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__base64Binary(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const struct tt__BinaryData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, a->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BinaryData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BinaryData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &a->xmime__contentType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__base64Binary(soap, "tt:Data", &a->Data, "xsd:base64Binary"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_new_tt__BinaryData(struct soap *soap, int n)
{
	struct tt__BinaryData *p;
	struct tt__BinaryData *a = (struct tt__BinaryData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BinaryData));
	for (p = a; p && n--; p++)
		soap_default_tt__BinaryData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a, const char *tag, const char *type)
{
	if (soap_out_tt__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, struct tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolicyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetAccessPolicyResponse(struct soap *soap, const struct _tds__GetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &a->PolicyFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (!a->PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__GetAccessPolicyResponse *a, const char *type)
{
	size_t soap_flag_PolicyFile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetAccessPolicyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile--;
					continue;
				}
			}
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_new__tds__GetAccessPolicyResponse(struct soap *soap, int n)
{
	struct _tds__GetAccessPolicyResponse *p;
	struct _tds__GetAccessPolicyResponse *a = (struct _tds__GetAccessPolicyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetAccessPolicyResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetAccessPolicyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetAccessPolicyResponse(struct soap *soap, const struct _tds__GetAccessPolicyResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetAccessPolicyResponse(soap, tag ? tag : "tds:GetAccessPolicyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetAccessPolicy(struct soap *soap, const struct _tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const struct _tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, struct _tds__GetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetAccessPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetAccessPolicy * SOAP_FMAC4 soap_new__tds__GetAccessPolicy(struct soap *soap, int n)
{
	struct _tds__GetAccessPolicy *p;
	struct _tds__GetAccessPolicy *a = (struct _tds__GetAccessPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetAccessPolicy));
	for (p = a; p && n--; p++)
		soap_default__tds__GetAccessPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetAccessPolicy(struct soap *soap, const struct _tds__GetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveIPAddressFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_new__tds__RemoveIPAddressFilterResponse(struct soap *soap, int n)
{
	struct _tds__RemoveIPAddressFilterResponse *p;
	struct _tds__RemoveIPAddressFilterResponse *a = (struct _tds__RemoveIPAddressFilterResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveIPAddressFilterResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveIPAddressFilterResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag ? tag : "tds:RemoveIPAddressFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (!a->IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveIPAddressFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_new__tds__RemoveIPAddressFilter(struct soap *soap, int n)
{
	struct _tds__RemoveIPAddressFilter *p;
	struct _tds__RemoveIPAddressFilter *a = (struct _tds__RemoveIPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveIPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveIPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddIPAddressFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_new__tds__AddIPAddressFilterResponse(struct soap *soap, int n)
{
	struct _tds__AddIPAddressFilterResponse *p;
	struct _tds__AddIPAddressFilterResponse *a = (struct _tds__AddIPAddressFilterResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddIPAddressFilterResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__AddIPAddressFilterResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag ? tag : "tds:AddIPAddressFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (!a->IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddIPAddressFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_new__tds__AddIPAddressFilter(struct soap *soap, int n)
{
	struct _tds__AddIPAddressFilter *p;
	struct _tds__AddIPAddressFilter *a = (struct _tds__AddIPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddIPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default__tds__AddIPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetIPAddressFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_new__tds__SetIPAddressFilterResponse(struct soap *soap, int n)
{
	struct _tds__SetIPAddressFilterResponse *p;
	struct _tds__SetIPAddressFilterResponse *a = (struct _tds__SetIPAddressFilterResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetIPAddressFilterResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetIPAddressFilterResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag ? tag : "tds:SetIPAddressFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (!a->IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetIPAddressFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_new__tds__SetIPAddressFilter(struct soap *soap, int n)
{
	struct _tds__SetIPAddressFilter *p;
	struct _tds__SetIPAddressFilter *a = (struct _tds__SetIPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetIPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default__tds__SetIPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &a->Type);
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_embedded(soap, a->IPv4Address + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_embedded(soap, a->IPv6Address + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->IPv6Address + i);
		}
	}
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter *a, const char *type)
{
	size_t soap_flag_Type = 1;
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddressFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(struct tt__PrefixedIPv4Address));
					if (a->IPv4Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->IPv4Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:PrefixedIPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(struct tt__PrefixedIPv6Address));
					if (a->IPv6Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->IPv6Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:PrefixedIPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_new_tt__IPAddressFilter(struct soap *soap, int n)
{
	struct tt__IPAddressFilter *p;
	struct tt__IPAddressFilter *a = (struct tt__IPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (!a->IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetIPAddressFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			}
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_new__tds__GetIPAddressFilterResponse(struct soap *soap, int n)
{
	struct _tds__GetIPAddressFilterResponse *p;
	struct _tds__GetIPAddressFilterResponse *a = (struct _tds__GetIPAddressFilterResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetIPAddressFilterResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetIPAddressFilterResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag ? tag : "tds:GetIPAddressFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetIPAddressFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_new__tds__GetIPAddressFilter(struct soap *soap, int n)
{
	struct _tds__GetIPAddressFilter *p;
	struct _tds__GetIPAddressFilter *a = (struct _tds__GetIPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetIPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default__tds__GetIPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetZeroConfigurationResponse(struct soap *soap, const struct _tds__SetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetZeroConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_new__tds__SetZeroConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__SetZeroConfigurationResponse *p;
	struct _tds__SetZeroConfigurationResponse *a = (struct _tds__SetZeroConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetZeroConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetZeroConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetZeroConfigurationResponse(struct soap *soap, const struct _tds__SetZeroConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetZeroConfigurationResponse(soap, tag ? tag : "tds:SetZeroConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetZeroConfiguration(struct soap *soap, const struct _tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_empty(soap, "tds:InterfaceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__SetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetZeroConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->InterfaceToken || soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration * SOAP_FMAC4 soap_new__tds__SetZeroConfiguration(struct soap *soap, int n)
{
	struct _tds__SetZeroConfiguration *p;
	struct _tds__SetZeroConfiguration *a = (struct _tds__SetZeroConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetZeroConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__SetZeroConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetZeroConfiguration(struct soap *soap, const struct _tds__SetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizeAddresses = 0;
	a->Addresses = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Addresses)
	{	int i;
		for (i = 0; i < (int)a->__sizeAddresses; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->Addresses + i));
		}
	}
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &a->Extension);
#endif
}


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
