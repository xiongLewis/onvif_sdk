/* soapC.c
   Generated by gSOAP 2.8.117 for onvif_release2/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.117 2021-11-04 01:18:35 GMT")

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__NotifyMessageNotSupportedFaultType *p;
	struct wsnt__NotifyMessageNotSupportedFaultType *a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotifyMessageNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__sizeUnsupportedPolicy = 0;
	a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnsupportedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{	const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnsupportedPolicy", -1, (char*const*)(void*)&soap_tmp_UnsupportedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnsupportedPolicy", 1, NULL))
			{	if (a->UnsupportedPolicy == NULL)
				{	if (soap_blist_UnsupportedPolicy == NULL)
						soap_blist_UnsupportedPolicy = soap_alloc_block(soap);
					a->UnsupportedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
					if (a->UnsupportedPolicy == NULL)
						return NULL;
					*a->UnsupportedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnsupportedPolicy", (char**)a->UnsupportedPolicy, "xsd:QName"))
				{	a->__sizeUnsupportedPolicy++;
					a->UnsupportedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnsupportedPolicy)
			soap_pop_block(soap, soap_blist_UnsupportedPolicy);
		if (a->__sizeUnsupportedPolicy)
		{	a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
		}
		else
		{	a->UnsupportedPolicy = NULL;
			if (soap_blist_UnsupportedPolicy)
				soap_end_block(soap, soap_blist_UnsupportedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnsupportedPolicyRequestFaultType *p;
	struct wsnt__UnsupportedPolicyRequestFaultType *a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnsupportedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__sizeUnrecognizedPolicy = 0;
	a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnrecognizedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{	const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnrecognizedPolicy", -1, (char*const*)(void*)&soap_tmp_UnrecognizedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnrecognizedPolicy", 1, NULL))
			{	if (a->UnrecognizedPolicy == NULL)
				{	if (soap_blist_UnrecognizedPolicy == NULL)
						soap_blist_UnrecognizedPolicy = soap_alloc_block(soap);
					a->UnrecognizedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
					if (a->UnrecognizedPolicy == NULL)
						return NULL;
					*a->UnrecognizedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnrecognizedPolicy", (char**)a->UnrecognizedPolicy, "xsd:QName"))
				{	a->__sizeUnrecognizedPolicy++;
					a->UnrecognizedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnrecognizedPolicy)
			soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
		if (a->__sizeUnrecognizedPolicy)
		{	a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
		}
		else
		{	a->UnrecognizedPolicy = NULL;
			if (soap_blist_UnrecognizedPolicy)
				soap_end_block(soap, soap_blist_UnrecognizedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnrecognizedPolicyRequestFaultType *p;
	struct wsnt__UnrecognizedPolicyRequestFaultType *a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidMessageContentExpressionFaultType *p;
	struct wsnt__InvalidMessageContentExpressionFaultType *a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidMessageContentExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
			soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n)
{
	struct wsnt__MultipleTopicsSpecifiedFaultType *p;
	struct wsnt__MultipleTopicsSpecifiedFaultType *a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *p;
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_Description *p;
	struct _wsnt__TopicNotSupportedFaultType_Description *a = (struct _wsnt__TopicNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
			soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicNotSupportedFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicNotSupportedFaultType *p;
	struct wsnt__TopicNotSupportedFaultType *a = (struct wsnt__TopicNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_Description *p;
	struct _wsnt__InvalidTopicExpressionFaultType_Description *a = (struct _wsnt__InvalidTopicExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidTopicExpressionFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidTopicExpressionFaultType *p;
	struct wsnt__InvalidTopicExpressionFaultType *a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidTopicExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidTopicExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionDialectUnknownFaultType *p;
	struct wsnt__TopicExpressionDialectUnknownFaultType *a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_FaultCause *p;
	struct _wsnt__InvalidFilterFaultType_FaultCause *a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_Description *p;
	struct _wsnt__InvalidFilterFaultType_Description *a = (struct _wsnt__InvalidFilterFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_ErrorCode *p;
	struct _wsnt__InvalidFilterFaultType_ErrorCode *a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnknownFilter + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)(void*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_alloc_block(soap);
					a->UnknownFilter = (char **)soap_push_block_max(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", (char**)a->UnknownFilter, "xsd:QName"))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
		{	a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		}
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidFilterFaultType *p;
	struct wsnt__InvalidFilterFaultType *a = (struct wsnt__InvalidFilterFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidFilterFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidFilterFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p;
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_Description *p;
	struct _wsnt__SubscribeCreationFailedFaultType_Description *a = (struct _wsnt__SubscribeCreationFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p;
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__SubscribeCreationFailedFaultType *p;
	struct wsnt__SubscribeCreationFailedFaultType *a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscribeCreationFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscribeCreationFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDReference(struct soap *soap, struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDReference(struct soap *soap, const char *tag, int id, const struct tt__OSDReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_in_tt__OSDReference(struct soap *soap, const char *tag, struct tt__OSDReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct tt__OSDReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__OSDReference(soap, a);
	if (!soap_in_tt__ReferenceToken(soap, tag, (char**)&a->__item, "tt:OSDReference"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_new_tt__OSDReference(struct soap *soap, int n)
{
	struct tt__OSDReference *p;
	struct tt__OSDReference *a = (struct tt__OSDReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDReference));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_get_tt__OSDReference(struct soap *soap, struct tt__OSDReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->EngineToken);
	soap_default_tt__ReferenceToken(soap, &a->EngineConfigToken);
	a->__sizeInputToken = 0;
	a->InputToken = NULL;
	a->__sizeReceiverToken = 0;
	a->ReceiverToken = NULL;
	a->Multicast = NULL;
	a->Subscription = NULL;
	soap_default_tt__ModeOfOperation(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineConfigToken);
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->InputToken + i));
		}
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ReceiverToken + i));
		}
	}
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_PointerTott__Config(soap, &a->Subscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineControl *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineControl), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->EngineToken)
	{	if (soap_element_empty(soap, "tt:EngineToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:EngineToken", -1, (char*const*)&a->EngineToken, ""))
		return soap->error;
	if (!a->EngineConfigToken)
	{	if (soap_element_empty(soap, "tt:EngineConfigToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:EngineConfigToken", -1, (char*const*)&a->EngineConfigToken, ""))
		return soap->error;
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
			if (soap_out_string(soap, "tt:InputToken", -1, (char*const*)(a->InputToken + i), ""))
				return soap->error;
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
			if (soap_out_string(soap, "tt:ReceiverToken", -1, (char*const*)(a->ReceiverToken + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (!a->Subscription)
	{	if (soap_element_empty(soap, "tt:Subscription", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Config(soap, "tt:Subscription", -1, &a->Subscription, ""))
		return soap->error;
	if (soap_out_tt__ModeOfOperation(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_in_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, struct tt__AnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_EngineToken = 1;
	size_t soap_flag_EngineConfigToken = 1;
	struct soap_blist *soap_blist_InputToken = NULL;
	struct soap_blist *soap_blist_ReceiverToken = NULL;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Subscription = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineControl(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_EngineToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineToken", (char**)&a->EngineToken, "tt:ReferenceToken"))
				{	soap_flag_EngineToken--;
					continue;
				}
			}
			if (soap_flag_EngineConfigToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineConfigToken", (char**)&a->EngineConfigToken, "tt:ReferenceToken"))
				{	soap_flag_EngineConfigToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputToken", 1, NULL))
			{	if (a->InputToken == NULL)
				{	if (soap_blist_InputToken == NULL)
						soap_blist_InputToken = soap_alloc_block(soap);
					a->InputToken = (char **)soap_push_block_max(soap, soap_blist_InputToken, sizeof(char *));
					if (a->InputToken == NULL)
						return NULL;
					*a->InputToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputToken", (char**)a->InputToken, "tt:ReferenceToken"))
				{	a->__sizeInputToken++;
					a->InputToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ReceiverToken", 1, NULL))
			{	if (a->ReceiverToken == NULL)
				{	if (soap_blist_ReceiverToken == NULL)
						soap_blist_ReceiverToken = soap_alloc_block(soap);
					a->ReceiverToken = (char **)soap_push_block_max(soap, soap_blist_ReceiverToken, sizeof(char *));
					if (a->ReceiverToken == NULL)
						return NULL;
					*a->ReceiverToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", (char**)a->ReceiverToken, "tt:ReferenceToken"))
				{	a->__sizeReceiverToken++;
					a->ReceiverToken = NULL;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Subscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:Subscription", &a->Subscription, "tt:Config"))
				{	soap_flag_Subscription--;
					continue;
				}
			}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ModeOfOperation(soap, "tt:Mode", &a->Mode, "tt:ModeOfOperation"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputToken)
			soap_pop_block(soap, soap_blist_InputToken);
		if (a->__sizeInputToken)
		{	a->InputToken = (char **)soap_save_block(soap, soap_blist_InputToken, NULL, 1);
		}
		else
		{	a->InputToken = NULL;
			if (soap_blist_InputToken)
				soap_end_block(soap, soap_blist_InputToken);
		}
		if (a->ReceiverToken)
			soap_pop_block(soap, soap_blist_ReceiverToken);
		if (a->__sizeReceiverToken)
		{	a->ReceiverToken = (char **)soap_save_block(soap, soap_blist_ReceiverToken, NULL, 1);
		}
		else
		{	a->ReceiverToken = NULL;
			if (soap_blist_ReceiverToken)
				soap_end_block(soap, soap_blist_ReceiverToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->EngineToken || !a->EngineConfigToken || a->__sizeInputToken < 1 || a->__sizeReceiverToken < 1 || !a->Subscription || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineControl, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_new_tt__AnalyticsEngineControl(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineControl *p;
	struct tt__AnalyticsEngineControl *a = (struct tt__AnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineControl(soap, tag ? tag : "tt:AnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_get_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->SourceIdentification = NULL;
	a->VideoInput = NULL;
	a->MetadataInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__SourceIdentification(soap, &a->SourceIdentification);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoInput);
	soap_serialize_PointerTott__MetadataInput(soap, &a->MetadataInput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInput), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceIdentification)
	{	if (soap_element_empty(soap, "tt:SourceIdentification", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", -1, &a->SourceIdentification, ""))
		return soap->error;
	if (!a->VideoInput)
	{	if (soap_element_empty(soap, "tt:VideoInput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", -1, &a->VideoInput, ""))
		return soap->error;
	if (!a->MetadataInput)
	{	if (soap_element_empty(soap, "tt:MetadataInput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MetadataInput(soap, "tt:MetadataInput", -1, &a->MetadataInput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceIdentification = 1;
	size_t soap_flag_VideoInput = 1;
	size_t soap_flag_MetadataInput = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_SourceIdentification && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", &a->SourceIdentification, "tt:SourceIdentification"))
				{	soap_flag_SourceIdentification--;
					continue;
				}
			}
			if (soap_flag_VideoInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", &a->VideoInput, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoInput--;
					continue;
				}
			}
			if (soap_flag_MetadataInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInput(soap, "tt:MetadataInput", &a->MetadataInput, "tt:MetadataInput"))
				{	soap_flag_MetadataInput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceIdentification || !a->VideoInput || !a->MetadataInput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInput, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInput(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInput *p;
	struct tt__AnalyticsEngineInput *a = (struct tt__AnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInput(soap, tag ? tag : "tt:AnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngine(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngine *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngine), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_in_tt__AnalyticsEngine(struct soap *soap, const char *tag, struct tt__AnalyticsEngine *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngine(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsDeviceEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->AnalyticsEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngine, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_new_tt__AnalyticsEngine(struct soap *soap, int n)
{
	struct tt__AnalyticsEngine *p;
	struct tt__AnalyticsEngine *a = (struct tt__AnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngine(soap, tag ? tag : "tt:AnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_get_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventFilter(struct soap *soap, struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventFilter(struct soap *soap, const char *tag, int id, const struct tt__EventFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_in_tt__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EventFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_new_tt__EventFilter(struct soap *soap, int n)
{
	struct tt__EventFilter *p;
	struct tt__EventFilter *a = (struct tt__EventFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__EventFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventFilter(soap, tag ? tag : "tt:EventFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_get_tt__EventFilter(struct soap *soap, struct tt__EventFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNode(struct soap *soap, struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__Name(soap, &a->Name);
	a->SupportedPTZSpaces = NULL;
	soap_default_int(soap, &a->MaximumNumberOfPresets);
	soap_default_xsd__boolean(soap, &a->HomeSupported);
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->FixedHomePosition = NULL;
	a->GeoMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &a->SupportedPTZSpaces);
	soap_embedded(soap, &a->MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &a->HomeSupported, SOAP_TYPE_xsd__boolean);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, (char*const*)(a->AuxiliaryCommands + i));
		}
	}
	soap_serialize_PointerTott__PTZNodeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const struct tt__PTZNode *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->FixedHomePosition)
	{	soap_set_attr(soap, "FixedHomePosition", soap_xsd__boolean2s(soap, *a->FixedHomePosition), 1);
	}
	if (a->GeoMove)
	{	soap_set_attr(soap, "GeoMove", soap_xsd__boolean2s(soap, *a->GeoMove), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->SupportedPTZSpaces)
	{	if (soap_element_empty(soap, "tt:SupportedPTZSpaces", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->SupportedPTZSpaces, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:HomeSupported", -1, &a->HomeSupported, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
			if (soap_out_string(soap, "tt:AuxiliaryCommands", -1, (char*const*)(a->AuxiliaryCommands + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_SupportedPTZSpaces = 1;
	size_t soap_flag_MaximumNumberOfPresets = 1;
	size_t soap_flag_HomeSupported = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNode(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "FixedHomePosition", 5, 0);
		if (t)
		{
			if (!(a->FixedHomePosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedHomePosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoMove", 5, 0);
		if (t)
		{
			if (!(a->GeoMove = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GeoMove))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces--;
					continue;
				}
			}
			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets--;
					continue;
				}
			}
			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:HomeSupported", &a->HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_alloc_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block_max(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", (char**)a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
		{	a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		}
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedPTZSpaces || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_new_tt__PTZNode(struct soap *soap, int n)
{
	struct tt__PTZNode *p;
	struct tt__PTZNode *a = (struct tt__PTZNode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNode));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, struct tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->IdleState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalInput(struct soap *soap, const char *tag, int id, const struct tt__DigitalInput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->IdleState)
	{	soap_set_attr(soap, "IdleState", soap_tt__DigitalIdleState2s(soap, *a->IdleState), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalInput), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_in_tt__DigitalInput(struct soap *soap, const char *tag, struct tt__DigitalInput *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DigitalInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DigitalInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "IdleState", 5, 0);
		if (t)
		{
			if (!(a->IdleState = (enum tt__DigitalIdleState *)soap_malloc(soap, sizeof(enum tt__DigitalIdleState))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__DigitalIdleState(soap, t, a->IdleState))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_new_tt__DigitalInput(struct soap *soap, int n)
{
	struct tt__DigitalInput *p;
	struct tt__DigitalInput *a = (struct tt__DigitalInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DigitalInput));
	for (p = a; p && n--; p++)
		soap_default_tt__DigitalInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__DigitalInput(soap, tag ? tag : "tt:DigitalInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_get_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->OutputToken)
	{	if (soap_element_empty(soap, "tt:OutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, (char*const*)&a->OutputToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_in_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, struct tt__VideoOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", (char**)&a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->OutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfiguration, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_new_tt__VideoOutputConfiguration(struct soap *soap, int n)
{
	struct tt__VideoOutputConfiguration *p;
	struct tt__VideoOutputConfiguration *a = (struct tt__VideoOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputConfiguration(soap, tag ? tag : "tt:VideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_get_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Layout = NULL;
	a->Resolution = NULL;
	a->RefreshRate = NULL;
	a->AspectRatio = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTofloat(soap, &a->RefreshRate);
	soap_serialize_PointerTofloat(soap, &a->AspectRatio);
	soap_serialize_PointerTott__VideoOutputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutput(struct soap *soap, const char *tag, int id, const struct tt__VideoOutput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutput), type))
		return soap->error;
	if (!a->Layout)
	{	if (soap_element_empty(soap, "tt:Layout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Layout(soap, "tt:Layout", -1, &a->Layout, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:RefreshRate", -1, &a->RefreshRate, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:AspectRatio", -1, &a->AspectRatio, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoOutputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_in_tt__VideoOutput(struct soap *soap, const char *tag, struct tt__VideoOutput *a, const char *type)
{
	size_t soap_flag_Layout = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RefreshRate = 1;
	size_t soap_flag_AspectRatio = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Layout(soap, "tt:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_RefreshRate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:RefreshRate", &a->RefreshRate, "xsd:float"))
				{	soap_flag_RefreshRate--;
					continue;
				}
			}
			if (soap_flag_AspectRatio && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:AspectRatio", &a->AspectRatio, "xsd:float"))
				{	soap_flag_AspectRatio--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputExtension(soap, "tt:Extension", &a->Extension, "tt:VideoOutputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Layout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_new_tt__VideoOutput(struct soap *soap, int n)
{
	struct tt__VideoOutput *p;
	struct tt__VideoOutput *a = (struct tt__VideoOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutput(soap, tag ? tag : "tt:VideoOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_get_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Multicast = NULL;
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoder2Configuration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_in_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, struct tt__AudioEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2Configuration, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_new_tt__AudioEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__AudioEncoder2Configuration *p;
	struct tt__AudioEncoder2Configuration *a = (struct tt__AudioEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoder2Configuration(soap, tag ? tag : "tt:AudioEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_get_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Resolution = NULL;
	a->RateControl = NULL;
	a->Multicast = NULL;
	soap_default_float(soap, &a->Quality);
	a->GovLength = NULL;
	soap_default_string(soap, &a->Profile);
	a->GuaranteedFrameRate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__VideoResolution2(soap, &a->Resolution);
	soap_serialize_PointerTott__VideoRateControl2(soap, &a->RateControl);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoder2Configuration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->GovLength)
	{	soap_set_attr(soap, "GovLength", soap_int2s(soap, *a->GovLength), 1);
	}
	if (a->Profile)
		soap_set_attr(soap, "Profile", soap_string2s(soap, a->Profile), 1);
	if (a->GuaranteedFrameRate)
	{	soap_set_attr(soap, "GuaranteedFrameRate", soap_xsd__boolean2s(soap, *a->GuaranteedFrameRate), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution2(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl2(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_in_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, struct tt__VideoEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Quality = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "GovLength", 5, 0);
		if (t)
		{
			if (!(a->GovLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->GovLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Profile", 1, 0), &a->Profile))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRate", 5, 0);
		if (t)
		{
			if (!(a->GuaranteedFrameRate = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GuaranteedFrameRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution2(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution2"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl2(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl2"))
				{	soap_flag_RateControl--;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || !a->Resolution || soap_flag_Quality > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2Configuration, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_new_tt__VideoEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__VideoEncoder2Configuration *p;
	struct tt__VideoEncoder2Configuration *a = (struct tt__VideoEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoder2Configuration(soap, tag ? tag : "tt:VideoEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_get_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteOSDResponse(struct soap *soap, const struct _trt__DeleteOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteOSDResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_in__trt__DeleteOSDResponse(struct soap *soap, const char *tag, struct _trt__DeleteOSDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteOSDResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteOSDResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSDResponse, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_new__trt__DeleteOSDResponse(struct soap *soap, int n)
{
	struct _trt__DeleteOSDResponse *p;
	struct _trt__DeleteOSDResponse *a = (struct _trt__DeleteOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteOSDResponse(struct soap *soap, const struct _trt__DeleteOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteOSDResponse(soap, tag ? tag : "trt:DeleteOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_get__trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteOSD(struct soap *soap, const struct _trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteOSD(struct soap *soap, const char *tag, int id, const struct _trt__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteOSD), type))
		return soap->error;
	if (!a->OSDToken)
	{	if (soap_element_empty(soap, "trt:OSDToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_in__trt__DeleteOSD(struct soap *soap, const char *tag, struct _trt__DeleteOSD *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteOSD*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteOSD(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSD, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_new__trt__DeleteOSD(struct soap *soap, int n)
{
	struct _trt__DeleteOSD *p;
	struct _trt__DeleteOSD *a = (struct _trt__DeleteOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteOSD(struct soap *soap, const struct _trt__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteOSD(soap, tag ? tag : "trt:DeleteOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_get__trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateOSDResponse(struct soap *soap, const struct _trt__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__CreateOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateOSDResponse), type))
		return soap->error;
	if (a->OSDToken)
		soap_element_result(soap, "trt:OSDToken");
	if (!a->OSDToken)
	{	if (soap_element_empty(soap, "trt:OSDToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_in__trt__CreateOSDResponse(struct soap *soap, const char *tag, struct _trt__CreateOSDResponse *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateOSDResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateOSDResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			}
			soap_check_result(soap, "trt:OSDToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSDResponse, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_new__trt__CreateOSDResponse(struct soap *soap, int n)
{
	struct _trt__CreateOSDResponse *p;
	struct _trt__CreateOSDResponse *a = (struct _trt__CreateOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateOSDResponse(struct soap *soap, const struct _trt__CreateOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateOSDResponse(soap, tag ? tag : "trt:CreateOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_get__trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateOSD(struct soap *soap, const struct _trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateOSD(struct soap *soap, const char *tag, int id, const struct _trt__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_empty(soap, "trt:OSD", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_in__trt__CreateOSD(struct soap *soap, const char *tag, struct _trt__CreateOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateOSD*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateOSD(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSD, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_new__trt__CreateOSD(struct soap *soap, int n)
{
	struct _trt__CreateOSD *p;
	struct _trt__CreateOSD *a = (struct _trt__CreateOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateOSD(struct soap *soap, const struct _trt__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateOSD(soap, tag ? tag : "trt:CreateOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_get__trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDOptionsResponse(struct soap *soap, const struct _trt__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfigurationOptions(soap, &a->OSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDOptionsResponse), type))
		return soap->error;
	if (a->OSDOptions)
		soap_element_result(soap, "trt:OSDOptions");
	if (!a->OSDOptions)
	{	if (soap_element_empty(soap, "trt:OSDOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDConfigurationOptions(soap, "trt:OSDOptions", -1, &a->OSDOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_in__trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDOptionsResponse *a, const char *type)
{
	size_t soap_flag_OSDOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSDOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationOptions(soap, "trt:OSDOptions", &a->OSDOptions, "tt:OSDConfigurationOptions"))
				{	soap_flag_OSDOptions--;
					continue;
				}
			}
			soap_check_result(soap, "trt:OSDOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptionsResponse, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_new__trt__GetOSDOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDOptionsResponse *p;
	struct _trt__GetOSDOptionsResponse *a = (struct _trt__GetOSDOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDOptionsResponse(struct soap *soap, const struct _trt__GetOSDOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDOptionsResponse(soap, tag ? tag : "trt:GetOSDOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_get__trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDOptions(struct soap *soap, const struct _trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDOptions), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_in__trt__GetOSDOptions(struct soap *soap, const char *tag, struct _trt__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSDOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptions, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_new__trt__GetOSDOptions(struct soap *soap, int n)
{
	struct _trt__GetOSDOptions *p;
	struct _trt__GetOSDOptions *a = (struct _trt__GetOSDOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDOptions(struct soap *soap, const struct _trt__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDOptions(soap, tag ? tag : "trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_get__trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetOSDResponse(struct soap *soap, const struct _trt__SetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetOSDResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_in__trt__SetOSDResponse(struct soap *soap, const char *tag, struct _trt__SetOSDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetOSDResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetOSDResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSDResponse, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_new__trt__SetOSDResponse(struct soap *soap, int n)
{
	struct _trt__SetOSDResponse *p;
	struct _trt__SetOSDResponse *a = (struct _trt__SetOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetOSDResponse(struct soap *soap, const struct _trt__SetOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetOSDResponse(soap, tag ? tag : "trt:SetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_get__trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetOSD(struct soap *soap, struct _trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetOSD(struct soap *soap, const struct _trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetOSD(struct soap *soap, const char *tag, int id, const struct _trt__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_empty(soap, "trt:OSD", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_in__trt__SetOSD(struct soap *soap, const char *tag, struct _trt__SetOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetOSD*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetOSD(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSD, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_new__trt__SetOSD(struct soap *soap, int n)
{
	struct _trt__SetOSD *p;
	struct _trt__SetOSD *a = (struct _trt__SetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__SetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetOSD(struct soap *soap, const struct _trt__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetOSD(soap, tag ? tag : "trt:SetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_get__trt__SetOSD(struct soap *soap, struct _trt__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDResponse(struct soap *soap, const struct _trt__GetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDResponse), type))
		return soap->error;
	if (a->OSD)
		soap_element_result(soap, "trt:OSD");
	if (!a->OSD)
	{	if (soap_element_empty(soap, "trt:OSD", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_in__trt__GetOSDResponse(struct soap *soap, const char *tag, struct _trt__GetOSDResponse *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSDResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			}
			soap_check_result(soap, "trt:OSD");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSD))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDResponse, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_new__trt__GetOSDResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDResponse *p;
	struct _trt__GetOSDResponse *a = (struct _trt__GetOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDResponse(struct soap *soap, const struct _trt__GetOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDResponse(soap, tag ? tag : "trt:GetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_get__trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSD(struct soap *soap, struct _trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSD(struct soap *soap, const struct _trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSD(struct soap *soap, const char *tag, int id, const struct _trt__GetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSD), type))
		return soap->error;
	if (!a->OSDToken)
	{	if (soap_element_empty(soap, "trt:OSDToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_in__trt__GetOSD(struct soap *soap, const char *tag, struct _trt__GetOSD *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSD*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSD(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OSDToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSD, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_new__trt__GetOSD(struct soap *soap, int n)
{
	struct _trt__GetOSD *p;
	struct _trt__GetOSD *a = (struct _trt__GetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSD(struct soap *soap, const struct _trt__GetOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSD(soap, tag ? tag : "trt:GetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_get__trt__GetOSD(struct soap *soap, struct _trt__GetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->VideoSourceConfigurationToken = NULL;
	soap_default_tt__OSDType(soap, &a->Type);
	a->Position = NULL;
	a->TextString = NULL;
	a->Image = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfiguration(struct soap *soap, const struct tt__OSDConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDReference(soap, &a->VideoSourceConfigurationToken);
	soap_embedded(soap, &a->Type, SOAP_TYPE_tt__OSDType);
	soap_serialize_PointerTott__OSDPosConfiguration(soap, &a->Position);
	soap_serialize_PointerTott__OSDTextConfiguration(soap, &a->TextString);
	soap_serialize_PointerTott__OSDImgConfiguration(soap, &a->Image);
	soap_serialize_PointerTott__OSDConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfiguration), type))
		return soap->error;
	if (!a->VideoSourceConfigurationToken)
	{	if (soap_element_empty(soap, "tt:VideoSourceConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", -1, &a->VideoSourceConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__OSDType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDPosConfiguration(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfiguration(soap, "tt:TextString", -1, &a->TextString, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfiguration(soap, "tt:Image", -1, &a->Image, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_in_tt__OSDConfiguration(struct soap *soap, const char *tag, struct tt__OSDConfiguration *a, const char *type)
{
	size_t soap_flag_VideoSourceConfigurationToken = 1;
	size_t soap_flag_Type = 1;
	size_t soap_flag_Position = 1;
	size_t soap_flag_TextString = 1;
	size_t soap_flag_Image = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfigurationToken && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", &a->VideoSourceConfigurationToken, "tt:OSDReference"))
				{	soap_flag_VideoSourceConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__OSDType(soap, "tt:Type", &a->Type, "tt:OSDType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfiguration(soap, "tt:Position", &a->Position, "tt:OSDPosConfiguration"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_TextString && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfiguration(soap, "tt:TextString", &a->TextString, "tt:OSDTextConfiguration"))
				{	soap_flag_TextString--;
					continue;
				}
			}
			if (soap_flag_Image && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfiguration(soap, "tt:Image", &a->Image, "tt:OSDImgConfiguration"))
				{	soap_flag_Image--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfigurationToken || soap_flag_Type > 0 || !a->Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_new_tt__OSDConfiguration(struct soap *soap, int n)
{
	struct tt__OSDConfiguration *p;
	struct tt__OSDConfiguration *a = (struct tt__OSDConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfiguration(struct soap *soap, const struct tt__OSDConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_get_tt__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOSDs = 0;
	a->OSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDsResponse(struct soap *soap, const struct _trt__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
		{
			soap_embedded(soap, a->OSDs + i, SOAP_TYPE_tt__OSDConfiguration);
			soap_serialize_tt__OSDConfiguration(soap, a->OSDs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOSDs");
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
			if (soap_out_tt__OSDConfiguration(soap, "trt:OSDs", -1, a->OSDs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_in__trt__GetOSDsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_OSDs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSDsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:OSDs", 1, NULL))
			{	if (a->OSDs == NULL)
				{	if (soap_blist_OSDs == NULL)
						soap_blist_OSDs = soap_alloc_block(soap);
					a->OSDs = (struct tt__OSDConfiguration *)soap_push_block_max(soap, soap_blist_OSDs, sizeof(struct tt__OSDConfiguration));
					if (a->OSDs == NULL)
						return NULL;
					soap_default_tt__OSDConfiguration(soap, a->OSDs);
				}
				soap_revert(soap);
				if (soap_in_tt__OSDConfiguration(soap, "trt:OSDs", a->OSDs, "tt:OSDConfiguration"))
				{	a->__sizeOSDs++;
					a->OSDs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOSDs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OSDs)
			soap_pop_block(soap, soap_blist_OSDs);
		if (a->__sizeOSDs)
		{	a->OSDs = (struct tt__OSDConfiguration *)soap_save_block(soap, soap_blist_OSDs, NULL, 1);
		}
		else
		{	a->OSDs = NULL;
			if (soap_blist_OSDs)
				soap_end_block(soap, soap_blist_OSDs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDsResponse, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_new__trt__GetOSDsResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDsResponse *p;
	struct _trt__GetOSDsResponse *a = (struct _trt__GetOSDsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDsResponse(struct soap *soap, const struct _trt__GetOSDsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDsResponse(soap, tag ? tag : "trt:GetOSDsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_get__trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDs(struct soap *soap, const struct _trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDs(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDs), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_in__trt__GetOSDs(struct soap *soap, const char *tag, struct _trt__GetOSDs *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetOSDs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDs, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_new__trt__GetOSDs(struct soap *soap, int n)
{
	struct _trt__GetOSDs *p;
	struct _trt__GetOSDs *a = (struct _trt__GetOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDs));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDs(struct soap *soap, const struct _trt__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDs(soap, tag ? tag : "trt:GetOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_get__trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Reboot);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoSourceModeResponse(struct soap *soap, const struct _trt__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Reboot, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoSourceModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoSourceModeResponse), type))
		return soap->error;
	soap_element_result(soap, "trt:Reboot");
	if (soap_out_xsd__boolean(soap, "trt:Reboot", -1, &a->Reboot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_in__trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, struct _trt__SetVideoSourceModeResponse *a, const char *type)
{
	size_t soap_flag_Reboot = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetVideoSourceModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetVideoSourceModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "trt:Reboot", &a->Reboot, "xsd:boolean"))
				{	soap_flag_Reboot--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Reboot");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reboot > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceModeResponse, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_new__trt__SetVideoSourceModeResponse(struct soap *soap, int n)
{
	struct _trt__SetVideoSourceModeResponse *p;
	struct _trt__SetVideoSourceModeResponse *a = (struct _trt__SetVideoSourceModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetVideoSourceModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetVideoSourceModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoSourceModeResponse(struct soap *soap, const struct _trt__SetVideoSourceModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetVideoSourceModeResponse(soap, tag ? tag : "trt:SetVideoSourceModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_get__trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoSourceModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceModeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoSourceMode(struct soap *soap, const struct _trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceModeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoSourceMode), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "trt:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->VideoSourceModeToken)
	{	if (soap_element_empty(soap, "trt:VideoSourceModeToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceModeToken", -1, (char*const*)&a->VideoSourceModeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_in__trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct _trt__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_VideoSourceModeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetVideoSourceMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetVideoSourceMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap_flag_VideoSourceModeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceModeToken", (char**)&a->VideoSourceModeToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceModeToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->VideoSourceModeToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceMode, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_new__trt__SetVideoSourceMode(struct soap *soap, int n)
{
	struct _trt__SetVideoSourceMode *p;
	struct _trt__SetVideoSourceMode *a = (struct _trt__SetVideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetVideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default__trt__SetVideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoSourceMode(struct soap *soap, const struct _trt__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetVideoSourceMode(soap, tag ? tag : "trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_get__trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoSourceModes = 0;
	a->VideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceModesResponse(struct soap *soap, const struct _trt__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
		{
			soap_embedded(soap, a->VideoSourceModes + i, SOAP_TYPE_trt__VideoSourceMode);
			soap_serialize_trt__VideoSourceMode(soap, a->VideoSourceModes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceModesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceModesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoSourceModes");
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
			if (soap_out_trt__VideoSourceMode(soap, "trt:VideoSourceModes", -1, a->VideoSourceModes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoSourceModes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSourceModesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceModesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSourceModes", 1, NULL))
			{	if (a->VideoSourceModes == NULL)
				{	if (soap_blist_VideoSourceModes == NULL)
						soap_blist_VideoSourceModes = soap_alloc_block(soap);
					a->VideoSourceModes = (struct trt__VideoSourceMode *)soap_push_block_max(soap, soap_blist_VideoSourceModes, sizeof(struct trt__VideoSourceMode));
					if (a->VideoSourceModes == NULL)
						return NULL;
					soap_default_trt__VideoSourceMode(soap, a->VideoSourceModes);
				}
				soap_revert(soap);
				if (soap_in_trt__VideoSourceMode(soap, "trt:VideoSourceModes", a->VideoSourceModes, "trt:VideoSourceMode"))
				{	a->__sizeVideoSourceModes++;
					a->VideoSourceModes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoSourceModes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceModes)
			soap_pop_block(soap, soap_blist_VideoSourceModes);
		if (a->__sizeVideoSourceModes)
		{	a->VideoSourceModes = (struct trt__VideoSourceMode *)soap_save_block(soap, soap_blist_VideoSourceModes, NULL, 1);
		}
		else
		{	a->VideoSourceModes = NULL;
			if (soap_blist_VideoSourceModes)
				soap_end_block(soap, soap_blist_VideoSourceModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeVideoSourceModes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModesResponse, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourceModesResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceModesResponse *p;
	struct _trt__GetVideoSourceModesResponse *a = (struct _trt__GetVideoSourceModesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceModesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceModesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceModesResponse(struct soap *soap, const struct _trt__GetVideoSourceModesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceModesResponse(soap, tag ? tag : "trt:GetVideoSourceModesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceModes(struct soap *soap, const struct _trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceModes), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "trt:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_in__trt__GetVideoSourceModes(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModes *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSourceModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceModes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModes, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_new__trt__GetVideoSourceModes(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceModes *p;
	struct _trt__GetVideoSourceModes *a = (struct _trt__GetVideoSourceModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceModes));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceModes(struct soap *soap, const struct _trt__GetVideoSourceModes *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceModes(soap, tag ? tag : "trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_get__trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "trt:MediaUri");
	if (!a->MediaUri)
	{	if (soap_element_empty(soap, "trt:MediaUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetSnapshotUriResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUriResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			}
			soap_check_result(soap, "trt:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MediaUri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUriResponse, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_new__trt__GetSnapshotUriResponse(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUriResponse *p;
	struct _trt__GetSnapshotUriResponse *a = (struct _trt__GetSnapshotUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUriResponse(soap, tag ? tag : "trt:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUri), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_in__trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetSnapshotUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUri, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_new__trt__GetSnapshotUri(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUri *p;
	struct _trt__GetSnapshotUri *a = (struct _trt__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUri(soap, tag ? tag : "trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_get__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetSynchronizationPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetSynchronizationPointResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPointResponse, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_new__trt__SetSynchronizationPointResponse(struct soap *soap, int n)
{
	struct _trt__SetSynchronizationPointResponse *p;
	struct _trt__SetSynchronizationPointResponse *a = (struct _trt__SetSynchronizationPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetSynchronizationPointResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetSynchronizationPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetSynchronizationPointResponse(soap, tag ? tag : "trt:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPoint), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__SetSynchronizationPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetSynchronizationPoint(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPoint, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_new__trt__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct _trt__SetSynchronizationPoint *p;
	struct _trt__SetSynchronizationPoint *a = (struct _trt__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default__trt__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetSynchronizationPoint(soap, tag ? tag : "trt:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__StopMulticastStreamingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StopMulticastStreamingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreamingResponse, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_new__trt__StopMulticastStreamingResponse(struct soap *soap, int n)
{
	struct _trt__StopMulticastStreamingResponse *p;
	struct _trt__StopMulticastStreamingResponse *a = (struct _trt__StopMulticastStreamingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StopMulticastStreamingResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__StopMulticastStreamingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__StopMulticastStreamingResponse(soap, tag ? tag : "trt:StopMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreaming), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_in__trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__StopMulticastStreaming*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StopMulticastStreaming(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreaming, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_new__trt__StopMulticastStreaming(struct soap *soap, int n)
{
	struct _trt__StopMulticastStreaming *p;
	struct _trt__StopMulticastStreaming *a = (struct _trt__StopMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StopMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default__trt__StopMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out__trt__StopMulticastStreaming(soap, tag ? tag : "trt:StopMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_get__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__StartMulticastStreamingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StartMulticastStreamingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreamingResponse, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_new__trt__StartMulticastStreamingResponse(struct soap *soap, int n)
{
	struct _trt__StartMulticastStreamingResponse *p;
	struct _trt__StartMulticastStreamingResponse *a = (struct _trt__StartMulticastStreamingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StartMulticastStreamingResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__StartMulticastStreamingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__StartMulticastStreamingResponse(soap, tag ? tag : "trt:StartMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreaming), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_in__trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__StartMulticastStreaming*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StartMulticastStreaming(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreaming, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_new__trt__StartMulticastStreaming(struct soap *soap, int n)
{
	struct _trt__StartMulticastStreaming *p;
	struct _trt__StartMulticastStreaming *a = (struct _trt__StartMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StartMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default__trt__StartMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out__trt__StartMulticastStreaming(soap, tag ? tag : "trt:StartMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_get__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "trt:MediaUri");
	if (!a->MediaUri)
	{	if (soap_element_empty(soap, "trt:MediaUri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_in__trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetStreamUriResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetStreamUriResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			}
			soap_check_result(soap, "trt:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MediaUri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUriResponse, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_new__trt__GetStreamUriResponse(struct soap *soap, int n)
{
	struct _trt__GetStreamUriResponse *p;
	struct _trt__GetStreamUriResponse *a = (struct _trt__GetStreamUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetStreamUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetStreamUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetStreamUriResponse(soap, tag ? tag : "trt:GetStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_get__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_empty(soap, "trt:StreamSetup", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StreamSetup(soap, "trt:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_in__trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetStreamUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetStreamUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StreamSetup(soap, "trt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUri, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_new__trt__GetStreamUri(struct soap *soap, int n)
{
	struct _trt__GetStreamUri *p;
	struct _trt__GetStreamUri *a = (struct _trt__GetStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetStreamUri));
	for (p = a; p && n--; p++)
		soap_default__trt__GetStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetStreamUri(soap, tag ? tag : "trt:GetStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_get__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->TotalNumber);
	a->JPEG = NULL;
	a->H264 = NULL;
	a->MPEG4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TotalNumber, SOAP_TYPE_int);
	soap_serialize_PointerToint(soap, &a->JPEG);
	soap_serialize_PointerToint(soap, &a->H264);
	soap_serialize_PointerToint(soap, &a->MPEG4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), type))
		return soap->error;
	soap_element_result(soap, "trt:TotalNumber");
	if (soap_out_int(soap, "trt:TotalNumber", -1, &a->TotalNumber, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *type)
{
	size_t soap_flag_TotalNumber = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_MPEG4 = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "trt:TotalNumber", &a->TotalNumber, "xsd:int"))
				{	soap_flag_TotalNumber--;
					continue;
				}
			}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "trt:JPEG", &a->JPEG, "xsd:int"))
				{	soap_flag_JPEG--;
					continue;
				}
			}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "trt:H264", &a->H264, "xsd:int"))
				{	soap_flag_H264--;
					continue;
				}
			}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "trt:MPEG4", &a->MPEG4, "xsd:int"))
				{	soap_flag_MPEG4--;
					continue;
				}
			}
			soap_check_result(soap, "trt:TotalNumber");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalNumber > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, int n)
{
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *p;
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag ? tag : "trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_get__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, int n)
{
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *p;
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances));
	for (p = a; p && n--; p++)
		soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag ? tag : "trt:GetGuaranteedNumberOfVideoEncoderInstances", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_get__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trt:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioDecoderConfigurationOptionsResponse *p;
	struct _trt__GetAudioDecoderConfigurationOptionsResponse *a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioDecoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioDecoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioDecoderConfigurationOptions *p;
	struct _trt__GetAudioDecoderConfigurationOptions *a = (struct _trt__GetAudioDecoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioDecoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioDecoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioDecoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trt:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioOutputConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputConfigurationOptionsResponse *p;
	struct _trt__GetAudioOutputConfigurationOptionsResponse *a = (struct _trt__GetAudioOutputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioOutputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputConfigurationOptions *p;
	struct _trt__GetAudioOutputConfigurationOptions *a = (struct _trt__GetAudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputConfigurationOptions(soap, tag ? tag : "trt:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MetadataConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trt:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MetadataConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetMetadataConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationOptions(soap, "trt:Options", &a->Options, "tt:MetadataConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurationOptionsResponse *p;
	struct _trt__GetMetadataConfigurationOptionsResponse *a = (struct _trt__GetMetadataConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurationOptionsResponse(soap, tag ? tag : "trt:GetMetadataConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationOptions(struct soap *soap, const struct _trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetMetadataConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptions, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurationOptions *p;
	struct _trt__GetMetadataConfigurationOptions *a = (struct _trt__GetMetadataConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationOptions(struct soap *soap, const struct _trt__GetMetadataConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurationOptions(soap, tag ? tag : "trt:GetMetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trt:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationOptionsResponse *p;
	struct _trt__GetAudioEncoderConfigurationOptionsResponse *a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioEncoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationOptions *p;
	struct _trt__GetAudioEncoderConfigurationOptions *a = (struct _trt__GetAudioEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trt:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
